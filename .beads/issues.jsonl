{"id":"bf-0fe","title":"A.1: Initialize monorepo structure","description":"# Task: Initialize Monorepo Structure\n\n## Context\nThis is the first task - setting up the bun workspace monorepo that all packages will live in. This foundational structure enables clean separation of concerns and independent package development.\n\n## What to Build\n- Root package.json with workspaces config pointing to packages/*\n- packages/ directory with subdirectories for each package\n- tsconfig.base.json with shared TypeScript settings\n- .gitignore updates for node_modules, dist, .browserflow\n- Basic README.md with project overview\n\n## Monorepo Layout\n\\`\\`\\`\nbrowserflow/\n├── packages/\n│   ├── core/           # Shared types, schemas, utilities\n│   ├── exploration/    # AI exploration engine\n│   ├── review-ui/      # React review application  \n│   ├── generator/      # Playwright test generator\n│   └── cli/            # bf command-line tool\n├── schemas/            # JSON Schema exports\n├── examples/           # Example projects\n├── docs/               # Documentation\n├── package.json        # Workspace root\n├── bun.lockb\n├── tsconfig.base.json\n└── README.md\n\\`\\`\\`\n\n## Root package.json\n\\`\\`\\`json\n{\n  \"name\": \"browserflow\",\n  \"private\": true,\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": {\n    \"build\": \"bun run --filter '*' build\",\n    \"test\": \"bun run --filter '*' test\",\n    \"typecheck\": \"bun run --filter '*' typecheck\",\n    \"dev\": \"bun run --filter @browserflow/cli dev\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.3.0\",\n    \"@types/node\": \"^20.10.0\"\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bun install\\` succeeds at repo root\n- [ ] Each package directory exists with minimal package.json\n- [ ] tsconfig.base.json has proper module/target settings\n- [ ] .gitignore includes .browserflow/, node_modules/, dist/\n- [ ] README has project overview\n\n## Why Bun Over npm/yarn/pnpm?\n- Faster installs (important for CI)\n- Native workspace support without extra config\n- Better TypeScript/ESM handling out of the box\n- Single lockfile (bun.lockb) instead of multiple","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:08.458673198-05:00","created_by":"ubuntu","updated_at":"2026-01-15T19:33:03.678827936-05:00","closed_at":"2026-01-15T19:33:03.678827936-05:00","close_reason":"Closed"}
{"id":"bf-0vx","title":"D.2: Implement step timeline component","description":"# Task: Implement Step Timeline Component\n\n## Context\nThe step timeline is the left rail of the Review UI, showing all steps with thumbnails and status indicators. Users click to select a step for detailed review.\n\n## What to Build\n\\`\\`\\`typescript\ninterface StepTimelineProps {\n  steps: ExplorationStep[];\n  currentStepId: string;\n  reviewStatus: Record\u003cstring, 'approved' | 'rejected' | 'pending'\u003e;\n  onSelectStep: (stepId: string) =\u003e void;\n}\n\nexport function StepTimeline({ steps, currentStepId, reviewStatus, onSelectStep }: StepTimelineProps) {\n  return (\n    \u003cdiv className=\"w-48 border-r overflow-y-auto\"\u003e\n      \u003cdiv className=\"p-2 border-b\"\u003e\n        \u003ch2 className=\"font-semibold\"\u003eSteps\u003c/h2\u003e\n        \u003cdiv className=\"text-sm text-muted-foreground\"\u003e\n          {countApproved(reviewStatus)} / {steps.length} approved\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      \u003cdiv className=\"space-y-1 p-2\"\u003e\n        {steps.map((step, index) =\u003e (\n          \u003cStepThumbnail\n            key={step.step_id}\n            step={step}\n            index={index}\n            status={reviewStatus[step.step_id] || 'pending'}\n            isSelected={step.step_id === currentStepId}\n            onClick={() =\u003e onSelectStep(step.step_id)}\n          /\u003e\n        ))}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction StepThumbnail({ step, index, status, isSelected, onClick }) {\n  return (\n    \u003cbutton\n      onClick={onClick}\n      className={cn(\n        \"w-full p-2 rounded text-left transition-colors\",\n        isSelected \u0026\u0026 \"bg-accent\",\n        !isSelected \u0026\u0026 \"hover:bg-muted\"\n      )}\n    \u003e\n      \u003cdiv className=\"flex items-center gap-2\"\u003e\n        {/* Status indicator */}\n        \u003cStatusIcon status={status} /\u003e\n        \n        {/* Step number and ID */}\n        \u003cdiv className=\"flex-1 min-w-0\"\u003e\n          \u003cdiv className=\"text-sm font-medium truncate\"\u003e\n            {index + 1}. {step.step_id}\n          \u003c/div\u003e\n          \u003cdiv className=\"text-xs text-muted-foreground truncate\"\u003e\n            {step.intent.action}\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      {/* Thumbnail image */}\n      {step.evidence.screenshots?.after \u0026\u0026 (\n        \u003cimg\n          src={step.evidence.screenshots.after}\n          alt=\"\"\n          className=\"mt-2 w-full h-16 object-cover rounded\"\n        /\u003e\n      )}\n    \u003c/button\u003e\n  );\n}\n\nfunction StatusIcon({ status }: { status: 'approved' | 'rejected' | 'pending' }) {\n  switch (status) {\n    case 'approved':\n      return \u003cCheckCircle className=\"h-4 w-4 text-green-500\" /\u003e;\n    case 'rejected':\n      return \u003cXCircle className=\"h-4 w-4 text-red-500\" /\u003e;\n    case 'pending':\n      return \u003cCircle className=\"h-4 w-4 text-yellow-500\" /\u003e;\n  }\n}\n\\`\\`\\`\n\n## Features\n- Thumbnail preview of \"after\" screenshot\n- Status indicator (approved/rejected/pending)\n- Current step highlighted\n- Scrollable for many steps\n- Shows approval progress count\n\n## Acceptance Criteria\n- [ ] Shows all steps with thumbnails\n- [ ] Status icons reflect review state\n- [ ] Current step visually highlighted\n- [ ] Click navigates to step\n- [ ] Scrollable when many steps\n- [ ] Progress count updates in real-time","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:02.682829183-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.602289857-05:00","closed_at":"2026-01-15T22:02:18.602289857-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-0vx","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:15.909564984-05:00","created_by":"ubuntu"}]}
{"id":"bf-0wt","title":"J.2: Create CI templates (GitHub Actions, GitLab)","description":"# Task: Create CI Templates\n\n## Context\nCI templates enable users to integrate BrowserFlow into their CI/CD pipelines with minimal effort.\n\n## What to Build\n\n### GitHub Actions Template\n\\`\\`\\`yaml\n# .github/workflows/e2e.yml\nname: E2E Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      - name: Install dependencies\n        run: bun install\n      \n      - name: Install BrowserFlow\n        run: bun add -g browserflow\n      \n      - name: Install Playwright browsers\n        run: bunx playwright install --with-deps chromium\n      \n      - name: Start application\n        run: |\n          bun run dev \u0026\n          sleep 5\n      \n      - name: Run E2E tests\n        run: bf run\n      \n      - name: Upload failure artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: browserflow-failures\n          path: |\n            .browserflow/runs/**/failure.json\n            .browserflow/runs/**/artifacts/\n\\`\\`\\`\n\n### GitLab CI Template\n\\`\\`\\`yaml\n# .gitlab-ci.yml\ne2e:\n  stage: test\n  image: oven/bun:latest\n  \n  before_script:\n    - bun add -g browserflow\n    - bunx playwright install --with-deps chromium\n  \n  script:\n    - bun install\n    - bun run dev \u0026\n    - sleep 5\n    - bf run\n  \n  artifacts:\n    when: on_failure\n    paths:\n      - .browserflow/runs/**/failure.json\n      - .browserflow/runs/**/artifacts/\n    expire_in: 1 week\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] GitHub Actions template works on real repo\n- [ ] GitLab CI template works on real repo\n- [ ] Artifacts uploaded on failure\n- [ ] Documentation explains customization options","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-15T17:46:35.829049062-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:25:15.075132223-05:00","closed_at":"2026-01-15T23:25:15.075132223-05:00","close_reason":"Documentation completed: getting started guide and CI templates","dependencies":[{"issue_id":"bf-0wt","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:17.144025118-05:00","created_by":"ubuntu"}]}
{"id":"bf-10c","title":"Add baseline accept confirmation prompt","notes":"## Context \u0026 Goal\n\n**Problem:** `bf baseline accept` always proceeds without confirmation, even without `--all` flag. This is dangerous - users might accidentally accept all baselines.\n\n**Why it matters:** Accidental baseline acceptance can hide regressions.\n\n**Project goal served:** Safe defaults - destructive operations require confirmation.\n\n## Current State vs Target State\n\n**Current (packages/cli/src/commands/baseline.ts:361-376):**\n```typescript\n// Without --all, we should confirm (but for now, always proceed)\nif (\\!options.all \u0026\u0026 \\!options.screenshot) {\n  console.log(colors.warning('Warning: Accepting all screenshots without --all flag.'));\n  // ...\n}\n\n// Always proceeds for now (confirmation would require interactive prompt)\nconst result = await acceptBaselines(options.spec, {\n  all: true, // Force to true regardless\n});\n```\n\n**Target:**\n```typescript\nif (\\!options.all \u0026\u0026 \\!options.screenshot) {\n  // List pending baselines\n  const pending = await getPendingBaselines(options.spec);\n  if (pending.length === 0) {\n    console.log('No pending baselines to accept');\n    return;\n  }\n  \n  console.log(`Found ${pending.length} pending baselines:`);\n  pending.forEach(b =\u003e console.log(`  - ${b.name}`));\n  \n  // Require confirmation\n  const { confirm } = await prompts({\n    type: 'confirm',\n    name: 'confirm',\n    message: `Accept all ${pending.length} baselines?`,\n    initial: false,\n  });\n  \n  if (\\!confirm) {\n    console.log('Cancelled');\n    process.exit(0);\n  }\n}\n\nconst result = await acceptBaselines(options.spec, {\n  all: options.all || confirmed,\n  screenshot: options.screenshot,\n});\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/cli/src/commands/baseline.ts (lines 361-380) - add confirmation prompt\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 and 2 beads (different concern)\n- bead-json-reporter (different file)\n- bead-unify-run-store (different concern)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying baseline.ts\n\n**Blocking Reason:** None - leaf fix\n\n## Estimated Scope\n- **Size:** Small (30-50 lines)\n- **Risk:** Low (adds safety, doesn't change core behavior)\n\n## Acceptance Criteria\n- [ ] Without `--all`, shows list and prompts for confirmation\n- [ ] With `--all`, proceeds without prompt\n- [ ] With `--screenshot`, proceeds for that specific screenshot\n- [ ] Answering 'n' cancels and exits cleanly\n- [ ] `bun run test` passes in packages/cli\n\n## Testing Requirements\n- Test: without flags, prompts shown (mock prompts)\n- Test: with --all, no prompt\n- Test: with --screenshot, no prompt for that file\n- Run: `cd packages/cli \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:21:37.237249369-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:45:04.433565155-05:00","closed_at":"2026-01-19T17:45:04.433565155-05:00","close_reason":"Closed"}
{"id":"bf-17e","title":"Wire Review UI to bf review server","notes":"# Context \u0026 Goal\n\nThe Review UI React app is fully built but the `bf review` server returns a placeholder HTML page instead of serving the actual React build.\n\n## Current State\n\n**File:** `packages/cli/src/commands/review.ts` (lines 62-91)\n\n```typescript\nasync function serveStaticUI(pathname: string): Promise\u003cResponse\u003e {\n  // For now, return a simple HTML page\n  // In production, this would serve from packages/review-ui/dist\n  if (pathname === \"/\") {\n    return new Response(`\u003ch1\u003eBrowserFlow Review Server\u003c/h1\u003e...placeholder...`);\n  }\n  return new Response(\"Not Found\", { status: 404 });\n}\n```\n\n## Target State\n\nThe server should:\n1. Build Review UI if not already built\n2. Serve static files from `packages/review-ui/dist/`\n3. Serve screenshot files from `.browserflow/explorations/{id}/screenshots/`\n4. Handle SPA routing (return index.html for non-API routes)\n\n**Files MODIFIED:**\n- `packages/cli/src/commands/review.ts` (lines 62-91) - Replace placeholder with real file serving\n\n**Files READ:**\n- `packages/review-ui/dist/` - Built React app files\n- `packages/review-ui/package.json` - Build script\n\n**Files CREATED (if needed):**\n- None (just serving existing dist)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill - different files)\n- bf-lkz (screenshots - different file)\n- Review UI component beads (different package)\n\n**Cannot Run In Parallel With:**\n- Any other CLI command beads\n\n## Estimated Scope\n- **Size:** Medium (50-100 lines)\n- **Risk:** Medium (server routing logic)\n\n## Acceptance Criteria\n- [ ] `bf review` serves React UI at http://localhost:8190\n- [ ] Static assets (JS, CSS) load correctly\n- [ ] Screenshots served via `/api/screenshots/{exp-id}/{filename}`\n- [ ] SPA routing works (refresh on any route returns app)\n- [ ] API endpoints still work\n\n## Testing Requirements\n- Run `bf review --exploration exp-xxx`\n- Browser should show React UI (not placeholder)\n- Navigate through steps, see screenshots\n- Submit review and verify it saves\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-20T00:20:27.671025868-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:39:27.029608877-05:00","closed_at":"2026-01-20T00:39:27.029608877-05:00","close_reason":"Closed"}
{"id":"bf-1lw","title":"Unify RunStore implementations","notes":"## Context \u0026 Goal\n\n**Problem:** Core and CLI have incompatible RunStore implementations with different directory structures.\n- Core: `.browserflow/runs/\u003cspec\u003e/run-YYYYMMDDHHMMSS-\u003chex\u003e/`\n- CLI: `.browserflow/runs/_execution/run-\u003ctimestamp\u003e/`\n\n**Why it matters:** \"Where did my run go?\" confusion. Run artifacts scattered.\n\n**Project goal served:** Consistent run directory structure.\n\n## Current State vs Target State\n\n**Current - Two implementations:**\n\nCore (packages/core/src/run-store.ts):\n```typescript\n// Per-spec organization with datetime+random ID\n.browserflow/runs/\u003cspec-name\u003e/run-20260115-031000-abc123/\n```\n\nCLI (packages/cli/src/run/run-store.ts):\n```typescript\n// Category-based with timestamp-only ID\n.browserflow/runs/_execution/run-1737075600000/\n```\n\n**Target - Delete CLI implementation, use Core:**\n\n1. Remove packages/cli/src/run/run-store.ts\n2. Import and use core RunStore in CLI:\n\n```typescript\n// packages/cli/src/commands/run.ts\nimport { createRunStore } from '@browserflow/core';\n\nconst runStore = createRunStore(projectRoot);\nconst runDir = await runStore.createRun(specName);\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/cli/src/commands/run.ts - use core RunStore\n- packages/cli/src/commands/review.ts - use core RunStore if applicable\n- packages/cli/src/run/failure-bundle.ts - update paths\n\n**Files READ (reference only):**\n- packages/core/src/run-store.ts - understand core API\n- packages/cli/src/run/run-store.ts - understand what to remove\n\n**Files DELETED:**\n- packages/cli/src/run/run-store.ts (or deprecate)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different concern)\n- bead-fix-testid-args (different package)\n- bead-region-mask-support (different package)\n\n**Cannot Run In Parallel With:**\n- bead-json-reporter (both touch CLI run infrastructure)\n\n**Blocking Reason:** Directory structure affects all run-related operations\n\n## Estimated Scope\n- **Size:** Medium (50-150 lines changed/deleted)\n- **Risk:** High (changes run artifact locations)\n\n## Acceptance Criteria\n- [ ] Single RunStore implementation (core)\n- [ ] CLI uses core RunStore\n- [ ] Run directories follow core structure\n- [ ] `latest` symlink works\n- [ ] Existing CLI tests pass with path updates\n- [ ] `bun run test` passes in packages/cli\n\n## Testing Requirements\n- Update CLI tests to expect core directory structure\n- Verify `bf explore`, `bf review`, `bf run` all use same structure\n- Run: `cd packages/cli \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:20:54.079551548-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:22:50.337273633-05:00","closed_at":"2026-01-19T17:22:50.337273633-05:00","close_reason":"Closed"}
{"id":"bf-2hk","title":"Implement Review UI server-side save","notes":"## Context \u0026 Goal\n\n**Problem:** Review UI \"Submit\" downloads JSON + shows alert(). No actual save to run directory.\n\n**Why it matters:** Premium UX requires real saves, not downloads.\n\n**Project goal served:** Review output must be real and written to run directory.\n\n## Current State vs Target State\n\n**Current (packages/review-ui/src/App.tsx:100-130):**\n```typescript\nconst handleSubmit = (reviewData: Record\u003cnumber, StepReviewData\u003e) =\u003e {\n  // ... builds reviewJson\n  \n  // Download as JSON for now\n  const blob = new Blob([JSON.stringify(reviewJson, null, 2)], {...});\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = `review-${data.id}.json`;\n  a.click();\n  \n  alert('Review submitted! Downloaded as JSON file.');\n};\n```\n\n**Target:**\n```typescript\nconst handleSubmit = async (reviewData: Record\u003cnumber, StepReviewData\u003e) =\u003e {\n  setSubmitting(true);\n  try {\n    const reviewJson = buildReviewJson(reviewData);\n    \n    // POST to review server endpoint\n    const response = await fetch(`/api/reviews/${data.id}`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(reviewJson),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Save failed: ${response.statusText}`);\n    }\n    \n    // Show success toast\n    toast.success(`Saved to ${response.headers.get('X-Review-Path')}`);\n    setDirty(false);\n  } catch (error) {\n    toast.error(`Save failed: ${error.message}. Retry?`, {\n      action: { label: 'Retry', onClick: () =\u003e handleSubmit(reviewData) }\n    });\n  } finally {\n    setSubmitting(false);\n  }\n};\n```\n\n**Also need server endpoint in packages/cli/src/commands/review.ts to handle POST.**\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/App.tsx - replace download with fetch POST\n- packages/cli/src/commands/review.ts - add API endpoint handler\n\n**Files READ (reference only):**\n- packages/review-ui/src/hooks/useReviewState.ts - understand state management\n\n**Files CREATED:**\n- None (or packages/cli/src/review-server.ts if separate)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different concern)\n- bead-fix-testid-args (different files in same package)\n- bead-region-mask-support (different package)\n\n**Cannot Run In Parallel With:**\n- bead-add-toast-system (depends on toast infrastructure)\n\n**Blocking Reason:** Core feature - review output must work\n\n## Estimated Scope\n- **Size:** Large (100-200 lines)\n- **Risk:** High (changes save flow, needs server endpoint)\n\n## Acceptance Criteria\n- [ ] Submit button POSTs to server endpoint\n- [ ] Server writes review.json to run directory\n- [ ] Success shows toast with file path\n- [ ] Error shows retry option\n- [ ] No more alert()\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Mock fetch, verify POST called with correct payload\n- Test error handling shows retry\n- Integration: run `bf review`, submit, verify file written\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-16T18:21:39.794048404-05:00","created_by":"ubuntu","updated_at":"2026-01-19T19:27:18.329663013-05:00","closed_at":"2026-01-19T19:27:18.329663013-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-2hk","depends_on_id":"bf-b9b","type":"blocks","created_at":"2026-01-16T18:22:31.097843012-05:00","created_by":"ubuntu"},{"issue_id":"bf-2hk","depends_on_id":"bf-kqu","type":"blocks","created_at":"2026-01-19T15:25:18.830991426-05:00","created_by":"ubuntu"}]}
{"id":"bf-2ts","title":"Implement screenshot evidence writing","notes":"## Context \u0026 Goal\n\n**Problem:** EvidenceCollector.captureScreenshot is a stub - returns path but doesnt write file. Review UI references non-existent screenshots.\n\n**Why it matters:** UX trust-breaker - screenshots referenced in reports dont exist.\n\n**Project goal served:** Screenshots must exist where reports say they are.\n\n## Current State vs Target State\n\n**Current (packages/exploration/src/evidence.ts:62-81):**\n```typescript\nasync captureScreenshot(\n  sessionId: string,\n  name: string,\n  options: ScreenshotOptions = {}\n): Promise\u003cstring\u003e {\n  // TODO: Implement actual screenshot capture via agent-browser\n  // This stub returns a valid path for compilation\n  const filename = `${name}.${this.screenshotFormat}`;\n  const path = `${this.outputDir}/screenshots/${filename}`;\n  // ... no actual file writing\n  return path;\n}\n```\n\n**Target:**\n```typescript\nasync captureScreenshot(\n  sessionId: string,\n  name: string,\n  options: ScreenshotOptions = {}\n): Promise\u003cstring\u003e {\n  const filename = `${name}.${this.screenshotFormat}`;\n  const filepath = `${this.outputDir}/screenshots/${filename}`;\n  \n  // Ensure directory exists\n  await fs.mkdir(path.dirname(filepath), { recursive: true });\n  \n  // Capture screenshot from browser session\n  const session = this.sessions.get(sessionId);\n  if (!session) {\n    throw new Error(`No browser session found: ${sessionId}`);\n  }\n  \n  const buffer = await session.screenshot(options);\n  await fs.writeFile(filepath, buffer);\n  \n  // Record metadata\n  this.evidence.push({\n    timestamp: new Date().toISOString(),\n    sessionId,\n    type: 'screenshot',\n    path: filepath,\n  });\n  \n  return filepath;\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/exploration/src/evidence.ts (lines 62-81) - implement actual capture\n- packages/exploration/src/step-executor.ts (lines 737-740) - wire up properly\n\n**Files READ (reference only):**\n- packages/exploration/src/explorer.ts - understand how evidence collector is used\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different concern)\n- bead-fix-testid-args (different package)\n- bead-fix-diff-hotkey (different package)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying evidence.ts or step-executor.ts\n\n**Blocking Reason:** Evidence capture must work before Review UI can trust paths\n\n## Estimated Scope\n- **Size:** Medium (50-100 lines)\n- **Risk:** Medium (requires browser session integration)\n\n## Acceptance Criteria\n- [ ] captureScreenshot actually writes PNG to disk\n- [ ] Screenshots directory is created if needed\n- [ ] Returned path points to existing file\n- [ ] Step execution records valid screenshot paths\n- [ ] `bun run test` passes in packages/exploration\n\n## Testing Requirements\n- Mock browser session with screenshot returning Buffer\n- Verify file written to expected path\n- Verify metadata recorded correctly\n- Run: `cd packages/exploration \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:20:08.19372134-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:17:55.399620459-05:00","closed_at":"2026-01-19T17:17:55.399620459-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-2ts","depends_on_id":"bf-yi8","type":"blocks","created_at":"2026-01-17T18:51:16.394430689-05:00","created_by":"ubuntu"}]}
{"id":"bf-2un","title":"B.3: Implement bf doctor command","description":"# Task: Implement bf doctor Command\n\n## Context\n\\`bf doctor\\` checks that all dependencies are installed and configured correctly. It provides actionable fix instructions for any issues found.\n\n## What to Build\n\\`\\`\\`typescript\n// bf doctor [options]\n// Options:\n//   --fix    Attempt to fix issues automatically\n\ninterface Check {\n  name: string;\n  check: () =\u003e Promise\u003cCheckResult\u003e;\n  fix?: () =\u003e Promise\u003cvoid\u003e;\n}\n\ninterface CheckResult {\n  status: 'pass' | 'warn' | 'fail';\n  message: string;\n  fixHint?: string;\n}\n\nconst checks: Check[] = [\n  {\n    name: 'Node.js version',\n    check: async () =\u003e {\n      const version = process.version;\n      const major = parseInt(version.slice(1));\n      if (major \u003e= 18) {\n        return { status: 'pass', message: \\`Node.js \\${version}\\` };\n      }\n      return {\n        status: 'fail',\n        message: \\`Node.js \\${version} (need \u003e=18)\\`,\n        fixHint: 'Install Node.js 18+ from https://nodejs.org'\n      };\n    }\n  },\n  {\n    name: 'agent-browser',\n    check: async () =\u003e {\n      try {\n        await exec('agent-browser --version');\n        return { status: 'pass', message: 'Installed' };\n      } catch {\n        return {\n          status: 'fail',\n          message: 'Not installed',\n          fixHint: 'Run: bun add -g agent-browser'\n        };\n      }\n    }\n  },\n  {\n    name: 'Playwright browsers',\n    check: async () =\u003e { /* Check chromium installed */ }\n  },\n  {\n    name: 'Configuration',\n    check: async () =\u003e {\n      if (!exists('browserflow.yaml')) {\n        return {\n          status: 'fail',\n          message: 'No browserflow.yaml',\n          fixHint: 'Run: bf init'\n        };\n      }\n      // Validate config\n      return { status: 'pass', message: 'Valid' };\n    }\n  },\n  {\n    name: 'Review port',\n    check: async () =\u003e {\n      const port = config.review.port;\n      if (await isPortAvailable(port)) {\n        return { status: 'pass', message: \\`Port \\${port} available\\` };\n      }\n      return {\n        status: 'warn',\n        message: \\`Port \\${port} in use\\`,\n        fixHint: 'Change review.port in browserflow.yaml'\n      };\n    }\n  }\n];\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf doctor\n\nBrowserFlow Doctor\n\n  ✓ Node.js version      v20.10.0\n  ✓ agent-browser        v0.5.0\n  ✗ Playwright browsers  Not installed\n    → Run: bunx playwright install chromium\n  ✓ Configuration        Valid\n  ⚠ Review port          8190 in use\n    → Change review.port in browserflow.yaml\n\n2 passed, 1 warning, 1 failed\n\nRun bf doctor --fix to attempt automatic fixes.\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Checks Node.js version (\u003e=18)\n- [ ] Checks agent-browser installation\n- [ ] Checks Playwright browsers\n- [ ] Validates browserflow.yaml\n- [ ] Checks review port availability\n- [ ] Provides actionable fix hints\n- [ ] --fix attempts automatic fixes where possible\n- [ ] Exit code reflects worst status","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:39.936745969-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:39.389924087-05:00","closed_at":"2026-01-15T21:59:39.389924087-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-2un","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:14.976740866-05:00","created_by":"ubuntu"}]}
{"id":"bf-32b","title":"J.1: Write getting started guide","description":"# Task: Write Getting Started Guide\n\n## Context\nThe getting started guide is the first documentation new users see. It must enable zero-to-first-test in under 10 minutes.\n\n## What to Build\n\\`\\`\\`markdown\n# Getting Started with BrowserFlow\n\n## Installation\n\n\\`\\`\\`bash\n# Install globally\nbun add -g browserflow\n\n# Install Playwright browsers\nbunx playwright install chromium\n\\`\\`\\`\n\n## Quick Start\n\n### 1. Initialize Your Project\n\n\\`\\`\\`bash\ncd your-web-app\nbf init --example\n\\`\\`\\`\n\n### 2. Check Your Setup\n\n\\`\\`\\`bash\nbf doctor\n\\`\\`\\`\n\n### 3. Write Your First Spec\n\n\\`\\`\\`yaml\n# specs/homepage.yaml\nversion: 2\nname: homepage-test\ndescription: Verify homepage loads correctly\n\nsteps:\n  - id: visit_home\n    action: navigate\n    to: /\n    \n  - id: check_title\n    action: expect\n    checks:\n      - visible:\n          target: { css: \"h1\" }\n\\`\\`\\`\n\n### 4. Validate Your Spec\n\n\\`\\`\\`bash\nbf lint\n\\`\\`\\`\n\n### 5. Run Exploration\n\n\\`\\`\\`bash\n# Start your app first\nbun run dev\n\n# Then explore\nbf explore --spec homepage-test --url http://localhost:3000\n\\`\\`\\`\n\n### 6. Review \u0026 Approve\n\n\\`\\`\\`bash\nbf review --spec homepage-test\n\\`\\`\\`\n\n### 7. Generate Test\n\n\\`\\`\\`bash\nbf generate --spec homepage-test\n\\`\\`\\`\n\n### 8. Run Test\n\n\\`\\`\\`bash\nbf run --spec homepage-test\n\\`\\`\\`\n\n## What's Next?\n\n- [Configuration Guide](./configuration.md)\n- [Spec Format Reference](./spec-format.md)\n- [CI Integration](./ci-integration.md)\n\\`\\`\\`\n\n## Structure\n- Installation (30 seconds)\n- Quick start (5 minutes)\n- What's next (links to deeper docs)\n\n## Acceptance Criteria\n- [ ] New user can follow guide successfully\n- [ ] All commands work as documented\n- [ ] Links to deeper documentation\n- [ ] Troubleshooting section for common issues","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-15T17:46:24.087472502-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:25:15.073456989-05:00","closed_at":"2026-01-15T23:25:15.073456989-05:00","close_reason":"Documentation completed: getting started guide and CI templates","dependencies":[{"issue_id":"bf-32b","depends_on_id":"bf-jlm","type":"blocks","created_at":"2026-01-15T17:47:17.051788758-05:00","created_by":"ubuntu"}]}
{"id":"bf-3a1","title":"Add missing actions to spec-v2 schema","notes":"## Context \u0026 Goal\n\n**Problem:** The spec-v2.schema.json only allows 16 actions but docs and StepExecutor support additional actions (`reload`, `scroll`, `press`, `upload`, `scroll_into_view`). This causes specs written per docs to fail validation, while runtime supports them.\n\n**Why it matters:** Users following docs will write invalid specs. Schema should be source of truth.\n\n**Project goal served:** Spec coherence - single source of truth for action types.\n\n## Current State vs Target State\n\n**Current (packages/core/schemas/spec-v2.schema.json:35-51):**\n```json\n\"action\": {\n  \"type\": \"string\",\n  \"enum\": [\n    \"click\", \"navigate\", \"back\", \"forward\", \"refresh\",\n    \"fill\", \"type\", \"select\", \"check\", \"wait\", \"expect\",\n    \"screenshot\", \"verify_state\", \"identify_element\", \"ai_verify\", \"custom\"\n  ]\n}\n```\n\n**Target:**\n```json\n\"action\": {\n  \"type\": \"string\",\n  \"enum\": [\n    \"click\", \"navigate\", \"back\", \"forward\", \"refresh\", \"reload\",\n    \"fill\", \"type\", \"select\", \"check\", \"press\", \"upload\",\n    \"wait\", \"expect\", \"screenshot\", \"scroll\", \"scroll_into_view\",\n    \"verify_state\", \"identify_element\", \"ai_verify\", \"custom\"\n  ]\n}\n```\n\n**Note:** `reload` should be an alias for `refresh` - add both to schema, normalize in loader.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/core/schemas/spec-v2.schema.json (lines 35-51) - add missing action enums\n\n**Files READ (reference only):**\n- packages/exploration/src/step-executor.ts - verify which actions are implemented\n- docs/SPEC-v1.0.md - verify which actions are documented\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-navigate-url-field (different file section)\n- bead-preconditions-format (different file section)\n- bead-duration-schema (different file section)\n\n**Cannot Run In Parallel With:**\n- None in this phase\n\n**Blocking Reason:** Schema changes must complete before Zod schema sync\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (additive change, no breaking changes)\n\n## Acceptance Criteria\n- [ ] spec-v2.schema.json includes all actions from docs\n- [ ] Schema validates specs using `reload`, `scroll`, `press`, `upload`\n- [ ] Zod schema updated to match (in sync task)\n- [ ] `bun run test` passes in packages/core\n\n## Testing Requirements\n- Existing schema validation tests should still pass\n- Add test case validating spec with new actions\n- Run: `cd packages/core \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:18:46.620469855-05:00","created_by":"ubuntu","updated_at":"2026-01-17T18:12:46.830806842-05:00","closed_at":"2026-01-17T18:12:46.830806842-05:00","close_reason":"Closed"}
{"id":"bf-3el","title":"Replace Approve/Reject with free-form feedback in Review UI","notes":"# Context \u0026 Goal\n\nThe Review UI currently has Approve/Reject buttons per step, designed for a \"gate\" workflow. The new vision is that Review UI is a free-form feedback tool for Claude - users highlight issues and add comments, not approve/reject.\n\n## Current State\n\n**File:** `packages/review-ui/src/pages/ReviewPage.tsx` (lines 248-261)\n\n```tsx\n\u003cdiv className=\"flex items-center gap-2\"\u003e\n  \u003cbutton onClick={actions.rejectStep} className=\"...bg-red-100...\"\u003e\n    Reject (r)\n  \u003c/button\u003e\n  \u003cbutton onClick={actions.approveStep} className=\"...bg-green-100...\"\u003e\n    Approve (a)\n  \u003c/button\u003e\n\u003c/div\u003e\n```\n\n**File:** `packages/review-ui/src/hooks/useReviewState.ts` (lines 7-14)\n\n```typescript\nexport type StepReviewStatus = \"approved\" | \"rejected\" | \"pending\";\n```\n\n## Target State\n\nReplace Approve/Reject with a simpler \"Mark as Reviewed\" toggle or remove entirely:\n- Keep comments (primary feedback mechanism)\n- Keep masks (for highlighting issues)\n- Change status from 3-state to 2-state: \"reviewed\" | \"pending\"\n- Or: Remove status entirely, just track \"has comment\" or \"has mask\"\n\n**Files MODIFIED:**\n- `packages/review-ui/src/pages/ReviewPage.tsx` (lines 248-261) - Replace buttons\n- `packages/review-ui/src/hooks/useReviewState.ts` (lines 7-14, 105-112) - Simplify status\n- `packages/review-ui/src/components/StepTimeline.tsx` - Update status display\n- `packages/review-ui/src/hooks/useReviewKeyboardShortcuts.ts` - Remove a/r shortcuts or repurpose\n\n**Files READ:**\n- `packages/review-ui/src/components/MaskEditor.tsx` - Keep as-is\n- `packages/review-ui/src/components/ScreenshotViewer.tsx` - Keep as-is\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill - different package)\n- bf-lkz (screenshots - different package)\n- bf-17e (server - different package) \n\n**Cannot Run In Parallel With:**\n- Any other Review UI beads (same files)\n\n## Estimated Scope\n- **Size:** Medium (100-150 lines changed)\n- **Risk:** Low (UI changes, no core logic)\n\n## Acceptance Criteria\n- [ ] No Approve/Reject buttons visible\n- [ ] Steps show \"reviewed\" state based on having comment or mask\n- [ ] Progress shows \"X reviewed / Y total\" instead of approved/rejected/pending\n- [ ] Keyboard shortcut help updated (or a/r removed)\n- [ ] Submit still saves all feedback\n\n## Testing Requirements\n- Open Review UI\n- Add comment to step 1 - should mark as reviewed\n- Add mask to step 2 - should mark as reviewed\n- Submit - review.json should contain feedback without approve/reject\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-20T00:20:47.000123321-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:41:43.549771806-05:00","closed_at":"2026-01-20T00:41:43.549771806-05:00","close_reason":"Closed"}
{"id":"bf-4gk","title":"Create BrowserFlow testing skill for Claude","notes":"# Context \u0026 Goal\n\nBrowserFlow is an AI-driven E2E testing tool where Claude drives the entire workflow. Instead of building \"smart\" CLI commands, we provide structured interfaces for Claude to use.\n\nThis skill will guide Claude through the spec-driven testing workflow:\n1. Identify implemented features (beads)\n2. Write spec YAML documenting what to test and why\n3. Run exploration via `bf explore`\n4. Review feedback via `bf review` UI\n5. Generate Playwright tests based on exploration + feedback\n\n## Current State\n\nNo skill exists. The spec creation guidance is scattered in docs/SPEC-v1.0.md but not optimized for LLM consumption.\n\n## Target State\n\nCreate `~/.claude/skills/browserflow-testing.md` that Claude can load when working with BrowserFlow.\n\n**Files CREATED:**\n- `~/.claude/skills/browserflow-testing.md` - The skill file\n\n**Files READ (reference only):**\n- `/data/projects/browserflow/docs/SPEC-v1.0.md` - Original spec for reference\n- `/data/projects/browserflow/e2e/specs/full-pipeline.yaml` - Example spec format\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All other beads (no file overlap)\n\n**Blocking Reason:** None - independent task\n\n## Estimated Scope\n- **Size:** Medium (100-200 lines of markdown)\n- **Risk:** Low (new file, no existing code touched)\n\n## Acceptance Criteria\n- [ ] Skill file created with proper frontmatter\n- [ ] Includes spec YAML schema with examples\n- [ ] Explains the explore → review → test workflow\n- [ ] Documents `bf explore` and `bf review` commands\n- [ ] Includes guidance on generating Playwright tests from exploration\n- [ ] Includes traceability (linking to beads)\n- [ ] Includes \"why\" documentation requirements\n\n## Testing Requirements\n- Manual verification: Load skill in Claude session\n- Verify Claude can follow workflow end-to-end\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-20T00:19:54.114729802-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:34:37.882812535-05:00","closed_at":"2026-01-20T00:34:37.882812535-05:00","close_reason":"Skill file created at ~/.claude/skills/browserflow-testing.md (523 lines). File includes: spec YAML schema with examples, explore→review→codify workflow, command reference, traceability guidance, 'why' documentation requirements, troubleshooting guide, and beads integration."}
{"id":"bf-5t1","title":"B.5: Implement CLI output utilities","description":"# Task: Implement CLI Output Utilities\n\n## Context\nPremium CLI UX requires consistent formatting, colors, spinners, and prompts. This task creates reusable utilities for all commands.\n\n## What to Build\n\n### Colors (ui/colors.ts)\n\\`\\`\\`typescript\nimport chalk from 'chalk';\n\nexport const colors = {\n  success: chalk.green,\n  error: chalk.red,\n  warn: chalk.yellow,\n  info: chalk.blue,\n  dim: chalk.gray,\n  bold: chalk.bold,\n  \n  // Semantic\n  pass: chalk.green('✓'),\n  fail: chalk.red('✗'),\n  pending: chalk.yellow('○'),\n  arrow: chalk.cyan('→'),\n};\n\\`\\`\\`\n\n### Spinner (ui/spinner.ts)\n\\`\\`\\`typescript\nimport ora from 'ora';\n\nexport function createSpinner(text: string) {\n  return ora({\n    text,\n    color: 'cyan',\n    spinner: 'dots'\n  });\n}\n\n// Usage:\nconst spinner = createSpinner('Exploring...');\nspinner.start();\n// ... work ...\nspinner.succeed('Exploration complete');\n\\`\\`\\`\n\n### Box Output (ui/box.ts)\n\\`\\`\\`typescript\nexport function printBox(title: string, content: string[]) {\n  const width = 60;\n  console.log('┌' + '─'.repeat(width) + '┐');\n  console.log('│ ' + title.padEnd(width - 1) + '│');\n  console.log('├' + '─'.repeat(width) + '┤');\n  for (const line of content) {\n    console.log('│ ' + line.padEnd(width - 1) + '│');\n  }\n  console.log('└' + '─'.repeat(width) + '┘');\n}\n\\`\\`\\`\n\n### JSON Mode (ui/output.ts)\n\\`\\`\\`typescript\nlet jsonMode = false;\n\nexport function setJsonMode(enabled: boolean) {\n  jsonMode = enabled;\n}\n\nexport function output(data: unknown) {\n  if (jsonMode) {\n    console.log(JSON.stringify(data, null, 2));\n  } else {\n    // Pretty print for humans\n  }\n}\n\\`\\`\\`\n\n### Next Steps Helper\n\\`\\`\\`typescript\nexport function printNextSteps(steps: string[]) {\n  console.log('');\n  console.log(colors.bold('Next steps:'));\n  for (const step of steps) {\n    console.log(\\`  \\${colors.arrow} \\${step}\\`);\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Consistent color scheme across all commands\n- [ ] Spinners for long-running operations\n- [ ] --json flag outputs parseable JSON\n- [ ] Box formatting for summaries\n- [ ] \"Next steps\" suggestions after every command\n- [ ] Works in CI (no TTY) without breaking","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:41:12.545342411-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:24:10.921842148-05:00","closed_at":"2026-01-15T22:24:10.921842148-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-5t1","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:15.244266432-05:00","created_by":"ubuntu"}]}
{"id":"bf-65x","title":"Update docs to match spec-v2 schema","notes":"## Context \u0026 Goal\n\n**Problem:** Docs (SPEC-v1.0.md) use field names and examples that dont match spec-v2.schema.json. This misleads users.\n\n**Why it matters:** Users following docs write invalid specs.\n\n**Project goal served:** Single source of truth - docs must reflect schema.\n\n## Current State vs Target State\n\n**Key discrepancies to fix:**\n\n1. **Navigate action (line 411):**\n   Current: `to: /`\n   Target: `url: /` (keep `to:` as \"also accepted\" note)\n\n2. **Preconditions page (line 332):**\n   Current: `page: /`\n   Target: `page: { url: / }` (note string shorthand also works)\n\n3. **Action names:**\n   - Document that `reload` is alias for `refresh`\n   - Add `press`, `scroll`, `scroll_into_view`, `upload` actions\n\n4. **Duration examples:**\n   - Ensure all examples use strings (\"500ms\", \"2m\"), never numbers\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- docs/SPEC-v1.0.md - update examples and descriptions\n\n**Files READ (reference only):**\n- packages/core/schemas/spec-v2.schema.json - source of truth\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All implementation beads (docs only)\n\n**Cannot Run In Parallel With:**\n- None\n\n**Blocking Reason:** Depends on schema being finalized (after bead-add-schema-actions)\n\n## Estimated Scope\n- **Size:** Medium (many small edits across large doc)\n- **Risk:** Low (documentation only)\n\n## Acceptance Criteria\n- [ ] All code examples validate against spec-v2.schema.json\n- [ ] Field names match schema (url not to, etc)\n- [ ] Duration examples all use strings\n- [ ] Action type list is complete\n- [ ] No misleading backward-compat syntax without notes\n\n## Testing Requirements\n- Extract YAML examples from docs, run through validator\n- Manual review for consistency\n","status":"open","priority":2,"issue_type":"chore","created_at":"2026-01-16T18:23:06.851924163-05:00","created_by":"ubuntu","updated_at":"2026-01-16T18:23:06.851924163-05:00","dependencies":[{"issue_id":"bf-65x","depends_on_id":"bf-3a1","type":"blocks","created_at":"2026-01-16T18:23:13.927090192-05:00","created_by":"ubuntu"}]}
{"id":"bf-661","title":"C.4: Implement locator candidate generator","description":"# Task: Implement Locator Candidate Generator\n\n## Context\nFor each target element found during exploration, we generate multiple locator strategies. These become the options reviewers choose from when locking the preferred locator.\n\n## What to Build\n\\`\\`\\`typescript\nimport { Locator, ElementHandle } from 'playwright-core';\n\ninterface LocatorCandidate {\n  strategy: LocatorStrategy;\n  confidence: number;      // 0-1, how stable/reliable\n  match_count: number;     // How many elements match\n  screenshot_crop?: string; // Path to cropped image of element\n}\n\nexport async function generateCandidates(\n  element: Locator,\n  page: Page\n): Promise\u003cLocatorCandidate[]\u003e {\n  const candidates: LocatorCandidate[] = [];\n  \n  // Get element properties\n  const handle = await element.elementHandle();\n  const tagName = await handle.evaluate(el =\u003e el.tagName.toLowerCase());\n  const attributes = await getAttributes(handle);\n  const textContent = await element.textContent();\n  const ariaRole = await handle.evaluate(el =\u003e el.getAttribute('role'));\n  const ariaLabel = await handle.evaluate(el =\u003e el.getAttribute('aria-label'));\n  \n  // 1. Try data-testid (highest confidence)\n  for (const attr of ['data-testid', 'data-test', 'data-qa']) {\n    if (attributes[attr]) {\n      candidates.push({\n        strategy: { type: 'testid', value: attributes[attr], attribute: attr },\n        confidence: 0.95,\n        match_count: await countMatches(page, \\`[\\${attr}=\"\\${attributes[attr]}\"]\\`)\n      });\n    }\n  }\n  \n  // 2. Try role + name (high confidence)\n  if (ariaRole || inferRole(tagName)) {\n    const role = ariaRole || inferRole(tagName);\n    const name = ariaLabel || textContent?.trim();\n    if (name) {\n      candidates.push({\n        strategy: { type: 'role', role, name, exact: true },\n        confidence: 0.85,\n        match_count: await countRoleMatches(page, role, name)\n      });\n    }\n  }\n  \n  // 3. Try label (for form elements)\n  const labelText = await findAssociatedLabel(handle);\n  if (labelText) {\n    candidates.push({\n      strategy: { type: 'label', text: labelText },\n      confidence: 0.80,\n      match_count: await countLabelMatches(page, labelText)\n    });\n  }\n  \n  // 4. Try text content (medium confidence)\n  if (textContent \u0026\u0026 textContent.length \u003c 50) {\n    candidates.push({\n      strategy: { type: 'text', text: textContent.trim() },\n      confidence: 0.60,\n      match_count: await countTextMatches(page, textContent)\n    });\n  }\n  \n  // 5. CSS selector (fallback, lowest confidence)\n  const cssSelector = await generateCssSelector(handle);\n  candidates.push({\n    strategy: { type: 'css', selector: cssSelector },\n    confidence: 0.40,\n    match_count: 1  // CSS selectors are usually unique\n  });\n  \n  // Sort by confidence\n  return candidates.sort((a, b) =\u003e b.confidence - a.confidence);\n}\n\\`\\`\\`\n\n## Confidence Scoring\n| Strategy | Base Confidence | Notes |\n|----------|-----------------|-------|\n| testid | 0.95 | Developer-controlled, most stable |\n| role+name | 0.85 | Semantic, survives styling changes |\n| label | 0.80 | User-facing, stable for forms |\n| placeholder | 0.70 | May change with i18n |\n| text | 0.60 | Can change frequently |\n| css | 0.40 | Brittle, last resort |\n\n## Acceptance Criteria\n- [ ] Generates multiple candidates for each element\n- [ ] Candidates ordered by confidence\n- [ ] match_count accurate\n- [ ] CSS fallback always generated\n- [ ] Handles elements without testid gracefully","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:14.459464505-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:00:46.359189234-05:00","closed_at":"2026-01-15T23:00:46.359189234-05:00","close_reason":"Implemented locator candidate generator with all strategies (ref, testid, role, text, css), element matching, confidence scoring. 39 tests pass.","dependencies":[{"issue_id":"bf-661","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.528514424-05:00","created_by":"ubuntu"},{"issue_id":"bf-661","depends_on_id":"bf-c4o","type":"blocks","created_at":"2026-01-15T17:47:15.818262824-05:00","created_by":"ubuntu"}]}
{"id":"bf-6e6","title":"D.3: Implement screenshot viewer with comparison modes","description":"# Task: Implement Screenshot Viewer\n\n## Context\nThe screenshot viewer is the main panel showing before/after screenshots. It supports 4 comparison modes per the spec: side-by-side, slider, blink, and diff.\n\n## What to Build\n\\`\\`\\`typescript\ntype ViewMode = 'side-by-side' | 'slider' | 'blink' | 'diff';\n\ninterface ScreenshotViewerProps {\n  beforeSrc: string;\n  afterSrc: string;\n  diffSrc?: string;\n  mode: ViewMode;\n  onModeChange: (mode: ViewMode) =\u003e void;\n}\n\nexport function ScreenshotViewer({ beforeSrc, afterSrc, diffSrc, mode, onModeChange }: ScreenshotViewerProps) {\n  return (\n    \u003cdiv className=\"flex flex-col h-full\"\u003e\n      {/* Mode selector */}\n      \u003cdiv className=\"flex gap-2 p-2 border-b\"\u003e\n        \u003cButton variant={mode === 'side-by-side' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('side-by-side')}\u003e\n          Side-by-Side\n        \u003c/Button\u003e\n        \u003cButton variant={mode === 'slider' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('slider')}\u003e\n          Slider\n        \u003c/Button\u003e\n        \u003cButton variant={mode === 'blink' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('blink')}\u003e\n          Blink\n        \u003c/Button\u003e\n        {diffSrc \u0026\u0026 (\n          \u003cButton variant={mode === 'diff' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('diff')}\u003e\n            Diff\n          \u003c/Button\u003e\n        )}\n      \u003c/div\u003e\n      \n      {/* Viewer content */}\n      \u003cdiv className=\"flex-1 overflow-auto p-4\"\u003e\n        {mode === 'side-by-side' \u0026\u0026 \u003cSideBySideView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'slider' \u0026\u0026 \u003cSliderView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'blink' \u0026\u0026 \u003cBlinkView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'diff' \u0026\u0026 diffSrc \u0026\u0026 \u003cDiffView baseline={beforeSrc} actual={afterSrc} diff={diffSrc} /\u003e}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Side-by-Side View\n\\`\\`\\`typescript\nfunction SideBySideView({ before, after }) {\n  return (\n    \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e\n      \u003cdiv\u003e\n        \u003cdiv className=\"text-sm font-medium mb-2\"\u003eBefore\u003c/div\u003e\n        \u003cimg src={before} className=\"border rounded\" /\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003cdiv className=\"text-sm font-medium mb-2\"\u003eAfter\u003c/div\u003e\n        \u003cimg src={after} className=\"border rounded\" /\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Slider View\n\\`\\`\\`typescript\nfunction SliderView({ before, after }) {\n  const [position, setPosition] = useState(50);\n  \n  return (\n    \u003cdiv className=\"relative\"\u003e\n      \u003cimg src={after} className=\"w-full\" /\u003e\n      \u003cdiv \n        className=\"absolute top-0 left-0 h-full overflow-hidden\"\n        style={{ width: \\`\\${position}%\\` }}\n      \u003e\n        \u003cimg src={before} className=\"w-full\" style={{ width: \\`\\${100 / position * 100}%\\` }} /\u003e\n      \u003c/div\u003e\n      \u003cinput\n        type=\"range\"\n        min={0}\n        max={100}\n        value={position}\n        onChange={e =\u003e setPosition(Number(e.target.value))}\n        className=\"absolute bottom-4 left-4 right-4\"\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Blink View\n\\`\\`\\`typescript\nfunction BlinkView({ before, after }) {\n  const [showBefore, setShowBefore] = useState(true);\n  \n  useEffect(() =\u003e {\n    const interval = setInterval(() =\u003e setShowBefore(v =\u003e !v), 500);\n    return () =\u003e clearInterval(interval);\n  }, []);\n  \n  return \u003cimg src={showBefore ? before : after} className=\"w-full\" /\u003e;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] All 4 modes implemented\n- [ ] Mode switching is instant\n- [ ] Slider is draggable\n- [ ] Blink speed is comfortable (~500ms)\n- [ ] Diff mode shows highlighted differences\n- [ ] Keyboard shortcuts 1-4 switch modes","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:20.283852437-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.603910726-05:00","closed_at":"2026-01-15T22:02:18.603910726-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-6e6","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.001657599-05:00","created_by":"ubuntu"}]}
{"id":"bf-6ig","title":"A.5: Implement LocatorObject types and resolution","description":"# Task: Implement LocatorObject Types and Resolution\n\n## Context\nThe LocatorObject is the core primitive for deterministic element selection. It replaces brittle agent-browser refs with durable locator strategies that include fallbacks and proof.\n\n## What to Build\n\n### Types\n\\`\\`\\`typescript\ntype LocatorStrategyType = 'testid' | 'role' | 'label' | 'placeholder' | 'text' | 'css';\n\ninterface LocatorStrategy {\n  type: LocatorStrategyType;\n  // For testid\n  value?: string;\n  attribute?: string;  // Default: data-testid\n  // For role\n  role?: string;\n  name?: string;\n  exact?: boolean;  // Default: true\n  // For label/placeholder/text\n  text?: string;\n  // For css\n  selector?: string;\n}\n\ninterface LocatorObject {\n  locator_id: string;\n  preferred: LocatorStrategy;\n  fallbacks: LocatorStrategy[];\n  scoping?: {\n    within?: LocatorStrategy[];\n    nth?: number;\n  };\n  proof: {\n    a11y_role?: string;\n    a11y_name?: string;\n    dom_fingerprint?: {\n      tag: string;\n      classes: string[];\n      attributes?: Record\u003cstring, string\u003e;\n    };\n    bounding_box?: {\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n    };\n  };\n}\n\\`\\`\\`\n\n### Resolution Function\n\\`\\`\\`typescript\nimport { Page, Locator } from 'playwright-core';\n\ninterface ResolveOptions {\n  useFallbacks: boolean;  // false in CI, true in dev\n  timeout?: number;\n}\n\nfunction resolveLocator(\n  locator: LocatorObject,\n  page: Page,\n  options: ResolveOptions\n): Locator;\n\nfunction strategyToLocator(\n  strategy: LocatorStrategy,\n  page: Page\n): Locator;\n\\`\\`\\`\n\n## Resolution Priority (Default)\n1. testid (most stable)\n2. role + name (semantic)\n3. label (form-specific)\n4. placeholder (input-specific)\n5. text (visible content)\n6. css (last resort)\n\n## Scoping Application\n\\`\\`\\`typescript\n// Apply scoping constraints\nlet locator = strategyToLocator(obj.preferred, page);\n\nif (obj.scoping?.within) {\n  for (const scope of obj.scoping.within) {\n    locator = strategyToLocator(scope, page).locator(locator);\n  }\n}\n\nif (obj.scoping?.nth !== undefined) {\n  locator = locator.nth(obj.scoping.nth);\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Types match spec section 7\n- [ ] Zod schema validates LocatorObject correctly\n- [ ] Resolution works with Playwright Page\n- [ ] Scoping (within, nth) applied correctly\n- [ ] Fallback iteration works when useFallbacks=true","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:08.345477155-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.065088631-05:00","closed_at":"2026-01-15T22:27:55.065088631-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-6ig","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.52288281-05:00","created_by":"ubuntu"}]}
{"id":"bf-6yr","title":"Epic C: Exploration Engine","description":"# Epic C: Exploration Engine\n\n## Strategic Context\n\nThe exploration engine is where **AI meets browser automation**. This is the \"magic\" that differentiates BrowserFlow from traditional test frameworks. We use AI to interpret intent-first specs and turn them into actionable test evidence.\n\n## Why This Matters\n\n**Key insight from the spec:** Exploration produces **evidence + candidates**, not final truth.\n\nThe AI might:\n- Click the wrong element\n- Miss timing windows  \n- Misinterpret ambiguous specs\n- Discover incomplete specs\n\nThis is OK because **human review** comes next. The exploration engine's job is to:\n1. Make a best effort at each step\n2. Collect rich evidence (screenshots, trace, timing)\n3. Generate multiple locator candidates per target\n4. Document what it tried and what happened\n\n## Deliverables\n\n1. **@browserflow/exploration package**\n2. **Explorer orchestrator** - Drives browser through spec steps\n3. **Step executor** - Maps action types to agent-browser calls:\n   - click, fill, type, select, check\n   - navigate, back, forward, reload\n   - wait (element, text, url, load_state, function)\n   - expect (assertions)\n   - screenshot, scroll, press\n4. **Evidence collector**:\n   - Before/after screenshots per step\n   - Trace recording (Playwright trace)\n   - Console/network error capture\n   - Timing information\n5. **Locator candidate generator**:\n   - Inspects DOM for testid, role, label, etc.\n   - Ranks candidates by stability\n   - Records confidence scores\n6. **Claude adapter** - Implements AIAdapter interface\n\n## Acceptance Criteria\n\n- [ ] Exploration produces valid exploration.json\n- [ ] Screenshots exist for all steps with screenshot config\n- [ ] Locator candidates include testid, role, css strategies\n- [ ] Trace files are valid Playwright traces\n- [ ] Console/network errors are captured\n- [ ] Duration per step is recorded\n- [ ] Handles step failures gracefully (continues exploration)\n\n## Dependencies\n\n- **Depends on Epic A** - Core types, schemas\n- **Depends on Epic B** - CLI structure (bf explore command)\n\n## Technical Decisions\n\n**Why agent-browser as library (not CLI)?**\n- Direct access to Playwright primitives\n- No JSON serialization overhead\n- Better error handling\n- Type safety throughout\n\n**agent-browser ref system lifecycle:**\n\\`\\`\\`\nExploration time:\n  agent-browser ref (@e1)\n    ↓\n  { selector: \"getByRole('button', {name: 'Add'})\", ... }\n    ↓\nLockfile (durable):\n  LocatorObject { preferred, fallbacks, proof }\n    ↓\nGenerated test (deterministic):\n  page.getByTestId('add-to-cart')\n\\`\\`\\`\n\n**Handling ambiguity:**\nWhen \\`query:\\` maps to multiple elements:\n1. Record top 3-5 candidates with confidence\n2. Include screenshot crops of each candidate\n3. Review UI forces human to lock the intended one\n\n## Integration Points\n\n\\`\\`\\`typescript\nimport { BrowserManager } from 'agent-browser';\nimport { getEnhancedSnapshot } from 'agent-browser/snapshot';\n\nasync function exploreStep(step, browser) {\n  const snapshot = await browser.getSnapshot({ interactive: true });\n  const ref = await aiAgent.findElement(step.target, snapshot);\n  const locator = browser.getLocatorFromRef(ref);\n  await executeAction(step.action, locator);\n  const candidates = await generateLocatorCandidates(locator);\n  return { ref, candidates };\n}\n\\`\\`\\`\n\n## Risk Factors\n\n- AI interpretation variance (mitigated by human review)\n- agent-browser API stability\n- Complex sites may confuse element detection\n\n## Related Spec Sections\n\n- Section 8: Exploration Phase\n- Section 16: AI Adapter Interface\n- Section 17: agent-browser Integration","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:29.936909824-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.72344913-05:00","closed_at":"2026-01-16T17:18:41.72344913-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-6yr","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:46:59.887770987-05:00","created_by":"ubuntu"},{"issue_id":"bf-6yr","depends_on_id":"bf-p8r","type":"blocks","created_at":"2026-01-15T17:46:59.970834144-05:00","created_by":"ubuntu"}]}
{"id":"bf-71k","title":"Epic A: Core Infrastructure","description":"# Epic A: Core Infrastructure\n\n## Strategic Context\n\nThis is the **foundational epic** upon which all of BrowserFlow depends. Nothing else can proceed until we have a solid TypeScript monorepo with shared types, schemas, and core utilities.\n\n## Why This Matters\n\nBrowserFlow's architecture decision to use a **bun monorepo** with separate packages enables:\n1. **Clean separation of concerns** - Each package has a single responsibility\n2. **Independent testing** - Packages can be tested in isolation\n3. **Incremental adoption** - Users could theoretically use just parts\n4. **Type safety across boundaries** - Shared types prevent drift\n\nThe **Zod schemas** are critical because:\n- They provide runtime validation (specs, configs)\n- They generate TypeScript types automatically\n- They can export JSON Schema for IDE validation\n- They document the data model in code\n\n## Deliverables\n\n1. **Monorepo structure** with bun workspaces\n2. **@browserflow/core package** with:\n   - Spec v2 Zod schema\n   - LocatorObject types and resolution logic\n   - Lockfile types\n   - Duration string parser (handles \"3s\", \"2m\", \"500ms\", etc.)\n   - Run store for immutable run directories\n   - Configuration types\n3. **JSON Schema exports** for IDE validation\n4. **TypeScript configuration** with proper paths and references\n\n## Acceptance Criteria\n\n- [ ] \\`bun install\\` succeeds at repo root\n- [ ] \\`bun run build\\` compiles all packages\n- [ ] Duration parsing handles ms/s/m/h and combinations like \"1m30s\"\n- [ ] Run directories are created immutably (never overwrite)\n- [ ] Zod schemas validate example specs correctly\n- [ ] JSON Schemas export and validate in VS Code\n\n## Dependencies\n\nNone - this is the foundation everything else builds on.\n\n## Technical Decisions\n\n**Why Bun over npm/yarn/pnpm?**\n- Faster installs (important for CI)\n- Native workspace support\n- Better TypeScript/ESM handling\n- Single lockfile (bun.lockb)\n\n**Why Zod over JSON Schema directly?**\n- TypeScript-first: types derived from schemas\n- Better DX for schema composition\n- Runtime validation built-in\n- Can still export to JSON Schema\n\n## Risk Factors\n\n- Bun is newer; may have edge cases\n- Monorepo complexity can slow initial development\n- Schema design errors are expensive to fix later\n\n## Related Spec Sections\n\n- Section 6: Spec YAML v2 Schema\n- Section 7: Locator Object Model\n- Section 15: Configuration\n- Section 18: Architecture \u0026 Monorepo Structure\n- Appendix C: Duration String Format","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:33:45.400622533-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.709930872-05:00","closed_at":"2026-01-16T17:18:41.709930872-05:00","close_reason":"All tasks completed"}
{"id":"bf-75p","title":"Fix diff view hotkey blank state","notes":"## Context \u0026 Goal\n\n**Problem:** Keyboard shortcut 4 can switch to diff mode even when diffSrc is undefined, resulting in blank viewer.\n\n**Why it matters:** Dead modes hurt perceived quality - premium apps have no dead buttons.\n\n**Project goal served:** Polish - no dead modes.\n\n## NOTE: This fix overlaps with bf-781 (keyboard duplicates)\n\nCurrently ScreenshotViewer guards diff mode locally (line 40-42):\n```typescript\ncase '4':\n  if (diffSrc) {\n    onModeChange('diff');\n  }\n  break;\n```\n\nBut useReviewKeyboardShortcuts does NOT guard it (line 100):\n```typescript\nuseHotkeys('4', () =\u003e handlers.setViewMode('diff'), {...});\n```\n\n**Resolution options:**\n1. Fix in bf-781 by adding guard to centralized hook (PREFERRED)\n2. Fix here independently, then bf-781 can rely on it\n\nIf bf-781 is done first with proper guarding, close this as duplicate.\n\n## Current State vs Target State\n\n**Target (in useReviewKeyboardShortcuts.ts:100-104):**\n```typescript\nuseHotkeys('4', () =\u003e {\n  // Only enable diff mode if diff image exists\n  // Note: need to pass diffSrc availability to handlers somehow\n  if (handlers.canShowDiff?.()) {\n    handlers.setViewMode('diff');\n  }\n}, {...});\n```\n\nOR add guard in setViewMode itself.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/hooks/useReviewKeyboardShortcuts.ts - guard diff hotkey\n- OR packages/review-ui/src/hooks/useReviewState.ts - clamp in setter\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different package)\n\n**Cannot Run In Parallel With:**\n- bf-781 (both modify keyboard handling) - PREFER doing bf-781 first\n\n## Estimated Scope\n- **Size:** Small (\u003c20 lines)\n- **Risk:** Low (isolated UI fix)\n\n## Acceptance Criteria\n- [ ] Pressing '4' when no diff exists does nothing\n- [ ] Pressing '4' when diff exists switches to diff mode\n- [ ] No blank viewer state possible via keyboard\n","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-16T18:20:09.254042124-05:00","created_by":"ubuntu","updated_at":"2026-01-19T19:21:08.868018125-05:00","closed_at":"2026-01-19T19:21:08.868018125-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-75p","depends_on_id":"bf-781","type":"blocks","created_at":"2026-01-16T18:33:49.319849255-05:00","created_by":"ubuntu"}]}
{"id":"bf-76k","title":"Add region mask support to generator","notes":"## Context \u0026 Goal\n\n**Problem:** Review UI creates region-based masks (x,y,width,height) but generator only supports selector-based masks. Region masks are silently dropped.\n\n**Why it matters:** Users mask regions in Review UI, CI tests ignore the masks - major trust issue.\n\n**Project goal served:** Masks must actually affect generated tests.\n\n## Current State vs Target State\n\n**Current (packages/generator/src/visual-checks.ts):**\n```typescript\nfunction generateMaskArray(masks: MaskRegion[], pageVar = 'page'): string {\n  const maskItems = masks\n    .map((mask) =\u003e {\n      if (mask.selector) {\n        return `${pageVar}.locator('${escapeString(mask.selector)}')`;\n      }\n      // Region-based masks need custom handling\n      // Playwright doesnt directly support region masks, so wed need a locator\n      return null;  // DROPPED!\n    })\n    .filter((item): item is string =\u003e item !== null);\n  // ...\n}\n```\n\n**Target - Option A (element overlay approach):**\n```typescript\nfunction generateMaskArray(masks: MaskRegion[], pageVar = 'page'): string {\n  const maskItems = masks.map((mask, i) =\u003e {\n    if (mask.selector) {\n      return `${pageVar}.locator('${escapeString(mask.selector)}')`;\n    }\n    if (mask.region) {\n      // Create positioned overlay element for region masking\n      return `${pageVar}.locator('[data-bf-mask=\"${i}\"]')`;\n    }\n    return null;\n  }).filter(Boolean);\n  // ...\n}\n\n// Also generate mask setup code:\nfunction generateMaskSetupCode(masks: MaskRegion[]): string {\n  const regionMasks = masks.filter(m =\u003e m.region);\n  if (regionMasks.length === 0) return '';\n  \n  return `\n  // Inject mask overlay elements for region-based masks\n  await page.evaluate((masks) =\u003e {\n    masks.forEach((mask, i) =\u003e {\n      const div = document.createElement('div');\n      div.setAttribute('data-bf-mask', String(i));\n      div.style.cssText = \\`position:fixed;left:\\${mask.x}%;top:\\${mask.y}%;width:\\${mask.width}%;height:\\${mask.height}%;pointer-events:none;z-index:99999\\`;\n      document.body.appendChild(div);\n    });\n  }, ${JSON.stringify(regionMasks.map(m =\u003e m.region))});`;\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/generator/src/visual-checks.ts - implement region mask handling\n- packages/generator/src/playwright-ts.ts - include mask setup in test output\n\n**Files READ (reference only):**\n- packages/review-ui/src/components/MaskEditor.tsx - understand mask format\n- packages/core/src/spec-schema.ts - verify mask region schema\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different package)\n- bead-fix-testid-args (different files)\n- bead-implement-screenshot-writing (different package)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying visual-checks.ts or playwright-ts.ts\n\n**Blocking Reason:** Generator changes needed before masks work end-to-end\n\n## Estimated Scope\n- **Size:** Medium (100-150 lines)\n- **Risk:** Medium (new code path in generator)\n\n## Acceptance Criteria\n- [ ] Region masks (x,y,width,height) generate valid Playwright code\n- [ ] Overlay elements injected at correct positions\n- [ ] Selector masks still work unchanged\n- [ ] Generated test executes without error\n- [ ] `bun run test` passes in packages/generator\n\n## Testing Requirements\n- Add test: region mask generates overlay injection code\n- Add test: selector mask works as before\n- Add test: mixed masks (region + selector) work together\n- Run: `cd packages/generator \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:20:51.856518821-05:00","created_by":"ubuntu","updated_at":"2026-01-17T18:16:57.837373064-05:00","closed_at":"2026-01-17T18:16:57.837373064-05:00","close_reason":"Closed"}
{"id":"bf-781","title":"Fix keyboard shortcut duplicates in Review UI","notes":"## Context \u0026 Goal\n\n**Problem:** Multiple components handle same shortcuts (m, l, 1-4) via both react-hotkeys-hook AND window.addEventListener. This causes conflicts and race conditions.\n\n**Why it matters:** Unpredictable keyboard behavior frustrates power users.\n\n**Project goal served:** Polish - keyboard shortcuts must be reliable.\n\n## Current State vs Target State\n\n**Current - duplicates:**\n- useReviewKeyboardShortcuts: handles m, l, 1-4\n- MaskEditor: window.addEventListener for m\n- LocatorPicker: window.addEventListener for l  \n- ScreenshotViewer: window.addEventListener for 1-4\n\n**Target - single source:**\n1. Remove all window.addEventListener shortcut handlers from components\n2. Centralize ALL shortcuts in useReviewKeyboardShortcuts\n3. Pass handlers as props to components\n\n```typescript\n// Remove from MaskEditor.tsx:\n// useEffect(() =\u003e {\n//   const handleKeyDown = (e: KeyboardEvent) =\u003e {\n//     if (e.key === 'm') toggleMaskMode();\n//   };\n//   window.addEventListener('keydown', handleKeyDown);\n// }, []);\n\n// Instead, parent passes: onToggleMaskMode={() =\u003e ...}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/hooks/useReviewKeyboardShortcuts.ts - ensure all shortcuts handled\n- packages/review-ui/src/components/MaskEditor.tsx - remove addEventListener\n- packages/review-ui/src/components/LocatorPicker.tsx - remove addEventListener\n- packages/review-ui/src/components/ScreenshotViewer.tsx - remove addEventListener\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1/2 beads (different package)\n- bead-fix-diff-hotkey (can merge into this task)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying these components\n\n**Blocking Reason:** None - cleanup task\n\n## Estimated Scope\n- **Size:** Medium (50-100 lines removed/refactored)\n- **Risk:** Medium (changes event handling flow)\n\n## Acceptance Criteria\n- [ ] No window.addEventListener for shortcuts in components\n- [ ] All shortcuts handled in useReviewKeyboardShortcuts\n- [ ] No shortcut conflicts or double-handling\n- [ ] All shortcuts still work correctly\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Test each shortcut triggers exactly once\n- Test no race conditions with rapid key presses\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-16T18:22:26.55873573-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:44:25.214520804-05:00","closed_at":"2026-01-19T17:44:25.214520804-05:00","close_reason":"Closed"}
{"id":"bf-79r","title":"Require comment for mask highlights","notes":"# Context \u0026 Goal\n\nMasks are being repurposed as \"highlights\" - regions the user wants to call attention to. Every highlight should have an associated comment explaining what the issue is.\n\n## Current State\n\n**File:** `packages/review-ui/src/components/MaskEditor.tsx`\n\nMasks have optional `reason` field:\n```typescript\ninterface Mask {\n  id: string;\n  x: number; y: number; width: number; height: number;\n  reason: string;  // Currently optional in practice\n}\n```\n\n## Target State\n\nWhen user draws a mask:\n1. Popup appears asking for comment\n2. Cannot save mask without comment\n3. UI shows comment alongside mask thumbnail\n\n**Files MODIFIED:**\n- `packages/review-ui/src/components/MaskEditor.tsx` - Add required comment on create\n- `packages/review-ui/src/pages/ReviewPage.tsx` - Update mask creation flow\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill)\n- bf-lkz (screenshots)\n- bf-17e (server)\n\n**Should Wait For:**\n- bf-3el (coordinate with feedback UI changes)\n\n## Estimated Scope\n- **Size:** Small (40-60 lines)\n- **Risk:** Low (UI enhancement)\n\n## Acceptance Criteria\n- [ ] Drawing mask prompts for comment\n- [ ] Cannot create mask without comment\n- [ ] Comment visible in mask thumbnail\n- [ ] Existing mask edit flow unchanged\n\n## Testing Requirements\n- Draw mask - should prompt for comment\n- Try to dismiss without comment - should not save\n- Enter comment - mask saved with comment\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-20T00:21:55.316469757-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:21:55.316469757-05:00","dependencies":[{"issue_id":"bf-79r","depends_on_id":"bf-3el","type":"blocks","created_at":"2026-01-20T00:22:04.286460713-05:00","created_by":"ubuntu"}]}
{"id":"bf-7do","title":"C.2: Implement exploration orchestrator","description":"# Task: Implement Exploration Orchestrator\n\n## Context\nThe Explorer class orchestrates the entire exploration: initializing browser, executing steps, collecting evidence, and producing exploration.json.\n\n## What to Build\n\\`\\`\\`typescript\nimport { BrowserManager } from 'agent-browser';\nimport { Spec, ExplorationOutput, ExplorationStep } from '@browserflow/core';\n\nexport class Explorer {\n  private browser: BrowserManager;\n  private adapter: AIAdapter;\n  private runDir: string;\n  \n  constructor(options: ExplorerOptions) {\n    this.browser = new BrowserManager();\n    this.adapter = options.adapter;\n  }\n  \n  async explore(spec: Spec): Promise\u003cExplorationOutput\u003e {\n    const startTime = Date.now();\n    const steps: ExplorationStep[] = [];\n    \n    try {\n      // 1. Launch browser\n      await this.browser.launch({\n        headless: this.options.headless,\n        viewport: spec.preconditions?.viewport || this.options.viewport\n      });\n      \n      // 2. Navigate to starting page\n      const baseUrl = spec.base_url || this.options.baseUrl;\n      const startPage = spec.preconditions?.page || '/';\n      await this.browser.navigate(\\`\\${baseUrl}\\${startPage}\\`);\n      \n      // 3. Execute each step\n      for (const step of spec.steps) {\n        const result = await this.executeStep(step);\n        steps.push(result);\n        \n        if (result.execution.status === 'failed') {\n          // Continue exploration but mark as failed\n        }\n      }\n      \n      // 4. Build output\n      return {\n        run_id: this.runId,\n        spec_name: spec.name,\n        spec_hash: hashSpec(spec),\n        app_context: this.getAppContext(),\n        steps,\n        status: steps.every(s =\u003e s.execution.status === 'completed') \n          ? 'completed' : 'failed',\n        duration_ms: Date.now() - startTime,\n        errors: []\n      };\n    } finally {\n      await this.browser.close();\n    }\n  }\n  \n  private async executeStep(step: SpecStep): Promise\u003cExplorationStep\u003e {\n    // Delegate to StepExecutor\n  }\n}\n\\`\\`\\`\n\n## Key Behaviors\n1. **Graceful failure handling** - Continue on step failure, mark overall as failed\n2. **Evidence collection** - Screenshots before/after each action\n3. **Timing capture** - Duration per step\n4. **Context preservation** - Save browser state info\n\n## Acceptance Criteria\n- [ ] Can run exploration for a valid spec\n- [ ] Produces valid exploration.json\n- [ ] Handles step failures gracefully (continues)\n- [ ] Collects timing information\n- [ ] Cleans up browser on completion/error","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:39.033215682-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:37.386920955-05:00","closed_at":"2026-01-15T21:59:37.386920955-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-7do","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.334526496-05:00","created_by":"ubuntu"}]}
{"id":"bf-7fc","title":"Add integration test for full pipeline","notes":"## Context \u0026 Goal\n\n**UPDATED**: Per new BrowserFlow design, the pipeline no longer includes `bf codify` as a CLI command. Instead, Claude generates tests manually guided by the skill.\n\n**Problem:** No end-to-end integration test validates the explore → review flow works together.\n\n**Why it matters:** Individual units may work but pipeline may be broken at boundaries.\n\n**Project goal served:** Validate core promises work end-to-end.\n\n## Current State vs Target State\n\n**Current:**\n- Unit tests in each package\n- No cross-package integration test\n\n**Target:**\nCreate test that:\n1. Loads a spec\n2. Runs exploration (`bf explore`)\n3. Verifies exploration.json + screenshots created\n4. Starts review server (`bf review`)\n5. Verifies Review UI loads and shows exploration data\n\nNote: Test generation is now Claude-driven, not tested here.\n\n## Files Inventory\n\n**Files CREATED:**\n- packages/integration-tests/src/pipeline.test.ts\n- packages/integration-tests/fixtures/simple-checkout.yaml\n\n## Parallelization Info\n\nShould run AFTER these fixes complete:\n- bf-lkz (screenshot saving) - exploration needs to write screenshots\n- bf-17e (wire Review UI) - review server needs to serve UI\n\n## Estimated Scope\n- **Size:** Medium (100-150 lines)\n- **Risk:** Medium (depends on many packages)\n\n## Acceptance Criteria\n- [ ] Integration test passes\n- [ ] Covers spec load → explore → review flow\n- [ ] Uses real package APIs\n- [ ] Verifies exploration.json exists with screenshots\n- [ ] Verifies Review UI serves and loads data\n- [ ] Runs in CI\n\n## Dependencies Update\n- Remove dependency on bf-ari (codify command being removed)\n- Add dependency on bf-lkz (screenshot fixing)\n- Add dependency on bf-17e (review UI wiring)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-16T18:23:49.168078994-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:27:23.414325547-05:00","dependencies":[{"issue_id":"bf-7fc","depends_on_id":"bf-yi8","type":"blocks","created_at":"2026-01-17T18:51:16.418508457-05:00","created_by":"ubuntu"},{"issue_id":"bf-7fc","depends_on_id":"bf-x9t","type":"blocks","created_at":"2026-01-19T15:25:21.911934366-05:00","created_by":"ubuntu"},{"issue_id":"bf-7fc","depends_on_id":"bf-ari","type":"blocks","created_at":"2026-01-19T15:25:25.496136061-05:00","created_by":"ubuntu"},{"issue_id":"bf-7fc","depends_on_id":"bf-lkz","type":"blocks","created_at":"2026-01-20T00:27:29.793377458-05:00","created_by":"ubuntu"},{"issue_id":"bf-7fc","depends_on_id":"bf-17e","type":"blocks","created_at":"2026-01-20T00:27:30.961405554-05:00","created_by":"ubuntu"}]}
{"id":"bf-7ne","title":"Add preconditions.page string coercion","notes":"## Context \u0026 Goal\n\n**Problem:** Docs show `preconditions.page: /` (string) but schema expects `{ page: { url: string } }`. Users following docs write invalid specs.\n\n**Why it matters:** Common spec syntax will fail validation.\n\n**Project goal served:** Backward-compatible spec loading.\n\n## Current State vs Target State\n\n**Schema (spec-v2.schema.json:314-321) is correct:**\n```json\n\"page\": {\n  \"type\": \"object\",\n  \"properties\": {\n    \"url\": { \"type\": \"string\" }\n  }\n}\n```\n\n**Need coercion layer in spec loader. Create/update packages/core/src/spec-loader.ts:**\n\n```typescript\nfunction normalizePreconditions(preconditions: unknown): Preconditions {\n  if (\\!preconditions || typeof preconditions \\!== 'object') return {};\n  \n  const pre = preconditions as Record\u003cstring, unknown\u003e;\n  \n  // Coerce string page to object format\n  if (typeof pre.page === 'string') {\n    pre.page = { url: pre.page };\n  }\n  \n  return pre as Preconditions;\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/core/src/spec-loader.ts - add normalizePreconditions function\n- packages/core/src/index.ts - export normalizePreconditions if needed\n\n**Files READ (reference only):**\n- packages/core/schemas/spec-v2.schema.json - verify expected format\n- packages/core/src/spec-schema.ts - understand Zod preconditions schema\n\n**Files CREATED:**\n- None (spec-loader.ts may already exist)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-add-schema-actions (different concern)\n- bead-navigate-url-field (different files)\n- bead-duration-types (different concern)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying spec-loader.ts\n\n**Blocking Reason:** Coercion must happen before validation in spec load path\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (additive, backward compatible)\n\n## Acceptance Criteria\n- [ ] Spec with `preconditions.page: /` loads and validates\n- [ ] Spec with `preconditions.page: { url: / }` still works\n- [ ] Tests cover both formats\n- [ ] `bun run test` passes in packages/core\n\n## Testing Requirements\n- Add test for string preconditions.page coercion\n- Add test for object preconditions.page passthrough\n- Run: `cd packages/core \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:18:49.168577906-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:54:27.331092416-05:00","closed_at":"2026-01-19T15:54:27.331092416-05:00","close_reason":"Closed"}
{"id":"bf-7qo","title":"Create command palette for Review UI","notes":"## Context \u0026 Goal\n\n**Problem:** Many keyboard shortcuts are hard to discover. Power users need quick access to all actions.\n\n**Why it matters:** Command palette is a premium UX pattern (VS Code, Slack, Linear).\n\n**Project goal served:** Premium UX - discoverability + power user efficiency.\n\n## Current State vs Target State\n\n**Current:**\n- Keyboard shortcuts only\n- Help modal lists all shortcuts\n- No searchable command interface\n\n**Target:**\nAdd Cmd+K / Ctrl+K command palette:\n\n```typescript\n// packages/review-ui/src/components/CommandPalette.tsx\nfunction CommandPalette({ isOpen, onClose, commands }: Props) {\n  const [query, setQuery] = useState('');\n  const filtered = useMemo(() =\u003e \n    commands.filter(c =\u003e c.label.toLowerCase().includes(query.toLowerCase())),\n    [commands, query]\n  );\n  \n  if (!isOpen) return null;\n  \n  return (\n    \u003cdiv className=\"command-palette-overlay\"\u003e\n      \u003cdiv className=\"command-palette\"\u003e\n        \u003cinput \n          value={query}\n          onChange={e =\u003e setQuery(e.target.value)}\n          placeholder=\"Type a command...\"\n          autoFocus\n        /\u003e\n        \u003cul\u003e\n          {filtered.map(cmd =\u003e (\n            \u003cli key={cmd.id} onClick={() =\u003e { cmd.action(); onClose(); }}\u003e\n              \u003cspan className=\"label\"\u003e{cmd.label}\u003c/span\u003e\n              \u003cspan className=\"shortcut\"\u003e{cmd.shortcut}\u003c/span\u003e\n            \u003c/li\u003e\n          ))}\n        \u003c/ul\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\n// Commands list:\nconst commands = [\n  { id: 'approve', label: 'Approve step', shortcut: 'a', action: approveStep },\n  { id: 'reject', label: 'Reject step', shortcut: 'r', action: rejectStep },\n  { id: 'mask', label: 'Add mask', shortcut: 'm', action: toggleMaskMode },\n  { id: 'lock', label: 'Lock locator', shortcut: 'l', action: lockLocator },\n  { id: 'submit', label: 'Submit review', shortcut: 'Ctrl+S', action: submitReview },\n  { id: 'help', label: 'Show shortcuts', shortcut: '?', action: showHelp },\n  // ...\n];\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/hooks/useReviewKeyboardShortcuts.ts - add Ctrl+K handler\n- packages/review-ui/src/ReviewPage.tsx - render CommandPalette\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- packages/review-ui/src/components/CommandPalette.tsx\n- packages/review-ui/src/components/CommandPalette.css\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Most other beads\n\n**Cannot Run In Parallel With:**\n- bead-fix-keyboard-duplicates (touching same hook)\n\n**Blocking Reason:** None - nice-to-have polish\n\n## Estimated Scope\n- **Size:** Medium (80-120 lines)\n- **Risk:** Low (additive feature)\n\n## Acceptance Criteria\n- [ ] Ctrl/Cmd+K opens palette\n- [ ] Typing filters commands\n- [ ] Enter/click executes command\n- [ ] Escape closes palette\n- [ ] All main actions accessible\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Test: opens on Ctrl+K\n- Test: filters by query\n- Test: executes selected command\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-16T18:23:42.604907564-05:00","created_by":"ubuntu","updated_at":"2026-01-16T18:23:42.604907564-05:00"}
{"id":"bf-8h2","title":"Sync Zod schema with JSON schema","notes":"## Context \u0026 Goal\n\n**Problem:** After updating spec-v2.schema.json with new actions, the Zod schema in spec-schema.ts must be synchronized.\n\n**Why it matters:** Zod schema is used for runtime validation - must match JSON schema.\n\n**Project goal served:** Single source of truth for spec validation.\n\n## Current State vs Target State\n\n**Current (packages/core/src/spec-schema.ts ~line 20-40):**\n```typescript\nconst actionSchema = z.enum([\n  'click', 'navigate', 'back', 'forward', 'refresh',\n  'fill', 'type', 'select', 'check',\n  'wait', 'expect', 'screenshot',\n  'verify_state', 'identify_element', 'ai_verify', 'custom'\n]);\n```\n\n**Target:**\n```typescript\nconst actionSchema = z.enum([\n  'click', 'navigate', 'back', 'forward', 'refresh', 'reload',\n  'fill', 'type', 'select', 'check', 'press', 'upload',\n  'wait', 'expect', 'screenshot', 'scroll', 'scroll_into_view',\n  'verify_state', 'identify_element', 'ai_verify', 'custom'\n]);\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/core/src/spec-schema.ts (lines ~20-40) - update action enum\n\n**Files READ (reference only):**\n- packages/core/schemas/spec-v2.schema.json - source of truth for actions\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-navigate-url-field (different files)\n- bead-duration-types (different files)\n\n**Cannot Run In Parallel With:**\n- bead-add-schema-actions - MUST complete first (dependency)\n\n**Blocking Reason:** JSON schema is source of truth, Zod must follow\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (synchronization only)\n\n## Acceptance Criteria\n- [ ] Zod actionSchema matches JSON schema action enum exactly\n- [ ] TypeScript action types derived from Zod include new actions\n- [ ] `bun run test` passes in packages/core\n\n## Testing Requirements\n- Existing validation tests should pass\n- Type-check that new actions are valid: `const x: Action = 'press'`\n- Run: `cd packages/core \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:19:22.278446541-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:54:27.329616067-05:00","closed_at":"2026-01-19T15:54:27.329616067-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-8h2","depends_on_id":"bf-3a1","type":"blocks","created_at":"2026-01-16T18:19:31.820964296-05:00","created_by":"ubuntu"}]}
{"id":"bf-8k4","title":"D.1: Create @browserflow/review-ui package with React + Vite","description":"# Task: Create Review UI Package\n\n## Context\nThe Review UI is a React SPA for human review of explorations. It uses Vite for fast development, Tailwind for styling, and shadcn/ui for premium components.\n\n## What to Build\n\\`\\`\\`\npackages/review-ui/\n├── src/\n│   ├── main.tsx           # Entry point\n│   ├── App.tsx            # Root component\n│   ├── components/        # UI components\n│   ├── hooks/             # Custom hooks\n│   ├── lib/               # Utilities\n│   └── styles/\n│       └── globals.css    # Tailwind imports\n├── index.html\n├── package.json\n├── tsconfig.json\n├── vite.config.ts\n├── tailwind.config.js\n└── postcss.config.js\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/review-ui\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.20.0\",\n    \"@radix-ui/react-*\": \"...\",\n    \"class-variance-authority\": \"^0.7.0\",\n    \"clsx\": \"^2.0.0\",\n    \"tailwind-merge\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@vitejs/plugin-react\": \"^4.2.0\",\n    \"tailwindcss\": \"^3.4.0\",\n    \"autoprefixer\": \"^10.4.0\",\n    \"postcss\": \"^8.4.0\",\n    \"vite\": \"^5.0.0\"\n  }\n}\n\\`\\`\\`\n\n## vite.config.ts\n\\`\\`\\`typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  build: {\n    outDir: 'dist',\n    // For embedding in CLI\n    rollupOptions: {\n      output: {\n        manualChunks: undefined,\n      },\n    },\n  },\n});\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bun run dev\\` starts Vite dev server\n- [ ] \\`bun run build\\` produces static assets\n- [ ] Tailwind CSS works\n- [ ] shadcn/ui components available\n- [ ] Can be served by CLI package","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:46.873878559-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:31:58.140222329-05:00","closed_at":"2026-01-15T21:31:58.140222329-05:00","close_reason":"Closed"}
{"id":"bf-8w0","title":"Add autosave drafts to Review UI","notes":"## Context \u0026 Goal\n\n**Problem:** Review UI has no autosave - all work lost on browser refresh.\n\n**Why it matters:** Users lose review progress if they accidentally close tab.\n\n**Project goal served:** Premium UX - data safety.\n\n## Current State vs Target State\n\n**Current:**\n- Review state only in React state\n- No persistence\n\n**Target:**\n```typescript\n// packages/review-ui/src/hooks/useReviewState.ts\n\nfunction useReviewState(explorationId: string) {\n  const [state, setState] = useState\u003cReviewState\u003e(() =\u003e {\n    // Load from localStorage on init\n    const saved = localStorage.getItem(`review-draft-${explorationId}`);\n    return saved ? JSON.parse(saved) : initialState;\n  });\n  \n  // Autosave on state change\n  useEffect(() =\u003e {\n    if (state.isDirty) {\n      localStorage.setItem(`review-draft-${explorationId}`, JSON.stringify(state));\n    }\n  }, [state, explorationId]);\n  \n  // Clear draft on successful submit\n  const clearDraft = () =\u003e {\n    localStorage.removeItem(`review-draft-${explorationId}`);\n  };\n  \n  return { ...state, clearDraft };\n}\n```\n\nAlso add \"Draft saved\" indicator in UI header.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/hooks/useReviewState.ts - add localStorage persistence\n- packages/review-ui/src/App.tsx or ReviewPage.tsx - add draft indicator\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1/2/3 beads (different concern)\n- bead-add-toast-system (different focus)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying useReviewState.ts\n\n**Blocking Reason:** None - nice to have, not blocking\n\n## Estimated Scope\n- **Size:** Small (30-50 lines)\n- **Risk:** Low (additive feature)\n\n## Acceptance Criteria\n- [ ] State persists to localStorage\n- [ ] Refresh browser restores state\n- [ ] Clear draft on successful submit\n- [ ] Draft indicator shows in header\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Test: state saves to localStorage on change\n- Test: state loads from localStorage on init\n- Test: draft cleared after submit\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-16T18:22:24.776154231-05:00","created_by":"ubuntu","updated_at":"2026-01-16T18:22:24.776154231-05:00"}
{"id":"bf-920","title":"D.4: Implement locator picker component","description":"# Task: Implement Locator Picker Component\n\n## Context\nThe locator picker shows locator candidates from exploration and lets reviewers lock the preferred strategy. This is critical for deterministic test generation.\n\n## What to Build\n\\`\\`\\`typescript\ninterface LocatorPickerProps {\n  candidates: LocatorCandidate[];\n  currentLocator?: LocatorObject;\n  onLockLocator: (locator: LocatorObject) =\u003e void;\n}\n\nexport function LocatorPicker({ candidates, currentLocator, onLockLocator }: LocatorPickerProps) {\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  \n  return (\n    \u003cdiv className=\"space-y-4\"\u003e\n      \u003cdiv className=\"flex justify-between items-center\"\u003e\n        \u003ch3 className=\"font-semibold\"\u003eLocator\u003c/h3\u003e\n        \u003cBadge variant={currentLocator ? 'default' : 'outline'}\u003e\n          {currentLocator ? 'Locked' : 'Not locked'}\n        \u003c/Badge\u003e\n      \u003c/div\u003e\n      \n      {/* Current locked locator */}\n      {currentLocator \u0026\u0026 (\n        \u003cdiv className=\"p-3 bg-green-50 border border-green-200 rounded\"\u003e\n          \u003cdiv className=\"text-sm font-medium text-green-800\"\u003ePreferred\u003c/div\u003e\n          \u003ccode className=\"text-xs\"\u003e{formatStrategy(currentLocator.preferred)}\u003c/code\u003e\n        \u003c/div\u003e\n      )}\n      \n      {/* Candidate list */}\n      \u003cdiv className=\"space-y-2\"\u003e\n        {candidates.map((candidate, index) =\u003e (\n          \u003cCandidateRow\n            key={index}\n            candidate={candidate}\n            isSelected={index === selectedIndex}\n            onClick={() =\u003e setSelectedIndex(index)}\n            onLock={() =\u003e onLockLocator(candidateToLocator(candidate))}\n          /\u003e\n        ))}\n      \u003c/div\u003e\n      \n      {/* Lock button */}\n      \u003cButton onClick={() =\u003e onLockLocator(candidateToLocator(candidates[selectedIndex]))}\u003e\n        Lock Selected as Preferred\n      \u003c/Button\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction CandidateRow({ candidate, isSelected, onClick, onLock }) {\n  return (\n    \u003cdiv\n      className={cn(\n        \"p-3 border rounded cursor-pointer\",\n        isSelected \u0026\u0026 \"border-blue-500 bg-blue-50\"\n      )}\n      onClick={onClick}\n    \u003e\n      \u003cdiv className=\"flex justify-between items-start\"\u003e\n        \u003cdiv\u003e\n          \u003cBadge variant=\"secondary\"\u003e{candidate.strategy.type}\u003c/Badge\u003e\n          \u003ccode className=\"ml-2 text-sm\"\u003e{formatStrategy(candidate.strategy)}\u003c/code\u003e\n        \u003c/div\u003e\n        \u003cdiv className=\"text-right\"\u003e\n          \u003cdiv className=\"text-sm\"\u003e{Math.round(candidate.confidence * 100)}% confidence\u003c/div\u003e\n          \u003cdiv className=\"text-xs text-muted-foreground\"\u003e\n            {candidate.match_count} match{candidate.match_count !== 1 ? 'es' : ''}\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction formatStrategy(strategy: LocatorStrategy): string {\n  switch (strategy.type) {\n    case 'testid':\n      return \\`[data-testid=\"\\${strategy.value}\"]\\`;\n    case 'role':\n      return \\`getByRole('\\${strategy.role}', { name: '\\${strategy.name}' })\\`;\n    case 'label':\n      return \\`getByLabel('\\${strategy.text}')\\`;\n    case 'css':\n      return strategy.selector;\n    default:\n      return JSON.stringify(strategy);\n  }\n}\n\\`\\`\\`\n\n## Features\n- Shows all candidates ranked by confidence\n- Displays confidence % and match count\n- Highlights selected candidate\n- One-click lock to preferred\n- Shows currently locked locator\n\n## Acceptance Criteria\n- [ ] All candidates displayed with confidence\n- [ ] Can select and lock a candidate\n- [ ] Locked state persists to lockfile\n- [ ] Shows testid/role/css in readable format\n- [ ] 'l' keyboard shortcut focuses picker","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:36.871668569-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.605376438-05:00","closed_at":"2026-01-15T22:02:18.605376438-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-920","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.10335248-05:00","created_by":"ubuntu"}]}
{"id":"bf-92j","title":"A.6: Implement run store (immutable directories)","description":"# Task: Implement Run Store\n\n## Context\nEvery exploration creates an immutable run directory. The run store manages creating these directories, maintaining \"latest\" symlinks, and ensuring runs are never overwritten.\n\n## Why Immutability Matters\n- Can diff between runs to see what changed\n- History preserved for debugging\n- No accidental data loss from re-exploration\n- Audit trail for compliance\n\n## What to Build\n\\`\\`\\`typescript\ninterface RunStore {\n  // Create new run directory, returns path\n  createRun(specName: string): Promise\u003cstring\u003e;\n  \n  // Get path to latest run for spec (or null)\n  getLatestRun(specName: string): string | null;\n  \n  // List all runs for a spec, newest first\n  listRuns(specName: string): string[];\n  \n  // Get full path to specific run\n  getRunDir(specName: string, runId: string): string;\n  \n  // Check if run exists\n  runExists(specName: string, runId: string): boolean;\n}\n\\`\\`\\`\n\n## Directory Structure\n\\`\\`\\`\n.browserflow/\n├── runs/\n│   └── checkout-cart/\n│       ├── run-20260115-031000-abc123/\n│       │   ├── exploration.json\n│       │   ├── review.json\n│       │   ├── lockfile.json\n│       │   └── artifacts/\n│       │       ├── screenshots/\n│       │       ├── trace.zip\n│       │       └── logs/\n│       ├── run-20260115-041500-def456/\n│       │   └── ...\n│       └── latest -\u003e run-20260115-041500-def456\n├── cache/\n└── tmp/\n\\`\\`\\`\n\n## Run ID Generation\n\\`\\`\\`typescript\nimport crypto from 'crypto';\n\nfunction createRunId(): string {\n  const now = new Date();\n  const ts = now.toISOString()\n    .replace(/[-:T]/g, '')\n    .slice(0, 14);  // YYYYMMDDHHMMSS\n  const rand = crypto.randomBytes(3).toString('hex');\n  return \\`run-\\${ts}-\\${rand}\\`;\n}\n// Example: run-20260115031000-a3f2dd\n\\`\\`\\`\n\n## Platform Considerations\n- Unix/Mac: Use symlinks for \"latest\"\n- Windows: Use junctions (fs.symlink with 'junction' type)\n- Handle race conditions in concurrent creation\n\n## Acceptance Criteria\n- [ ] Run directories never overwritten\n- [ ] \"latest\" symlink updated atomically on new run\n- [ ] Multiple runs for same spec coexist\n- [ ] Works on Windows (junctions) and Unix (symlinks)\n- [ ] Race conditions handled safely","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:24.298164687-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.06649772-05:00","closed_at":"2026-01-15T22:27:55.06649772-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-92j","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.616991847-05:00","created_by":"ubuntu"}]}
{"id":"bf-93d","title":"Update review.json schema for feedback-focused output","notes":"# Context \u0026 Goal\n\nThe review.json output needs to be optimized for Claude to read and diagnose issues. It should contain:\n- Overall comment from user\n- Per-step comments\n- Per-step masks with highlight regions and associated comments\n- Step references to exploration data\n\n## Current State\n\n**File:** `packages/cli/src/commands/review.ts` (line 35-38)\nCurrently just saves whatever JSON the UI sends.\n\nThe UI sends (from useReviewState.ts):\n```typescript\n{\n  [stepIndex]: {\n    status: \"approved\" | \"rejected\" | \"pending\",\n    comment: string,\n    masks: Mask[],\n    lockedLocator?: LocatorObject\n  }\n}\n```\n\n## Target State\n\nNew schema optimized for LLM consumption:\n\n```typescript\ninterface ReviewReport {\n  exploration_id: string;\n  spec: string;\n  reviewed_at: string;\n  overall_comment?: string;  // NEW: top-level feedback\n  steps: Array\u003c{\n    step_index: number;\n    step_id: string;  // from spec (e.g., \"fill-input\")\n    has_feedback: boolean;  // replaces status\n    comment?: string;\n    highlights: Array\u003c{  // renamed from masks\n      id: string;\n      x: number; y: number; width: number; height: number;\n      comment: string;  // REQUIRED for highlights\n    }\u003e;\n  }\u003e;\n}\n```\n\n**Files MODIFIED:**\n- `packages/cli/src/commands/review.ts` (lines 35-38) - Add schema validation\n- `packages/review-ui/src/hooks/useReviewState.ts` - Update output format\n- `packages/review-ui/src/App.tsx` - Update submit handler\n\n**Files CREATED:**\n- `packages/core/src/review-schema.ts` - Zod schema for review reports\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill)\n- bf-lkz (screenshots)\n\n**Must Wait For:**\n- bf-3el (depends on UI changes being done first)\n\n## Estimated Scope\n- **Size:** Medium (80-120 lines)\n- **Risk:** Low (schema change, backward compat not critical for new system)\n\n## Acceptance Criteria\n- [ ] Zod schema validates review reports\n- [ ] Review UI outputs new format\n- [ ] overall_comment field supported\n- [ ] highlights have required comment field\n- [ ] review.json is human-readable and LLM-friendly\n\n## Testing Requirements\n- Submit review with comments and masks\n- Read review.json - should match new schema\n- Feed to Claude - should be easy to parse\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-20T00:21:04.565507632-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:21:04.565507632-05:00","dependencies":[{"issue_id":"bf-93d","depends_on_id":"bf-3el","type":"blocks","created_at":"2026-01-20T00:22:01.959942175-05:00","created_by":"ubuntu"}]}
{"id":"bf-9ei","title":"Epic D: Review UI v1","description":"# Epic D: Review UI v1 (Core)\n\n## Strategic Context\n\nThe Review UI is where BrowserFlow becomes **premium**. This is the human gate where intent becomes deterministic. The spec calls for \"Stripe-level experience: fast, opinionated, polished, keyboard-driven.\"\n\nv1 focuses on **core review workflow**. v2 (Epic H) adds polish features like mask editor and assertion builder.\n\n## Why This Matters\n\n**Review is the quality gate.** No test gets codified without human sign-off.\n\nThe UI must make it **fast and pleasant** to:\n- Approve correct steps\n- Reject problematic steps with feedback\n- Lock the right locator from candidates\n- Understand what the AI did\n\nIf review is painful, people skip it. If people skip review, tests are unreliable.\n\n## Deliverables\n\n1. **@browserflow/review-ui package** (React SPA)\n2. **Step timeline** with thumbnails and status chips\n3. **Screenshot viewer** with 4 modes:\n   - Side-by-side\n   - Slider wipe\n   - Blink A/B\n   - Diff overlay\n4. **Approve/reject workflow** per step\n5. **Locator picker** - Show candidates, lock preferred\n6. **Comment and tag fields**\n7. **Keyboard shortcuts** (j/k navigate, a/approve, r/reject)\n8. **CLI server** to serve UI and handle API\n9. **review.json output** - Human decisions\n10. **lockfile.json output** - Resolved locators for generation\n\n## Acceptance Criteria\n\n- [ ] Reviewer can approve/reject all steps\n- [ ] Keyboard navigation works (j/k/a/r)\n- [ ] Screenshot comparison modes all functional\n- [ ] Locator locking persists to lockfile\n- [ ] Comments persist across sessions\n- [ ] Review produces valid review.json and lockfile.json\n- [ ] UI is responsive and doesn't feel janky\n- [ ] Light/dark mode support (stretch)\n\n## Dependencies\n\n- **Depends on Epic A** - Core types for lockfile, locators\n- **Depends on Epic C** - Exploration output to review\n\n## Technical Decisions\n\n**Why React + Tailwind + shadcn/ui?**\n- React: Rich component ecosystem, good state management\n- Tailwind: Rapid iteration, consistent design tokens\n- shadcn/ui: Premium components, accessible, customizable\n\n**Information Architecture:**\n\\`\\`\\`\n┌─────────────┬───────────────────────────────────┬───────────────────┐\n│   STEPS     │         MAIN PANEL                │    INSPECTOR      │\n│  (timeline) │   (screenshot viewer)             │  (locators, etc)  │\n└─────────────┴───────────────────────────────────┴───────────────────┘\n\\`\\`\\`\n\n**Keyboard shortcuts (from spec):**\n| Key | Action |\n|-----|--------|\n| j/↓ | Next step |\n| k/↑ | Previous step |\n| a | Approve |\n| r | Reject |\n| 1-4 | Screenshot view modes |\n| Ctrl+S | Submit review |\n\n## User Journey\n\n\\`\\`\\`\nbf explore --spec checkout-cart\n    ↓\nbf review --spec checkout-cart\n    ↓\nBrowser opens to http://localhost:8190/review/checkout-cart/run-xxx\n    ↓\nUser sees step timeline, clicks through\n    ↓\nUser approves most steps, rejects one with comment\n    ↓\nUser locks preferred locator for ambiguous step\n    ↓\nUser clicks \"Submit Review\"\n    ↓\nlockfile.json created, ready for generation\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 9: Review Phase\n- Section 10: Generation Phase (lockfile is input)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:53.772351054-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.726677699-05:00","closed_at":"2026-01-16T17:18:41.726677699-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-9ei","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:47:00.074525905-05:00","created_by":"ubuntu"},{"issue_id":"bf-9ei","depends_on_id":"bf-6yr","type":"blocks","created_at":"2026-01-15T17:47:00.158681822-05:00","created_by":"ubuntu"}]}
{"id":"bf-9x7","title":"Remove bf codify command (move to skill guidance)","notes":"# Context \u0026 Goal\n\nPer new design, `bf codify` should NOT be a CLI command. Instead, the BrowserFlow skill should guide Claude to generate Playwright tests directly from exploration + review feedback.\n\nThis keeps the CLI simple (explore, review) and lets Claude handle the intelligent test generation with iteration.\n\n## Current State\n\n**File:** `packages/cli/src/commands/codify.ts` - Full implementation exists\n**File:** `packages/cli/src/index.ts` - Registers codify command\n\n## Target State\n\n1. Remove codify command from CLI\n2. Add test generation guidance to BrowserFlow skill\n3. Keep the generator package (Claude can use it via code if needed)\n\n**Files MODIFIED:**\n- `packages/cli/src/index.ts` - Remove codify import/registration\n\n**Files DELETED:**\n- `packages/cli/src/commands/codify.ts`\n- `packages/cli/src/commands/codify.test.ts`\n\n**Files READ:**\n- `packages/generator/src/playwright-ts.ts` - Understand what codify did (for skill docs)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads (independent removal)\n\n**Blocking Reason:** None\n\n## Estimated Scope\n- **Size:** Small (deletion + skill update)\n- **Risk:** Low (removing unused feature)\n\n## Acceptance Criteria\n- [ ] `bf codify` no longer exists\n- [ ] `bf --help` does not show codify\n- [ ] Skill includes guidance for generating tests manually\n- [ ] Generator package still exists for programmatic use\n\n## Testing Requirements\n- Run `bf --help` - no codify\n- Run `bf codify` - error \"unknown command\"\n- Follow skill guidance to generate test manually\n","status":"open","priority":2,"issue_type":"chore","created_at":"2026-01-20T00:21:32.523744931-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:21:32.523744931-05:00"}
{"id":"bf-aak","title":"A.7: Implement lockfile types","description":"# Task: Implement Lockfile Types\n\n## Context\nThe lockfile is the canonical source for code generation. It contains all resolved locators, masks, and assertions from human review. Generation reads ONLY from the lockfile - never from raw exploration output.\n\n## What to Build\n\\`\\`\\`typescript\ninterface Lockfile {\n  // Identification\n  run_id: string;\n  spec_name: string;\n  spec_hash: string;  // SHA256 of spec file at review time\n  created_at: string; // ISO8601\n  \n  // Resolved locators (keyed by step_id or locator_id)\n  locators: Record\u003cstring, LocatorObject\u003e;\n  \n  // Masks for screenshots (keyed by screenshot name)\n  masks: Record\u003cstring, Mask[]\u003e;\n  \n  // Assertions (from review)\n  assertions: Assertion[];\n  \n  // Generation metadata\n  generation: {\n    format: 'playwright-ts';\n    output_path: string;\n    generated_at?: string;\n  };\n}\n\ninterface Mask {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  reason: string;  // Why this region is masked\n  locator?: string; // Optional: derived from element locator\n}\n\ninterface Assertion {\n  id: string;\n  type: AssertionType;\n  target?: LocatorObject;\n  expected?: string | number | boolean;\n  step_id?: string;  // If attached to specific step\n}\n\ntype AssertionType = \n  | 'visible'\n  | 'hidden'\n  | 'text_contains'\n  | 'text_equals'\n  | 'url_contains'\n  | 'url_matches'\n  | 'count'\n  | 'attribute'\n  | 'checked'\n  | 'screenshot';\n\\`\\`\\`\n\n## File Operations\n\\`\\`\\`typescript\nfunction readLockfile(runDir: string): Promise\u003cLockfile\u003e;\nfunction writeLockfile(runDir: string, lockfile: Lockfile): Promise\u003cvoid\u003e;\nfunction validateLockfile(lockfile: unknown): lockfile is Lockfile;\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Types match spec section 9.8\n- [ ] Zod schema validates lockfiles\n- [ ] Read/write functions handle file I/O\n- [ ] Missing optional fields handled gracefully\n- [ ] spec_hash computed consistently","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:37.901866983-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.067870267-05:00","closed_at":"2026-01-15T22:27:55.067870267-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-aak","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.707499783-05:00","created_by":"ubuntu"}]}
{"id":"bf-apb","title":"D.5: Implement keyboard shortcuts","description":"# Task: Implement Keyboard Shortcuts\n\n## Context\nPremium UX requires keyboard-driven workflows. The Review UI should be fully navigable via keyboard shortcuts per spec section 9.3.\n\n## What to Build\n\\`\\`\\`typescript\nimport { useHotkeys } from 'react-hotkeys-hook';\n\nexport function useReviewKeyboardShortcuts(handlers: ReviewHandlers) {\n  // Navigation\n  useHotkeys('j', handlers.nextStep, { description: 'Next step' });\n  useHotkeys('down', handlers.nextStep);\n  useHotkeys('k', handlers.prevStep, { description: 'Previous step' });\n  useHotkeys('up', handlers.prevStep);\n  \n  // Review actions\n  useHotkeys('a', handlers.approveStep, { description: 'Approve current step' });\n  useHotkeys('r', handlers.rejectStep, { description: 'Reject current step' });\n  \n  // UI actions\n  useHotkeys('m', handlers.addMask, { description: 'Add mask' });\n  useHotkeys('l', handlers.focusLocatorPicker, { description: 'Lock locator' });\n  useHotkeys('e', handlers.addAssertion, { description: 'Add assertion' });\n  useHotkeys('c', handlers.focusComment, { description: 'Focus comment field' });\n  \n  // View modes\n  useHotkeys('1', () =\u003e handlers.setViewMode('side-by-side'));\n  useHotkeys('2', () =\u003e handlers.setViewMode('slider'));\n  useHotkeys('3', () =\u003e handlers.setViewMode('blink'));\n  useHotkeys('4', () =\u003e handlers.setViewMode('diff'));\n  \n  // Search\n  useHotkeys('/', handlers.openSearch, { description: 'Search steps' });\n  \n  // Submit\n  useHotkeys('mod+s', handlers.submitReview, { description: 'Submit review' });\n  \n  // Help\n  useHotkeys('mod+?', handlers.showHelp, { description: 'Show shortcuts' });\n  useHotkeys('escape', handlers.closeModal);\n}\n\\`\\`\\`\n\n## Shortcuts Reference (from Spec)\n| Key | Action |\n|-----|--------|\n| j / ↓ | Next step |\n| k / ↑ | Previous step |\n| a | Approve current step |\n| r | Reject current step |\n| m | Add mask |\n| l | Lock locator |\n| e | Add assertion |\n| c | Focus comment field |\n| / | Search steps |\n| 1-4 | Screenshot view modes |\n| Ctrl+S | Submit review |\n| Ctrl+? | Show keyboard shortcuts |\n| Escape | Close modal/cancel |\n\n## Help Modal\n\\`\\`\\`typescript\nexport function KeyboardShortcutsHelp() {\n  return (\n    \u003cDialog\u003e\n      \u003cDialogContent\u003e\n        \u003cDialogHeader\u003e\n          \u003cDialogTitle\u003eKeyboard Shortcuts\u003c/DialogTitle\u003e\n        \u003c/DialogHeader\u003e\n        \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e\n          {shortcuts.map(({ key, description }) =\u003e (\n            \u003cdiv key={key} className=\"flex justify-between\"\u003e\n              \u003cspan\u003e{description}\u003c/span\u003e\n              \u003ckbd className=\"px-2 py-1 bg-muted rounded\"\u003e{key}\u003c/kbd\u003e\n            \u003c/div\u003e\n          ))}\n        \u003c/div\u003e\n      \u003c/DialogContent\u003e\n    \u003c/Dialog\u003e\n  );\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] All shortcuts from spec work\n- [ ] j/k navigate steps\n- [ ] a/r approve/reject\n- [ ] 1-4 switch view modes\n- [ ] Ctrl+S submits review\n- [ ] Help modal shows all shortcuts\n- [ ] Shortcuts don't interfere with text input","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:43:53.418823572-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:01:38.105103396-05:00","closed_at":"2026-01-15T23:01:38.105103396-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-apb","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.208286605-05:00","created_by":"ubuntu"}]}
{"id":"bf-ari","title":"Implement bf codify CLI command","notes":"## Context \u0026 Goal\n\n**Problem:** The generator package exists (\\`@browserflow/generator\\`) but there's no CLI command to invoke it. Users can't generate Playwright tests from approved explorations via command line.\n\n**Why it matters:** This is the final step in the workflow: exploration -\u003e review -\u003e codify -\u003e run. Without \\`bf codify\\`, users can't complete the loop.\n\n**Project goal served:** Enable test generation from approved explorations.\n\n## Current State vs Target State\n\n**Current (packages/cli/src/index.ts:1-38):**\n\\`\\`\\`typescript\n// Commands: init, doctor, lint, run, baseline, repair\n// NO codify command!\n\\`\\`\\`\n\n**Target - add codifyCommand to CLI:**\n\n\\`\\`\\`typescript\n// packages/cli/src/index.ts\nimport { codifyCommand } from './commands/codify.js';\n\n// In createProgram():\nprogram.addCommand(codifyCommand());\n\\`\\`\\`\n\n**New file packages/cli/src/commands/codify.ts:**\n\\`\\`\\`typescript\nimport { Command } from 'commander';\nimport { readFile, writeFile, mkdir, readdir } from 'node:fs/promises';\nimport { join, dirname } from 'node:path';\nimport { generateTest } from '@browserflow/generator';\nimport type { ExplorationLockfile, ReviewData } from '@browserflow/core';\nimport { colors } from '../ui/colors.js';\n\nexport function codifyCommand(): Command {\n  return new Command('codify')\n    .description('Generate Playwright test from approved exploration')\n    .requiredOption('--spec \u003cname\u003e', 'Spec name to codify')\n    .option('--exploration \u003cid\u003e', 'Specific exploration ID (default: latest for spec)')\n    .option('--output \u003cdir\u003e', 'Output directory', 'e2e/tests')\n    .option('--dry-run', 'Print generated test without writing')\n    .action(async (options) =\u003e {\n      // 1. Find exploration directory\n      const explorationId = options.exploration || await findLatestExploration(options.spec);\n      if (!explorationId) {\n        console.error(colors.error(\\`No exploration found for spec: \\${options.spec}\\`));\n        process.exit(1);\n      }\n      \n      const explorationDir = \\`.browserflow/explorations/\\${explorationId}\\`;\n      \n      // 2. Load exploration data (convert to lockfile format)\n      const explorationPath = join(explorationDir, 'exploration.json');\n      const explorationData = JSON.parse(await readFile(explorationPath, 'utf-8'));\n      const lockfile = convertToLockfile(explorationData);\n      \n      // 3. Load review data (optional - may not be approved yet)\n      let review: ReviewData | undefined;\n      try {\n        const reviewPath = join(explorationDir, 'review.json');\n        review = JSON.parse(await readFile(reviewPath, 'utf-8'));\n        console.log(colors.info(\\`Using review from \\${review.reviewed_at}\\`));\n      } catch {\n        console.log(colors.warning('No review found - generating without approval metadata'));\n      }\n      \n      // 4. Generate test\n      const result = generateTest(lockfile, { includeVisualChecks: true }, review);\n      \n      // 5. Write or print\n      if (options.dryRun) {\n        console.log(result.content);\n      } else {\n        const outputPath = join(options.output, \\`\\${options.spec}.spec.ts\\`);\n        await mkdir(dirname(outputPath), { recursive: true });\n        await writeFile(outputPath, result.content);\n        console.log(colors.success(\\`Generated: \\${outputPath}\\`));\n        console.log(\\`Run \\\\\\`bf run --spec \\${options.spec}\\\\\\` to execute\\`);\n      }\n    });\n}\n\nasync function findLatestExploration(specName: string): Promise\u003cstring | null\u003e {\n  const explorationsDir = '.browserflow/explorations';\n  try {\n    const entries = await readdir(explorationsDir);\n    // Find explorations for this spec, sorted by timestamp (newest first)\n    const matching = entries\n      .filter(e =\u003e e.startsWith('exp-'))\n      .sort()\n      .reverse();\n    \n    for (const id of matching) {\n      const explorationPath = join(explorationsDir, id, 'exploration.json');\n      try {\n        const data = JSON.parse(await readFile(explorationPath, 'utf-8'));\n        if (data.spec === specName) {\n          return id;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return null;\n  } catch {\n    return null;\n  }\n}\n\nfunction convertToLockfile(exploration: ExplorationOutput): ExplorationLockfile {\n  // Convert ExplorationOutput to ExplorationLockfile format\n  return {\n    spec: exploration.spec,\n    spec_path: exploration.specPath,\n    exploration_id: exploration.explorationId,\n    timestamp: exploration.timestamp,\n    steps: exploration.steps.map(step =\u003e ({\n      spec_action: step.specAction,\n      execution: step.execution,\n    })),\n    outcome_checks: exploration.outcomeChecks,\n    // ... other required fields\n  };\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files CREATED:**\n- packages/cli/src/commands/codify.ts (~150 lines) - new codify command\n\n**Files MODIFIED (write):**\n- packages/cli/src/index.ts (lines 1-10, 19-25) - import and register command\n- packages/cli/package.json - add \\`@browserflow/generator\\` dependency\n\n**Files READ (reference only):**\n- packages/generator/src/playwright-ts.ts - generateTest API\n- packages/core/src/lockfile.ts - ExplorationLockfile type\n- packages/exploration/src/adapters/types.ts - ExplorationOutput type\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-v8m (deprecate bash CLI) - different files\n- bf-2ts (screenshot evidence) - different package\n- bf-8h2 (schema sync) - different package\n- bf-wjz (pixelmatch) - different package\n\n**Cannot Run In Parallel With:**\n- bf-x9t (explore command) - both modify packages/cli/src/index.ts (MUST RUN AFTER)\n- bf-kqu (review server) - both modify packages/cli/src/index.ts (MUST RUN AFTER)\n\n**Blocking Reason:** Should run after bf-wvu (path fix) so generated tests go to correct location\n\n## Estimated Scope\n- **Size:** Medium (120-150 lines)\n- **Risk:** Medium (new integration point, type conversion needed)\n\n## Acceptance Criteria\n- [ ] \\`@browserflow/generator\\` added to CLI package.json dependencies\n- [ ] \\`bf codify --help\\` shows codify command\n- [ ] \\`bf codify --spec checkout\\` generates test file to e2e/tests/checkout.spec.ts\n- [ ] --exploration flag uses specific exploration\n- [ ] --dry-run prints without writing\n- [ ] Review metadata included when available\n- [ ] Missing review shows warning but still generates\n- [ ] Output path respects --output flag\n- [ ] \\`bun run test\\` passes in packages/cli\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Create mock exploration.json and review.json fixtures\n- Test option parsing: --spec, --exploration, --output, --dry-run\n- Test error handling for missing exploration\n- Test findLatestExploration returns correct result\n- Test convertToLockfile produces valid lockfile\n- Run: \\`cd packages/cli \u0026\u0026 bun test\\`","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-19T15:25:06.608975153-05:00","created_by":"ubuntu","updated_at":"2026-01-19T19:22:30.274803511-05:00","closed_at":"2026-01-19T19:22:30.274803511-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-ari","depends_on_id":"bf-wvu","type":"blocks","created_at":"2026-01-19T15:25:19.682624324-05:00","created_by":"ubuntu"},{"issue_id":"bf-ari","depends_on_id":"bf-kqu","type":"blocks","created_at":"2026-01-19T15:25:21.029811913-05:00","created_by":"ubuntu"}]}
{"id":"bf-b3g","title":"Epic G: Baseline Management","description":"# Epic G: Baseline Management\n\n## Strategic Context\n\nBaselines are the \"golden\" screenshots that visual regression tests compare against. Managing them properly is critical - **baselines should never update implicitly**.\n\n## Why This Matters\n\n**Explicit baseline acceptance** prevents:\n- Accidental regression acceptance\n- Confusion about what changed\n- Lost context on why images differ\n\nThe workflow must be:\n1. Test fails with visual diff\n2. Developer reviews diff (intentional change or bug?)\n3. If intentional: explicit \\`bf baseline accept\\`\n4. If bug: fix code, re-run\n\n## Deliverables\n\n1. **bf baseline commands**:\n   - \\`status\\` - Show baseline state for spec\n   - \\`diff\\` - Open diff gallery in Review UI\n   - \\`accept\\` - Accept new baselines (explicit)\n   - \\`update\\` - Convenience alias for accept from latest\n2. **Baseline diff gallery** in Review UI:\n   - Side-by-side baseline/actual/diff\n   - Accept/reject per screenshot\n   - Batch accept option\n3. **Acceptance metadata**:\n   - Who accepted\n   - When\n   - From which run\n   - Previous hash\n4. **Per-priority fail policy**:\n   - Critical/high: fail CI on diff\n   - Normal/low: warn only\n\n## Acceptance Criteria\n\n- [ ] Baselines never update without explicit command\n- [ ] \\`bf baseline diff\\` shows visual comparison\n- [ ] Acceptance includes reviewer and timestamp\n- [ ] Per-priority policy controls work\n- [ ] Metadata stored for audit trail\n- [ ] Works with multiple screenshots per spec\n\n## Dependencies\n\n- **Depends on Epic D** - Review UI for diff gallery\n- **Depends on Epic F** - Runner produces diffs\n\n## Technical Decisions\n\n**Baseline storage:**\n\\`\\`\\`\nbaselines/\n└── checkout-cart/\n    ├── cart-with-item.png\n    └── checkout-confirmation.png\n\\`\\`\\`\n\n**Metadata storage** (.browserflow/baseline-meta.json):\n\\`\\`\\`json\n{\n  \"baselines/checkout-cart/cart-with-item.png\": {\n    \"accepted_at\": \"2026-01-15T03:25:00Z\",\n    \"accepted_by\": \"alex\",\n    \"run_id\": \"run-xxx\",\n    \"previous_hash\": \"sha256:abc...\",\n    \"current_hash\": \"sha256:def...\",\n    \"reason\": \"Updated cart design\"\n  }\n}\n\\`\\`\\`\n\n**Priority-based policies** (from config):\n\\`\\`\\`yaml\nvisual:\n  fail_on_diff_by_priority:\n    critical: true   # Fail CI\n    high: true       # Fail CI\n    normal: false    # Warn only\n    low: false       # Warn only\n\\`\\`\\`\n\n## User Flow\n\n\\`\\`\\`\nTest fails with screenshot diff\n    ↓\nbf baseline diff --spec checkout-cart\n    ↓\nReview UI opens with baseline/actual/diff gallery\n    ↓\nUser reviews: \"This is intentional, we updated the cart design\"\n    ↓\nbf baseline accept --spec checkout-cart\n    ↓\nBaseline updated, metadata recorded\n    ↓\nRe-run passes\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 13: Baseline Management\n- Section 15: Configuration (visual settings)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:35:57.11800074-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.734612739-05:00","closed_at":"2026-01-16T17:18:41.734612739-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-b3g","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.524645102-05:00","created_by":"ubuntu"},{"issue_id":"bf-b3g","depends_on_id":"bf-xx5","type":"blocks","created_at":"2026-01-15T17:47:00.610530233-05:00","created_by":"ubuntu"}]}
{"id":"bf-b9b","title":"Add toast notification system to Review UI","notes":"## Context \u0026 Goal\n\n**Problem:** Review UI uses alert() for notifications. This screams \"prototype\".\n\n**Why it matters:** Premium UX requires proper toast/notification system.\n\n**Project goal served:** Stripe-level polish.\n\n## Current State vs Target State\n\n**Current:**\n- `alert('Review submitted!')` \n- No toast library installed\n\n**Target:**\n1. Install react-hot-toast or similar\n2. Replace all alert() calls with toast\n3. Add toast container to App root\n\n```typescript\n// packages/review-ui/src/App.tsx\nimport { Toaster, toast } from 'react-hot-toast';\n\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003cToaster position=\"bottom-right\" /\u003e\n      \u003cRoutes\u003e...\u003c/Routes\u003e\n    \u003c/\u003e\n  );\n}\n\n// Usage:\ntoast.success('Saved to .browserflow/runs/.../review.json');\ntoast.error('Save failed. Retry?', {\n  action: { label: 'Retry', onClick: retry }\n});\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/package.json - add toast dependency\n- packages/review-ui/src/App.tsx - add Toaster, replace alerts\n- packages/review-ui/src/components/*.tsx - replace any alert() calls\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1/2 beads (different concern)\n- bead-fix-testid-args (different files)\n- bead-fix-diff-hotkey (different concern)\n\n**Cannot Run In Parallel With:**\n- bead-server-side-save (will use toasts, should wait for this)\n\n**Blocking Reason:** Toast infrastructure needed by other UI improvements\n\n## Estimated Scope\n- **Size:** Small (30-50 lines + dependency)\n- **Risk:** Low (additive UI improvement)\n\n## Acceptance Criteria\n- [ ] Toast library installed\n- [ ] Toaster component in App root\n- [ ] No alert() calls remain\n- [ ] Success/error/info toast variants work\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Visual test: trigger toast, verify appears\n- Check no alert() calls in codebase\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:22:23.713433141-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:43:50.56411882-05:00","closed_at":"2026-01-19T17:43:50.56411882-05:00","close_reason":"Closed"}
{"id":"bf-bcv","title":"Epic H: Review UI v2 (Polish)","description":"# Epic H: Review UI v2 (Polish Features)\n\n## Strategic Context\n\nThis epic adds **premium features** to the Review UI that differentiate BrowserFlow from basic test tools. The mask editor and assertion builder turn review from \"just approval\" into \"active test refinement.\"\n\n## Why This Matters\n\n**\"Stripe-level review experience\"** means:\n- Users don't just approve/reject\n- They can refine tests without editing YAML\n- Dynamic content is handled elegantly (masks)\n- Missing assertions are easily added\n\nThese features reduce friction between \"test works\" and \"test is robust.\"\n\n## Deliverables\n\n1. **Mask editor** (canvas-based):\n   - Draw rectangle masks\n   - Click-to-mask from locator\n   - Resize/move existing masks\n   - Delete masks\n   - Reason field per mask\n2. **Assertion builder**:\n   - Add assertions without YAML editing\n   - Types: visible, hidden, text_contains, url_contains, etc.\n   - Attach to step or expected_outcomes\n3. **Evidence drawer**:\n   - Console errors (expandable)\n   - Network failures (expandable)\n   - Timing breakdown\n4. **Repair panel** (for Epic I):\n   - Show failure context\n   - Display fix suggestions\n   - Apply/reject buttons\n5. **UI polish**:\n   - Loading states\n   - Error boundaries\n   - Smooth animations\n   - Responsive design\n\n## Acceptance Criteria\n\n- [ ] Masks can be drawn, moved, resized, deleted\n- [ ] Click-to-mask works from element locator\n- [ ] Assertions can be added without editing YAML\n- [ ] Evidence drawer shows console/network info\n- [ ] Repair panel displays fix suggestions\n- [ ] No jank during interactions\n- [ ] Keyboard shortcuts for mask/assertion (m, e)\n\n## Dependencies\n\n- **Depends on Epic D** - Base Review UI\n- **Depends on Epic G** - Baseline diff gallery integration\n\n## Technical Decisions\n\n**Mask editor implementation:**\n- Use HTML5 Canvas for drawing\n- Store masks as array of { x, y, width, height, reason }\n- Persist to lockfile.json\n- Pass to Playwright's \\`mask\\` option\n\n**Assertion builder:**\n\\`\\`\\`typescript\ninterface Assertion {\n  id: string;\n  type: 'visible' | 'hidden' | 'text_contains' | 'url_contains' | ...;\n  target?: LocatorObject;\n  expected?: string;\n  step_id?: string;  // If attached to specific step\n}\n\\`\\`\\`\n\n**Evidence drawer:**\n- Collapsed by default (not overwhelming)\n- Shows counts: \"3 console errors, 1 network failure\"\n- Click to expand and see details\n\n## Premium UX Details\n\n**Mask editor interactions:**\n1. Click \"Add Mask\" button (or press 'm')\n2. Draw rectangle on screenshot\n3. Fill in reason: \"Dynamic timestamp\"\n4. Mask appears with translucent overlay\n5. Can resize via corner handles\n6. Can delete via 'x' button or Delete key\n\n**Assertion builder flow:**\n1. Click \"Add Assertion\" (or press 'e')\n2. Select type from dropdown\n3. If needs target: click element or enter locator\n4. If needs value: enter expected text\n5. Assertion added to step or global outcomes\n\n## Related Spec Sections\n\n- Section 9: Review Phase (9.5 Mask Editor, 9.6 Assertion Builder)\n- Section 10.3: Visual Regression Generation (masks)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:36:17.528898171-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.736988039-05:00","closed_at":"2026-01-16T17:18:41.736988039-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-bcv","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.70840866-05:00","created_by":"ubuntu"},{"issue_id":"bf-bcv","depends_on_id":"bf-b3g","type":"blocks","created_at":"2026-01-15T17:47:00.803013512-05:00","created_by":"ubuntu"}]}
{"id":"bf-bvs","title":"E.1: Create @browserflow/generator package","description":"# Task: Create Generator Package\n\n## Context\nThe generator package converts lockfiles into deterministic Playwright Test code. No AI involved - pure code generation.\n\n## What to Build\n\\`\\`\\`\npackages/generator/\n├── src/\n│   ├── index.ts              # Public exports\n│   ├── playwright-ts.ts      # TypeScript test generator\n│   ├── locator-emit.ts       # LocatorObject → Playwright code\n│   ├── visual-checks.ts      # Screenshot assertion generation\n│   └── config-emit.ts        # playwright.config.ts generation\n├── templates/\n│   ├── test.ts.hbs           # Test file template\n│   └── config.ts.hbs         # Config template\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/generator\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"handlebars\": \"^4.7.8\"\n  }\n}\n\\`\\`\\`\n\n## Main Export\n\\`\\`\\`typescript\nexport { PlaywrightGenerator } from './playwright-ts';\nexport { generateLocatorCode } from './locator-emit';\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles\n- [ ] Can generate test file from lockfile\n- [ ] Templates render correctly\n- [ ] Exports accessible from CLI","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:04.524259127-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:36:51.171886241-05:00","closed_at":"2026-01-15T21:36:51.171886241-05:00","close_reason":"Implemented @browserflow/generator package with PlaywrightGenerator, locator-emit, visual-checks, config-emit, and Handlebars templates"}
{"id":"bf-bwv","title":"Epic I: Repair Mode","description":"# Epic I: Repair Mode\n\n## Strategic Context\n\nRepair mode is what makes BrowserFlow **maintainable at scale**. E2E tests are notorious for breaking with UI changes. Instead of \"fix or delete\", BrowserFlow offers \"repair and move on.\"\n\n## Why This Matters\n\n**\"First-class maintainability\"** is a product goal.\n\nWhen tests break, developers typically:\n1. Spend hours debugging why\n2. Manually update selectors\n3. Re-run, discover more breaks\n4. Eventually give up and delete tests\n\nRepair mode changes this to:\n1. \\`bf repair --spec X\\`\n2. See failure context + suggested fixes\n3. Approve fix\n4. Done\n\nThis keeps test suites alive and valuable.\n\n## Deliverables\n\n1. **bf repair command**:\n   - \\`--spec X\\` - Repair specific spec (uses latest failure)\n   - \\`--from-run \u003cpath\u003e\\` - Repair from specific failure bundle\n   - \\`--ai\\` - Enable AI-assisted repair proposals\n   - \\`--apply\\` - Auto-apply suggested fixes\n   - \\`--headed\\` - Show browser during repair\n2. **Deterministic fix analysis**:\n   - Try fallback locators\n   - Increase timeout by 2x\n   - Suggest mask for changed region\n   - Show actual vs expected for assertions\n3. **AI repair proposals** (optional):\n   - Re-run failing step in headed mode\n   - AI inspects current DOM\n   - Proposes new locator/assertion/mask\n4. **Repair UI panel** in Review app:\n   - Show failure context\n   - Display fix options\n   - Apply/skip buttons\n5. **Patch application**:\n   - Update lockfile\n   - Regenerate test\n   - Run verification\n\n## Acceptance Criteria\n\n- [ ] \\`bf repair\\` loads failure bundle correctly\n- [ ] Deterministic fixes work (fallbacks, timeout)\n- [ ] AI proposals work when --ai flag provided\n- [ ] Human approval required before applying\n- [ ] Repaired tests pass verification run\n- [ ] repair_patch.json documents what changed\n\n## Dependencies\n\n- **Depends on Epic F** - Failure bundles\n- **Depends on Epic H** - Repair panel in Review UI\n- **Depends on Epic E** - Regenerate tests after repair\n\n## Technical Decisions\n\n**Repair flow:**\n\\`\\`\\`\n1. Load failure bundle + spec + lockfile\n2. Analyze failure type:\n   - locator_not_found → try fallbacks\n   - timeout → increase timeout\n   - screenshot_diff → suggest baseline update or mask\n   - assertion_failed → show actual vs expected\n3. Generate deterministic suggestions\n4. (If --ai) Run AI for additional proposals\n5. Open repair UI for human approval\n6. Apply approved changes to lockfile\n7. Regenerate test\n8. Run verification\n\\`\\`\\`\n\n**Deterministic vs AI fixes:**\n- Deterministic: always try first, no tokens\n- AI: only when --ai flag, costs tokens\n\n**Patch format:**\n\\`\\`\\`json\n{\n  \"run_id\": \"repair-xxx\",\n  \"original_run_id\": \"run-yyy\",\n  \"changes\": [\n    {\n      \"type\": \"locator_update\",\n      \"step_id\": \"add_product\",\n      \"before\": { \"preferred\": { \"type\": \"testid\", \"value\": \"old-id\" } },\n      \"after\": { \"preferred\": { \"type\": \"testid\", \"value\": \"new-id\" } },\n      \"reason\": \"Element testid changed\"\n    }\n  ]\n}\n\\`\\`\\`\n\n## User Journey\n\n\\`\\`\\`\nCI fails: checkout-cart\n    ↓\nDeveloper downloads failure bundle (or uses local)\n    ↓\nbf repair --spec checkout-cart\n    ↓\nCLI: \"Analyzing failure...\"\nCLI: \"Found: locator_not_found at step add_product\"\nCLI: \"Suggestion: Use fallback role locator (confidence: 0.9)\"\nCLI: \"Opening repair UI...\"\n    ↓\nRepair UI shows:\n  - Original locator that failed\n  - Suggested replacement\n  - Screenshot context\n    ↓\nDeveloper clicks \"Apply Fix\"\n    ↓\nCLI: \"Updating lockfile...\"\nCLI: \"Regenerating test...\"\nCLI: \"Running verification...\"\nCLI: \"✓ Test passes!\"\n    ↓\ngit add \u0026\u0026 git commit -m \"fix: update add_product locator\"\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 12: Repair Mode\n- Section 11.5: Failure Bundle Schema","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:36:41.549869761-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.739553842-05:00","closed_at":"2026-01-16T17:18:41.739553842-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-bwv","depends_on_id":"bf-xx5","type":"blocks","created_at":"2026-01-15T17:47:00.901983045-05:00","created_by":"ubuntu"},{"issue_id":"bf-bwv","depends_on_id":"bf-bcv","type":"blocks","created_at":"2026-01-15T17:47:00.988222239-05:00","created_by":"ubuntu"},{"issue_id":"bf-bwv","depends_on_id":"bf-u2n","type":"blocks","created_at":"2026-01-15T17:47:01.076049025-05:00","created_by":"ubuntu"}]}
{"id":"bf-c4o","title":"C.3: Implement step executor","description":"# Task: Implement Step Executor\n\n## Context\nThe step executor maps spec action types to actual browser operations using agent-browser.\n\n## What to Build\n\\`\\`\\`typescript\nexport class StepExecutor {\n  constructor(private browser: BrowserManager, private adapter: AIAdapter) {}\n  \n  async execute(step: SpecStep): Promise\u003cStepResult\u003e {\n    switch (step.action) {\n      case 'navigate':\n        return this.executeNavigate(step);\n      case 'click':\n        return this.executeClick(step);\n      case 'fill':\n        return this.executeFill(step);\n      case 'type':\n        return this.executeType(step);\n      case 'wait':\n        return this.executeWait(step);\n      case 'expect':\n        return this.executeExpect(step);\n      case 'screenshot':\n        return this.executeScreenshot(step);\n      case 'select':\n        return this.executeSelect(step);\n      case 'check':\n        return this.executeCheck(step);\n      case 'press':\n        return this.executePress(step);\n      case 'scroll':\n        return this.executeScroll(step);\n      // ... etc\n    }\n  }\n  \n  private async executeClick(step: ClickStep): Promise\u003cStepResult\u003e {\n    // 1. Resolve target to element\n    const { ref, locator } = await this.resolveTarget(step.target);\n    \n    // 2. Take before screenshot if configured\n    let beforeScreenshot: string | undefined;\n    if (step.screenshot?.before) {\n      beforeScreenshot = await this.captureScreenshot(\\`\\${step.id}-before\\`);\n    }\n    \n    // 3. Perform click\n    await locator.click({\n      button: step.button || 'left',\n      clickCount: step.click_count || 1\n    });\n    \n    // 4. Take after screenshot\n    let afterScreenshot: string | undefined;\n    if (step.screenshot?.after) {\n      afterScreenshot = await this.captureScreenshot(\\`\\${step.id}-after\\`);\n    }\n    \n    // 5. Generate locator candidates\n    const candidates = await this.generateCandidates(locator);\n    \n    return {\n      status: 'completed',\n      ref_used: ref,\n      screenshots: { before: beforeScreenshot, after: afterScreenshot },\n      candidates\n    };\n  }\n  \n  private async resolveTarget(target: Target): Promise\u003cResolvedTarget\u003e {\n    if (target.query) {\n      // Use AI to find element from natural language\n      return this.adapter.findElement(target.query, await this.browser.getSnapshot());\n    }\n    // Use explicit locator strategy\n    return this.resolveExplicitTarget(target);\n  }\n}\n\\`\\`\\`\n\n## Action Types to Implement\n- **Navigation:** navigate, back, forward, reload\n- **Interaction:** click, fill, type, select, check, press, upload\n- **Waiting:** wait (element, text, url, load_state, function)\n- **Assertions:** expect (visible, hidden, text_contains, etc.)\n- **Capture:** screenshot, scroll, scroll_into_view\n\n## Acceptance Criteria\n- [ ] All action types from spec section 6.4 implemented\n- [ ] Screenshots captured when configured\n- [ ] Target resolution works for query and explicit strategies\n- [ ] Error handling returns failed status with message\n- [ ] Locator candidates generated for target-based actions","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:55.084471671-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:53.026436312-05:00","closed_at":"2026-01-15T22:27:53.026436312-05:00","close_reason":"Implemented step executor with all action types. 44 tests pass.","dependencies":[{"issue_id":"bf-c4o","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.425755433-05:00","created_by":"ubuntu"},{"issue_id":"bf-c4o","depends_on_id":"bf-7do","type":"blocks","created_at":"2026-01-15T17:47:15.721589777-05:00","created_by":"ubuntu"}]}
{"id":"bf-cds","title":"A.2: Create @browserflow/core package structure","description":"# Task: Create Core Package Structure\n\n## Context\nThe core package holds shared types, schemas, and utilities used by all other packages. It's the dependency foundation - every other package imports from @browserflow/core.\n\n## What to Build\n\\`\\`\\`\npackages/core/\n├── src/\n│   ├── index.ts          # Public exports\n│   ├── spec-schema.ts    # Zod schemas for spec v2\n│   ├── locator-object.ts # LocatorObject types + resolution\n│   ├── lockfile.ts       # Lockfile types\n│   ├── duration.ts       # Duration string parser\n│   ├── run-store.ts      # Immutable run directory management\n│   └── config.ts         # Configuration types\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/core\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": \"./dist/index.js\",\n    \"./schemas\": \"./dist/spec-schema.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"vitest\"\n  },\n  \"dependencies\": {\n    \"zod\": \"^3.22.4\"\n  }\n}\n\\`\\`\\`\n\n## tsconfig.json\n\\`\\`\\`json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles with \\`bun run build\\`\n- [ ] Exports are accessible: \\`import { specSchema } from '@browserflow/core'\\`\n- [ ] Types are properly generated in dist/\n- [ ] Can be used as dependency in other workspace packages","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:18.906965459-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:57:46.716458245-05:00","closed_at":"2026-01-15T21:57:46.716458245-05:00","close_reason":"Created core package structure with modular file layout, zod schemas, and proper exports","dependencies":[{"issue_id":"bf-cds","depends_on_id":"bf-0fe","type":"blocks","created_at":"2026-01-15T17:47:14.25629364-05:00","created_by":"ubuntu"}]}
{"id":"bf-cim","title":"H.1: Implement mask editor component","description":"# Task: Implement Mask Editor Component\n\n## Context\nThe mask editor lets reviewers draw rectangles over dynamic regions (timestamps, ads, user avatars) that should be excluded from visual comparison.\n\n## What to Build\n\\`\\`\\`typescript\ninterface MaskEditorProps {\n  imageSrc: string;\n  masks: Mask[];\n  onMasksChange: (masks: Mask[]) =\u003e void;\n}\n\ninterface Mask {\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  reason: string;\n}\n\nexport function MaskEditor({ imageSrc, masks, onMasksChange }: MaskEditorProps) {\n  const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);\n  const [drawing, setDrawing] = useState(false);\n  const [currentRect, setCurrentRect] = useState\u003cRect | null\u003e(null);\n  const [selectedMask, setSelectedMask] = useState\u003cstring | null\u003e(null);\n  \n  // Handle mouse events for drawing\n  const handleMouseDown = (e: React.MouseEvent) =\u003e {\n    const rect = canvasRef.current.getBoundingClientRect();\n    setDrawing(true);\n    setCurrentRect({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n      width: 0,\n      height: 0\n    });\n  };\n  \n  const handleMouseMove = (e: React.MouseEvent) =\u003e {\n    if (!drawing || !currentRect) return;\n    const rect = canvasRef.current.getBoundingClientRect();\n    setCurrentRect({\n      ...currentRect,\n      width: e.clientX - rect.left - currentRect.x,\n      height: e.clientY - rect.top - currentRect.y\n    });\n  };\n  \n  const handleMouseUp = () =\u003e {\n    if (currentRect \u0026\u0026 currentRect.width \u003e 10 \u0026\u0026 currentRect.height \u003e 10) {\n      // Prompt for reason\n      const reason = prompt('Why is this region masked?');\n      if (reason) {\n        onMasksChange([...masks, {\n          id: crypto.randomUUID(),\n          ...normalizeRect(currentRect),\n          reason\n        }]);\n      }\n    }\n    setDrawing(false);\n    setCurrentRect(null);\n  };\n  \n  // Render masks with resize handles\n  return (\n    \u003cdiv className=\"relative\"\u003e\n      \u003cimg src={imageSrc} className=\"pointer-events-none\" /\u003e\n      \u003ccanvas\n        ref={canvasRef}\n        className=\"absolute top-0 left-0 w-full h-full\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n      /\u003e\n      \n      {/* Render existing masks */}\n      {masks.map(mask =\u003e (\n        \u003cMaskOverlay\n          key={mask.id}\n          mask={mask}\n          isSelected={selectedMask === mask.id}\n          onSelect={() =\u003e setSelectedMask(mask.id)}\n          onResize={(newRect) =\u003e updateMask(mask.id, newRect)}\n          onDelete={() =\u003e deleteMask(mask.id)}\n        /\u003e\n      ))}\n      \n      {/* Current drawing rect */}\n      {currentRect \u0026\u0026 (\n        \u003cdiv\n          className=\"absolute border-2 border-dashed border-blue-500 bg-blue-500/20\"\n          style={{\n            left: currentRect.x,\n            top: currentRect.y,\n            width: currentRect.width,\n            height: currentRect.height\n          }}\n        /\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Features\n- Draw rectangles by click+drag\n- Resize via corner handles\n- Delete via Delete key or button\n- Reason field for each mask\n- Visual feedback (translucent overlay)\n\n## Acceptance Criteria\n- [ ] Can draw new mask rectangles\n- [ ] Can resize existing masks\n- [ ] Can delete masks\n- [ ] Reason prompt on creation\n- [ ] Masks saved to lockfile\n- [ ] 'm' shortcut enters mask mode","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:45:49.698982228-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:59:38.799032649-05:00","closed_at":"2026-01-15T22:59:38.799032649-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-cim","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.867677689-05:00","created_by":"ubuntu"}]}
{"id":"bf-cj8","title":"Add reload -\u003e refresh action alias","notes":"## Context \u0026 Goal\n\n**Problem:** Docs use `reload`, schema uses `refresh`. Need alias support for backward compat.\n\n**Why it matters:** Specs written per docs should work.\n\n**Project goal served:** Backward-compatible spec loading.\n\n## Current State vs Target State\n\n**After bead-add-schema-actions, schema will allow both `reload` and `refresh`.**\n\n**Add normalization in step executor:**\n\n**Current (packages/exploration/src/step-executor.ts:175-180):**\n```typescript\ncase 'refresh':\n  return this.executeRefresh();\n```\n\n**Target:**\n```typescript\ncase 'refresh':\ncase 'reload':  // Alias for refresh\n  return this.executeRefresh();\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/exploration/src/step-executor.ts - add reload case alias\n\n**Files READ (reference only):**\n- packages/core/schemas/spec-v2.schema.json - verify reload is in enum\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Most beads in same phase\n\n**Cannot Run In Parallel With:**\n- bead-navigate-url-field (both modify step-executor.ts)\n\n**Blocking Reason:** Depends on schema having reload in enum\n\n## Estimated Scope\n- **Size:** Tiny (2 lines)\n- **Risk:** Low (additive alias)\n\n## Acceptance Criteria\n- [ ] `action: reload` executes as refresh\n- [ ] `action: refresh` still works\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Add test: step with action=reload executes refresh\n- Run: `cd packages/exploration \u0026\u0026 bun test`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:21:46.593877405-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:45:04.431503005-05:00","closed_at":"2026-01-19T17:45:04.431503005-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-cj8","depends_on_id":"bf-3a1","type":"blocks","created_at":"2026-01-16T18:21:46.630374935-05:00","created_by":"ubuntu"}]}
{"id":"bf-cv6","title":"A.8: Export JSON Schemas for IDE validation","description":"# Task: Export JSON Schemas for IDE Validation\n\n## Context\nJSON Schemas enable IDE features like autocomplete, inline validation, and documentation for YAML specs and config files. This dramatically improves DX.\n\n## What to Build\n\\`\\`\\`\nschemas/\n├── spec-v2.schema.json       # Spec YAML validation\n├── browserflow.schema.json   # Config file validation\n├── lockfile.schema.json      # Lockfile validation\n└── exploration.schema.json   # Exploration output validation\n\\`\\`\\`\n\n## Generation from Zod\n\\`\\`\\`typescript\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { specSchema, configSchema, lockfileSchema } from '@browserflow/core';\nimport fs from 'fs/promises';\n\nasync function generateSchemas() {\n  const schemas = {\n    'spec-v2': zodToJsonSchema(specSchema, 'spec-v2'),\n    'browserflow': zodToJsonSchema(configSchema, 'browserflow'),\n    'lockfile': zodToJsonSchema(lockfileSchema, 'lockfile'),\n  };\n  \n  for (const [name, schema] of Object.entries(schemas)) {\n    await fs.writeFile(\n      \\`schemas/\\${name}.schema.json\\`,\n      JSON.stringify(schema, null, 2)\n    );\n  }\n}\n\\`\\`\\`\n\n## VS Code Integration\nUsers add to YAML files:\n\\`\\`\\`yaml\n# yaml-language-server: \\$schema=./node_modules/browserflow/schemas/spec-v2.schema.json\nversion: 2\nname: my-test\n\\`\\`\\`\n\nOr in .vscode/settings.json:\n\\`\\`\\`json\n{\n  \"yaml.schemas\": {\n    \"./node_modules/browserflow/schemas/spec-v2.schema.json\": \"specs/*.yaml\",\n    \"./node_modules/browserflow/schemas/browserflow.schema.json\": \"browserflow.yaml\"\n  }\n}\n\\`\\`\\`\n\n## npm Package Inclusion\n\\`\\`\\`json\n{\n  \"files\": [\n    \"dist\",\n    \"schemas\"\n  ]\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] JSON Schemas generated from Zod schemas\n- [ ] Schemas validate correctly in VS Code YAML extension\n- [ ] Schemas included in npm package distribution\n- [ ] Documentation shows how to enable in VS Code/other IDEs\n- [ ] Build script regenerates schemas on change","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:39:51.999251205-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:01:12.636495129-05:00","closed_at":"2026-01-15T23:01:12.636495129-05:00","close_reason":"Implemented JSON schema generation from Zod schemas with VS Code integration docs","dependencies":[{"issue_id":"bf-cv6","depends_on_id":"bf-dgs","type":"blocks","created_at":"2026-01-15T17:47:14.796437963-05:00","created_by":"ubuntu"}]}
{"id":"bf-dcs","title":"F.2: Implement failure bundle generation","description":"# Task: Implement Failure Bundle Generation\n\n## Context\nWhen tests fail, BrowserFlow creates failure bundles containing everything needed for debugging and repair. These bundles are the input to \\`bf repair\\`.\n\n## What to Build\n\\`\\`\\`typescript\ninterface FailureBundle {\n  run_id: string;\n  spec_name: string;\n  failed_at: string;  // ISO8601\n  \n  failure: {\n    step_id: string;\n    action: string;\n    error_message: string;\n    error_type: 'locator_not_found' | 'timeout' | 'assertion_failed' | 'screenshot_diff' | 'unknown';\n  };\n  \n  context: {\n    url: string;\n    viewport: { width: number; height: number };\n    browser: string;\n  };\n  \n  artifacts: {\n    trace?: string;      // Path to trace.zip\n    video?: string;      // Path to video\n    screenshot?: string; // Path to failure screenshot\n    diff?: {\n      baseline: string;\n      actual: string;\n      diff: string;\n    };\n    console_log?: string;\n    network_log?: string;\n  };\n  \n  suggestions?: RepairSuggestion[];\n}\n\nasync function generateFailureBundle(\n  runDir: string,\n  failure: TestFailure,\n  playwrightArtifacts: string\n): Promise\u003cstring\u003e {\n  const bundleDir = path.join(runDir, 'artifacts');\n  \n  // 1. Copy trace file\n  const tracePath = await findTrace(playwrightArtifacts);\n  if (tracePath) {\n    await copyFile(tracePath, path.join(bundleDir, 'trace.zip'));\n  }\n  \n  // 2. Copy failure screenshot\n  const screenshotPath = await findFailureScreenshot(playwrightArtifacts);\n  if (screenshotPath) {\n    await copyFile(screenshotPath, path.join(bundleDir, 'screenshots', 'failure.png'));\n  }\n  \n  // 3. Copy diff images if screenshot failure\n  if (failure.type === 'screenshot_diff') {\n    await copyDiffImages(playwrightArtifacts, bundleDir);\n  }\n  \n  // 4. Extract console/network logs from trace\n  const logs = await extractLogsFromTrace(path.join(bundleDir, 'trace.zip'));\n  await writeJson(path.join(bundleDir, 'logs', 'console.json'), logs.console);\n  await writeJson(path.join(bundleDir, 'logs', 'network.json'), logs.network);\n  \n  // 5. Generate repair suggestions\n  const suggestions = generateRepairSuggestions(failure);\n  \n  // 6. Write failure.json\n  const bundle: FailureBundle = {\n    run_id: path.basename(runDir),\n    spec_name: failure.specName,\n    failed_at: new Date().toISOString(),\n    failure: {\n      step_id: failure.stepId,\n      action: failure.action,\n      error_message: failure.message,\n      error_type: classifyError(failure.message)\n    },\n    context: failure.context,\n    artifacts: { ... },\n    suggestions\n  };\n  \n  const bundlePath = path.join(runDir, 'failure.json');\n  await writeJson(bundlePath, bundle);\n  \n  return bundlePath;\n}\n\\`\\`\\`\n\n## Error Classification\n| Pattern | Error Type |\n|---------|------------|\n| \"locator resolved to N elements\" | locator_not_found |\n| \"Timeout\" | timeout |\n| \"expect\" failures | assertion_failed |\n| \"Screenshot comparison\" | screenshot_diff |\n| Other | unknown |\n\n## Acceptance Criteria\n- [ ] Failure bundle contains trace, screenshots, logs\n- [ ] failure.json is machine-readable\n- [ ] Error type classified correctly\n- [ ] Diff images included for visual failures\n- [ ] Repair suggestions generated","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:45:14.88553056-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:23:29.690977512-05:00","closed_at":"2026-01-15T22:23:29.690977512-05:00","close_reason":"Implemented failure bundle generation with: error classification, artifact collection (trace, screenshots, diff images), log extraction placeholders, repair suggestions, and comprehensive tests","dependencies":[{"issue_id":"bf-dcs","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:16.577203829-05:00","created_by":"ubuntu"}]}
{"id":"bf-dgs","title":"A.3: Implement spec v2 Zod schema","description":"# Task: Implement Spec v2 Zod Schema\n\n## Context\nThe spec schema validates YAML test specifications at runtime. It must be comprehensive enough to catch errors early with actionable messages, but flexible enough to support all documented spec features.\n\n## What to Build\nZod schemas covering:\n- Top-level spec fields (version, name, description, steps, etc.)\n- Target object (query, testid, role, label, css, within, nth)\n- All action types from spec section 6.4\n- Duration string validation\n- Preconditions (page, auth, viewport, mocks)\n- Expected outcomes\n\n## Key Schema Patterns\n\\`\\`\\`typescript\n// Duration validation\nconst durationSchema = z.string().regex(\n  /^(\\d+(ms|s|m|h))+$/,\n  'Must be duration string like \"3s\", \"2m\", \"500ms\"'\n);\n\n// Target - at least one strategy required\nconst targetSchema = z.object({\n  query: z.string().optional(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  name: z.string().optional(),\n  label: z.string().optional(),\n  placeholder: z.string().optional(),\n  text: z.string().optional(),\n  css: z.string().optional(),\n  within: z.lazy(() =\u003e targetSchema).optional(),\n  nth: z.number().int().optional(),\n}).refine(\n  data =\u003e data.query || data.testid || data.role || data.label || data.css || data.text,\n  'Target must have at least one locator strategy'\n);\n\n// Step - id is REQUIRED\nconst stepSchema = z.object({\n  id: z.string().min(1, 'Step id is required'),\n  action: z.enum(['click', 'fill', 'navigate', 'wait', 'expect', ...]),\n  target: targetSchema.optional(),\n  // ... action-specific fields via discriminated union\n});\n\n// Top-level spec\nconst specSchema = z.object({\n  version: z.literal(2),\n  name: z.string().regex(/^[a-z0-9-]+$/, 'Name must be kebab-case'),\n  description: z.string().optional(),\n  steps: z.array(stepSchema).min(1, 'At least one step required'),\n  timeout: durationSchema.optional(),\n  priority: z.enum(['critical', 'high', 'normal', 'low']).optional(),\n  tags: z.array(z.string()).optional(),\n  preconditions: preconditionsSchema.optional(),\n  expected_outcomes: z.array(outcomeSchema).optional(),\n}).refine(\n  data =\u003e {\n    const ids = data.steps.map(s =\u003e s.id);\n    return new Set(ids).size === ids.length;\n  },\n  'Step IDs must be unique within spec'\n);\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Valid specs pass validation\n- [ ] Invalid specs fail with clear, actionable error messages\n- [ ] All action types from spec section 6.4 covered\n- [ ] Duration strings validated per Appendix C\n- [ ] Step IDs validated for uniqueness\n- [ ] Discriminated unions handle action-specific fields","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:33.257176982-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.062094224-05:00","closed_at":"2026-01-15T22:27:55.062094224-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-dgs","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.347614529-05:00","created_by":"ubuntu"}]}
{"id":"bf-dhp","title":"Add OS-aware shortcut labels","notes":"## Context \u0026 Goal\n\n**Problem:** Keyboard shortcuts show \"Ctrl+?\" everywhere, not \"Cmd+?\" on macOS.\n\n**Why it matters:** Mac users expect to see Cmd symbol.\n\n**Project goal served:** Premium UX - platform-appropriate UI.\n\n## Current State vs Target State\n\n**Current (KeyboardShortcutsHelp.tsx):**\n```typescript\n\u003cspan\u003eCtrl+S\u003c/span\u003e\n\u003cspan\u003eCtrl+?\u003c/span\u003e\n```\n\n**Target:**\n```typescript\n// packages/review-ui/src/utils/platform.ts\nexport function getModifierKey(): string {\n  return navigator.platform.includes('Mac') ? '⌘' : 'Ctrl';\n}\n\nexport function formatShortcut(key: string): string {\n  const mod = getModifierKey();\n  return key.replace('Ctrl', mod).replace('Alt', navigator.platform.includes('Mac') ? '⌥' : 'Alt');\n}\n\n// Usage:\n\u003cspan\u003e{formatShortcut('Ctrl+S')}\u003c/span\u003e  // Shows \"⌘+S\" on Mac, \"Ctrl+S\" elsewhere\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/components/KeyboardShortcutsHelp.tsx - use formatShortcut\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- packages/review-ui/src/utils/platform.ts - platform detection helpers\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All other beads (isolated utility)\n\n**Cannot Run In Parallel With:**\n- None\n\n**Blocking Reason:** None - polish\n\n## Estimated Scope\n- **Size:** Small (20-30 lines)\n- **Risk:** Low (additive)\n\n## Acceptance Criteria\n- [ ] Mac shows ⌘ instead of Ctrl\n- [ ] Windows/Linux shows Ctrl\n- [ ] All shortcut labels updated\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Mock navigator.platform, verify correct symbols\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-16T18:23:09.278727721-05:00","created_by":"ubuntu","updated_at":"2026-01-16T18:23:09.278727721-05:00"}
{"id":"bf-dyj","title":"C.5: Implement Claude adapter","description":"# Task: Implement Claude Adapter\n\n## Context\nThe Claude adapter implements the AIAdapter interface, using Claude to interpret spec steps and find elements from natural language queries.\n\n## What to Build\n\\`\\`\\`typescript\nimport Anthropic from '@anthropic-ai/sdk';\n\nexport interface AIAdapter {\n  name: string;\n  \n  // Find element from natural language query\n  findElement(\n    query: string,\n    snapshot: EnhancedSnapshot\n  ): Promise\u003c{ ref: string; reasoning: string }\u003e;\n  \n  // (Optional) Propose repair for failure\n  proposeRepair?(params: RepairParams): Promise\u003cRepairProposal\u003e;\n}\n\nexport class ClaudeAdapter implements AIAdapter {\n  name = 'claude';\n  private client: Anthropic;\n  \n  constructor() {\n    this.client = new Anthropic();\n  }\n  \n  async findElement(query: string, snapshot: EnhancedSnapshot): Promise\u003c...\u003e {\n    const response = await this.client.messages.create({\n      model: 'claude-sonnet-4-20250514',\n      max_tokens: 1024,\n      system: ELEMENT_FINDER_SYSTEM_PROMPT,\n      messages: [{\n        role: 'user',\n        content: \\`\n          Find the element matching this description: \"\\${query}\"\n          \n          Current page snapshot:\n          \\${snapshot.tree}\n          \n          Available refs: \\${Object.keys(snapshot.refs).join(', ')}\n          \n          Return the ref (e.g., \"e1\") of the best matching element.\n        \\`\n      }]\n    });\n    \n    // Parse response to extract ref\n    const ref = extractRef(response.content[0].text);\n    return { ref, reasoning: response.content[0].text };\n  }\n}\n\nconst ELEMENT_FINDER_SYSTEM_PROMPT = \\`\nYou are helping find UI elements based on natural language descriptions.\nGiven an accessibility snapshot of a web page, identify the element that best matches the user's description.\n\nRules:\n1. Return ONLY the ref (like \"e1\", \"e2\") of the matching element\n2. If multiple elements could match, pick the most likely based on context\n3. If no element matches, say \"NOT_FOUND\" and explain why\n4. Consider the element's role, name, and position in the hierarchy\n\\`;\n\\`\\`\\`\n\n## Tool Use Pattern (Alternative)\n\\`\\`\\`typescript\n// Can also use tool_use for structured output\nconst tools = [{\n  name: 'select_element',\n  description: 'Select an element by its ref',\n  input_schema: {\n    type: 'object',\n    properties: {\n      ref: { type: 'string', description: 'Element ref like e1, e2' },\n      confidence: { type: 'number', description: '0-1 confidence' },\n      reasoning: { type: 'string' }\n    },\n    required: ['ref', 'confidence', 'reasoning']\n  }\n}];\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Implements AIAdapter interface\n- [ ] Uses Claude API correctly\n- [ ] Handles ambiguous queries gracefully\n- [ ] Returns ref + reasoning\n- [ ] Works with agent-browser snapshot format\n- [ ] Respects rate limits","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:32.166151615-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:37.388487652-05:00","closed_at":"2026-01-15T21:59:37.388487652-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-dyj","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.627977239-05:00","created_by":"ubuntu"}]}
{"id":"bf-el2","title":"Normalize navigate field: to -\u003e url","notes":"## Context \u0026 Goal\n\n**Problem:** Navigate action uses `url` in schema but `to` in docs and implementation. This causes validated specs to fail at runtime.\n\n**Why it matters:** Critical integration footgun - specs that pass validation wont execute.\n\n**Project goal served:** Spec coherence - field names must match across sources.\n\n## Current State vs Target State\n\n**Current (packages/exploration/src/step-executor.ts:234-244):**\n```typescript\nprivate async executeNavigate(step: SpecStep): Promise\u003cStepExecution\u003e {\n  if (\\!step.to) {\n    return {\n      status: 'failed',\n      method: 'navigate',\n      durationMs: 0,\n      error: 'Navigate action requires \"to\" field',\n    };\n  }\n  const url = step.to.startsWith('http') ? step.to : `${this.baseUrl}${step.to}`;\n```\n\n**Target:**\n```typescript\nprivate async executeNavigate(step: SpecStep): Promise\u003cStepExecution\u003e {\n  // Support both url (canonical) and to (legacy)\n  const targetUrl = step.url ?? step.to;\n  if (\\!targetUrl) {\n    return {\n      status: 'failed',\n      method: 'navigate',\n      durationMs: 0,\n      error: 'Navigate action requires \"url\" field',\n    };\n  }\n  const url = targetUrl.startsWith('http') ? targetUrl : `${this.baseUrl}${targetUrl}`;\n```\n\n**Also update explorer.ts:286-290 similarly.**\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/exploration/src/step-executor.ts (lines 234-250) - accept url || to\n- packages/exploration/src/explorer.ts (lines 284-291) - accept url || to\n- packages/exploration/src/adapters/types.ts - add url field to SpecStep\n\n**Files READ (reference only):**\n- packages/core/schemas/spec-v2.schema.json - verify url is the canonical field\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-add-schema-actions (different files)\n- bead-preconditions-format (different files)\n- bead-duration-types (different focus)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying step-executor.ts\n\n**Blocking Reason:** Executor changes needed before integration tests\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Medium (changes execution behavior)\n\n## Acceptance Criteria\n- [ ] Specs with `url:` field work at runtime\n- [ ] Specs with `to:` field still work (backward compat)\n- [ ] Error message references `url` not `to`\n- [ ] `bun run test` passes in packages/exploration\n\n## Testing Requirements\n- Update step-executor.test.ts navigate tests to use `url`\n- Add test case for backward compat with `to`\n- Run: `cd packages/exploration \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:18:47.870725828-05:00","created_by":"ubuntu","updated_at":"2026-01-17T18:11:44.361632738-05:00","closed_at":"2026-01-17T18:11:44.361632738-05:00","close_reason":"Closed"}
{"id":"bf-eq4","title":"B.4: Implement bf lint command","description":"# Task: Implement bf lint Command\n\n## Context\n\\`bf lint\\` validates spec files against the v2 schema. It catches errors early with actionable messages including line numbers.\n\n## What to Build\n\\`\\`\\`typescript\n// bf lint [options] [files...]\n// Options:\n//   --fix    Auto-fix simple issues (formatting)\n// Arguments:\n//   files    Specific files to lint (default: specs/*.yaml)\n\nimport { parse as parseYaml } from 'yaml';\nimport { specSchema } from '@browserflow/core';\n\nasync function lint(files: string[], options: { fix?: boolean }) {\n  const results: LintResult[] = [];\n  \n  for (const file of files) {\n    const content = await readFile(file, 'utf-8');\n    const parsed = parseYaml(content);\n    \n    const validation = specSchema.safeParse(parsed);\n    \n    if (!validation.success) {\n      results.push({\n        file,\n        errors: validation.error.issues.map(issue =\u003e ({\n          path: issue.path.join('.'),\n          message: issue.message,\n          line: getLineNumber(content, issue.path)\n        }))\n      });\n    }\n  }\n  \n  // Print results\n  for (const result of results) {\n    if (result.errors.length === 0) {\n      console.log(\\`✓ \\${result.file}\\`);\n    } else {\n      console.log(\\`✗ \\${result.file}\\`);\n      for (const error of result.errors) {\n        console.log(\\`  Line \\${error.line}: \\${error.message}\\`);\n        console.log(\\`    at \\${error.path}\\`);\n      }\n    }\n  }\n  \n  return results.some(r =\u003e r.errors.length \u003e 0) ? 1 : 0;\n}\n\\`\\`\\`\n\n## Validation Rules\n1. **Schema compliance** - All fields match Zod schema\n2. **Required fields** - version (must be 2), name, steps\n3. **Step IDs** - All steps have id, no duplicates\n4. **Duration strings** - All timeouts are valid (3s, 2m, etc.)\n5. **Target objects** - At least one locator strategy\n6. **Kebab-case names** - Spec name follows convention\n\n## CLI Output\n\\`\\`\\`\n$ bf lint\n\nLinting specs/*.yaml\n\n✓ specs/checkout-cart.yaml\n✗ specs/login-flow.yaml\n  Line 12: Step id is required\n    at steps.2.id\n  Line 18: Invalid duration \"3000\" - use \"3s\" instead\n    at steps.3.timeout\n✓ specs/homepage.yaml\n\n2 passed, 1 failed (2 errors)\n\\`\\`\\`\n\n## Error Messages (Actionable)\nBad: \"Invalid type\"\nGood: \"Step id is required - add 'id: login_button' to this step\"\n\nBad: \"String expected\"\nGood: \"Invalid duration \\\"3000\\\" - use format like \\\"3s\\\", \\\"2m\\\", or \\\"500ms\\\"\"\n\n## Acceptance Criteria\n- [ ] Validates all specs in specs/ by default\n- [ ] Reports errors with line numbers\n- [ ] Error messages are actionable\n- [ ] Catches missing step IDs\n- [ ] Catches invalid duration strings\n- [ ] Catches duplicate step IDs\n- [ ] Exit code 3 on validation failure (per spec)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:57.8663227-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.441068464-05:00","closed_at":"2026-01-15T23:04:35.441068464-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-eq4","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:15.064940969-05:00","created_by":"ubuntu"},{"issue_id":"bf-eq4","depends_on_id":"bf-dgs","type":"blocks","created_at":"2026-01-15T17:47:15.154771672-05:00","created_by":"ubuntu"}]}
{"id":"bf-gdo","title":"E.3: Implement locator-to-code conversion","description":"# Task: Implement Locator-to-Code Conversion\n\n## Context\nThis utility converts LocatorObject from the lockfile into Playwright locator code. It handles all strategy types and scoping.\n\n## What to Build\n\\`\\`\\`typescript\nimport { LocatorObject, LocatorStrategy } from '@browserflow/core';\n\nexport function generateLocatorCode(\n  locator: LocatorObject,\n  variableName: string = 'page'\n): string {\n  let code = variableName;\n  \n  // 1. Apply scoping (within)\n  if (locator.scoping?.within) {\n    for (const scope of locator.scoping.within) {\n      code = \\`\\${code}.\\${strategyToCode(scope)}\\`;\n    }\n  }\n  \n  // 2. Apply preferred strategy\n  code = \\`\\${code}.\\${strategyToCode(locator.preferred)}\\`;\n  \n  // 3. Apply nth index\n  if (locator.scoping?.nth !== undefined) {\n    const nth = locator.scoping.nth;\n    if (nth === 0) {\n      code = \\`\\${code}.first()\\`;\n    } else if (nth === -1) {\n      code = \\`\\${code}.last()\\`;\n    } else {\n      code = \\`\\${code}.nth(\\${nth})\\`;\n    }\n  }\n  \n  return code;\n}\n\nfunction strategyToCode(strategy: LocatorStrategy): string {\n  switch (strategy.type) {\n    case 'testid':\n      const attr = strategy.attribute || 'data-testid';\n      if (attr === 'data-testid') {\n        return \\`getByTestId('\\${escape(strategy.value)}')\\`;\n      }\n      return \\`locator('[\\${attr}=\"\\${escape(strategy.value)}\"]')\\`;\n      \n    case 'role':\n      const opts: string[] = [];\n      if (strategy.name) {\n        opts.push(\\`name: '\\${escape(strategy.name)}'\\`);\n      }\n      if (strategy.exact !== undefined) {\n        opts.push(\\`exact: \\${strategy.exact}\\`);\n      }\n      const optsStr = opts.length \u003e 0 ? \\`, { \\${opts.join(', ')} }\\` : '';\n      return \\`getByRole('\\${strategy.role}'\\${optsStr})\\`;\n      \n    case 'label':\n      return \\`getByLabel('\\${escape(strategy.text)}')\\`;\n      \n    case 'placeholder':\n      return \\`getByPlaceholder('\\${escape(strategy.text)}')\\`;\n      \n    case 'text':\n      return \\`getByText('\\${escape(strategy.text)}')\\`;\n      \n    case 'css':\n      return \\`locator('\\${escape(strategy.selector)}')\\`;\n      \n    default:\n      throw new Error(\\`Unknown strategy type: \\${(strategy as any).type}\\`);\n  }\n}\n\nfunction escape(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n\\`\\`\\`\n\n## Example Transformations\n\n| LocatorObject | Generated Code |\n|---------------|----------------|\n| \\`{ type: 'testid', value: 'submit' }\\` | \\`page.getByTestId('submit')\\` |\n| \\`{ type: 'role', role: 'button', name: 'Save' }\\` | \\`page.getByRole('button', { name: 'Save' })\\` |\n| \\`{ within: [testid: 'form'], preferred: {role...}, nth: 0 }\\` | \\`page.getByTestId('form').getByRole('button').first()\\` |\n\n## Acceptance Criteria\n- [ ] All strategy types generate valid code\n- [ ] Scoping (within) chains correctly\n- [ ] nth handling correct (first/last/nth)\n- [ ] String escaping prevents injection\n- [ ] Generated code is readable","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:37.419589663-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:04.698707324-05:00","closed_at":"2026-01-15T21:59:04.698707324-05:00","close_reason":"Implemented locator-to-code conversion with nth (first/last/nth) and within (scoping) options. Added 63 comprehensive tests. All acceptance criteria met.","dependencies":[{"issue_id":"bf-gdo","depends_on_id":"bf-bvs","type":"blocks","created_at":"2026-01-15T17:47:16.396175311-05:00","created_by":"ubuntu"}]}
{"id":"bf-h07","title":"E.2: Implement Playwright test generator","description":"# Task: Implement Playwright Test Generator\n\n## Context\nThe main generator that converts a lockfile into a runnable Playwright Test file. This is where determinism is guaranteed - the output should produce identical results every run.\n\n## What to Build\n\\`\\`\\`typescript\nimport { Lockfile, Spec } from '@browserflow/core';\nimport Handlebars from 'handlebars';\n\nexport class PlaywrightGenerator {\n  async generate(spec: Spec, lockfile: Lockfile, outputPath: string): Promise\u003cvoid\u003e {\n    const testCode = this.renderTest(spec, lockfile);\n    await writeFile(outputPath, testCode);\n  }\n  \n  private renderTest(spec: Spec, lockfile: Lockfile): string {\n    const steps = spec.steps.map(step =\u003e ({\n      id: step.id,\n      action: step.action,\n      intent: this.formatIntent(step),\n      code: this.generateStepCode(step, lockfile)\n    }));\n    \n    return testTemplate({\n      spec_name: spec.name,\n      description: spec.description,\n      run_id: lockfile.run_id,\n      generated_at: new Date().toISOString(),\n      preconditions: spec.preconditions,\n      steps,\n      expected_outcomes: spec.expected_outcomes\n    });\n  }\n  \n  private generateStepCode(step: SpecStep, lockfile: Lockfile): string {\n    switch (step.action) {\n      case 'click':\n        return this.generateClick(step, lockfile);\n      case 'fill':\n        return this.generateFill(step, lockfile);\n      case 'navigate':\n        return this.generateNavigate(step);\n      case 'wait':\n        return this.generateWait(step);\n      case 'expect':\n        return this.generateExpect(step, lockfile);\n      case 'screenshot':\n        return this.generateScreenshot(step, lockfile);\n      // ... etc\n    }\n  }\n}\n\\`\\`\\`\n\n## Generated Test Structure\n\\`\\`\\`typescript\n// e2e/tests/checkout-cart.spec.ts\nimport { test, expect } from '@playwright/test';\n\n/**\n * BrowserFlow Generated Test\n * \n * Spec: checkout-cart\n * Run: run-20260115-031000-abc123\n * Generated: 2026-01-15T03:25:00Z\n * \n * WARNING: Do not edit manually.\n * To update: bf generate --spec checkout-cart\n */\n\ntest.describe('checkout-cart', () =\u003e {\n  test('checkout-cart', async ({ page }) =\u003e {\n    // Preconditions\n    await page.goto('/');\n    \n    // ────────────────────────────────────────────────\n    // Step: add_first_product\n    // Intent: Click \"Add to Cart button on first product\"\n    // ────────────────────────────────────────────────\n    await test.step('add_first_product', async () =\u003e {\n      await page.getByTestId('add-to-cart').first().click();\n    });\n    \n    // ... more steps\n  });\n});\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Generates valid TypeScript that compiles\n- [ ] Uses lockfile locators (not exploration refs)\n- [ ] Includes generation metadata in header\n- [ ] test.step() for each spec step\n- [ ] Comments show original intent\n- [ ] Handles all action types","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:20.983571749-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:24:49.426648502-05:00","closed_at":"2026-01-15T22:24:49.426648502-05:00","close_reason":"Implemented test.step() wrapping for Playwright tests with comprehensive test suite (38 tests). All acceptance criteria met.","dependencies":[{"issue_id":"bf-h07","depends_on_id":"bf-bvs","type":"blocks","created_at":"2026-01-15T17:47:16.302574752-05:00","created_by":"ubuntu"},{"issue_id":"bf-h07","depends_on_id":"bf-gdo","type":"blocks","created_at":"2026-01-15T17:47:16.485223169-05:00","created_by":"ubuntu"}]}
{"id":"bf-jlm","title":"B.2: Implement bf init command","description":"# Task: Implement bf init Command\n\n## Context\n\\`bf init\\` is the first command new users run. It creates the project structure and default configuration. This is the onboarding experience.\n\n## What to Build\n\\`\\`\\`typescript\n// bf init [options]\n// Options:\n//   --force     Overwrite existing config\n//   --example   Create example spec\n\nasync function init(options: { force?: boolean; example?: boolean }) {\n  // 1. Create directories\n  await mkdir('specs', { recursive: true });\n  \n  // 2. Create browserflow.yaml (if not exists or --force)\n  if (!exists('browserflow.yaml') || options.force) {\n    await writeFile('browserflow.yaml', DEFAULT_CONFIG);\n  }\n  \n  // 3. Update .gitignore\n  await appendToGitignore(['.browserflow/', 'node_modules/']);\n  \n  // 4. Create example spec (if --example)\n  if (options.example) {\n    await writeFile('specs/example.yaml', EXAMPLE_SPEC);\n  }\n  \n  // 5. Print next steps\n  console.log('BrowserFlow initialized!');\n  console.log('Next steps:');\n  console.log('  1. Edit browserflow.yaml');\n  console.log('  2. Create specs in specs/');\n  console.log('  3. Run: bf explore --spec \u003cname\u003e');\n}\n\\`\\`\\`\n\n## Default Config (browserflow.yaml)\n\\`\\`\\`yaml\nproject:\n  name: my-project\n  base_url: http://localhost:3000\n\nruntime:\n  browser: chromium\n  headless: true\n  viewport:\n    width: 1280\n    height: 720\n  timeout: 30s\n\nlocators:\n  prefer_testid: true\n  testid_attributes:\n    - data-testid\n    - data-test\n\nexploration:\n  adapter: claude\n  max_retries: 3\n\nreview:\n  port: 8190\n  auto_open: true\n\noutput:\n  tests_dir: e2e/tests\n  baselines_dir: baselines\n\\`\\`\\`\n\n## Example Spec (specs/example.yaml)\n\\`\\`\\`yaml\nversion: 2\nname: example\ndescription: Example spec - customize for your app\n\nsteps:\n  - id: visit_home\n    action: navigate\n    to: /\n\n  - id: homepage_screenshot\n    action: screenshot\n    name: homepage\n\ntags:\n  - example\n  - smoke\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf init --example\n\nBrowserFlow Initialized!\n\nCreated:\n  ✓ browserflow.yaml\n  ✓ specs/example.yaml\n  ✓ .gitignore (updated)\n\nNext steps:\n  1. Edit browserflow.yaml with your project settings\n  2. Write specs in specs/ directory\n  3. Run: bf explore --spec example\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Creates browserflow.yaml with sensible defaults\n- [ ] Creates specs/ directory\n- [ ] Updates .gitignore (doesn't duplicate entries)\n- [ ] --force overwrites existing config\n- [ ] --example creates working example spec\n- [ ] Prints clear next steps","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:22.296770448-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:39.388056487-05:00","closed_at":"2026-01-15T21:59:39.388056487-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-jlm","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:14.886038131-05:00","created_by":"ubuntu"}]}
{"id":"bf-kqu","title":"Implement bf review server command","notes":"## Context \u0026 Goal\n\n**Problem:** Review UI expects data from \\`/api/exploration\\` endpoint (packages/review-ui/src/hooks/useExplorationData.ts:54), but no server exists to serve this data. The UI cannot load exploration data.\n\n**Why it matters:** Human review is the \"in-the-loop\" part of BrowserFlow. Without a working review server, the review workflow is broken.\n\n**Project goal served:** Enable human review of AI explorations.\n\n## Current State vs Target State\n\n**Current (packages/review-ui/src/hooks/useExplorationData.ts:45-59):**\n\\`\\`\\`typescript\nif (explorationPath) {\n  const response = await fetch(explorationPath);\n  // ...\n} else {\n  const response = await fetch('/api/exploration');  // No server!\n  // ...\n}\n\\`\\`\\`\n\n**Current CLI has no review command or server.**\n\n**Target - add review server command:**\n\n\\`\\`\\`typescript\n// packages/cli/src/commands/review.ts\nimport { Command } from 'commander';\nimport { readFile, writeFile, readdir, mkdir } from 'node:fs/promises';\nimport { join, basename } from 'node:path';\nimport { colors } from '../ui/colors.js';\n\nexport function reviewCommand(): Command {\n  return new Command('review')\n    .description('Start review server for exploration approval')\n    .option('--exploration \u003cid\u003e', 'Specific exploration ID to review')\n    .option('--port \u003cport\u003e', 'Server port', '8190')\n    .option('--no-open', 'Don\\\\'t auto-open browser')\n    .action(async (options) =\u003e {\n      const port = parseInt(options.port, 10);\n      \n      const server = Bun.serve({\n        port,\n        async fetch(req) {\n          const url = new URL(req.url);\n          \n          // Serve exploration data\n          if (url.pathname === '/api/exploration') {\n            const id = url.searchParams.get('id') || options.exploration;\n            if (!id) {\n              // List available explorations\n              const explorations = await listExplorations();\n              return Response.json({ explorations });\n            }\n            const data = await loadExploration(id);\n            return Response.json(data);\n          }\n          \n          // Handle review submission (POST /api/reviews/:id)\n          if (url.pathname.startsWith('/api/reviews/') \u0026\u0026 req.method === 'POST') {\n            const id = url.pathname.split('/').pop()!;\n            const reviewData = await req.json();\n            const reviewPath = await saveReview(id, reviewData);\n            return Response.json(\n              { success: true },\n              { headers: { 'X-Review-Path': reviewPath } }\n            );\n          }\n          \n          // Serve static review UI (from built review-ui dist)\n          return serveStaticUI(url.pathname);\n        },\n      });\n      \n      console.log(colors.info(\\`Review server: http://localhost:\\${port}\\`));\n      if (options.open !== false) {\n        const explorationParam = options.exploration ? \\`?id=\\${options.exploration}\\` : '';\n        // Open browser to review UI\n        await openBrowser(\\`http://localhost:\\${port}\\${explorationParam}\\`);\n      }\n    });\n}\n\nasync function loadExploration(id: string): Promise\u003cunknown\u003e {\n  const explorationPath = \\`.browserflow/explorations/\\${id}/exploration.json\\`;\n  const content = await readFile(explorationPath, 'utf-8');\n  return JSON.parse(content);\n}\n\nasync function saveReview(id: string, reviewData: unknown): Promise\u003cstring\u003e {\n  const reviewPath = \\`.browserflow/explorations/\\${id}/review.json\\`;\n  await writeFile(reviewPath, JSON.stringify(reviewData, null, 2));\n  return reviewPath;\n}\n\nasync function listExplorations(): Promise\u003cstring[]\u003e {\n  const explorationsDir = '.browserflow/explorations';\n  try {\n    const entries = await readdir(explorationsDir);\n    return entries.filter(e =\u003e e.startsWith('exp-'));\n  } catch {\n    return [];\n  }\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files CREATED:**\n- packages/cli/src/commands/review.ts (~180 lines) - review server command\n\n**Files MODIFIED (write):**\n- packages/cli/src/index.ts (lines 1-10, 19-25) - import and register command\n\n**Files READ (reference only):**\n- packages/review-ui/src/hooks/useExplorationData.ts - understand expected API\n- packages/review-ui/src/App.tsx - understand submit endpoint\n- packages/review-ui/dist/* - serve static files (after review-ui is built)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-v8m (deprecate bash CLI) - different files\n- bf-wvu (generator path) - different package\n- bf-2ts (screenshot evidence) - different package\n- bf-8h2 (schema sync) - different package\n- bf-wjz (pixelmatch) - different package\n\n**Cannot Run In Parallel With:**\n- bf-x9t (explore command) - both modify packages/cli/src/index.ts (MUST RUN AFTER)\n- bf-ari (codify command) - both modify packages/cli/src/index.ts\n\n**Blocking Reason:** Unblocks bf-2hk (server-side save) and bf-ari (codify needs review data)\n\n## Estimated Scope\n- **Size:** Large (150-200 lines)\n- **Risk:** Medium (new server, uses Bun.serve which is well-documented)\n\n## Acceptance Criteria\n- [ ] \\`bf review --help\\` shows review command\n- [ ] \\`bf review --exploration exp-123\\` starts server on port 8190\n- [ ] \\`GET /api/exploration?id=exp-123\\` returns exploration JSON\n- [ ] \\`GET /api/exploration\\` (no id) returns list of available explorations\n- [ ] \\`POST /api/reviews/exp-123\\` saves review data to .browserflow/explorations/exp-123/review.json\n- [ ] Review UI loads correctly when served\n- [ ] --no-open flag prevents browser opening\n- [ ] \\`bun run test\\` passes in packages/cli\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Test API endpoints with mock exploration data\n- Test static file serving\n- Test review save writes correct JSON\n- Test list explorations returns correct IDs\n- Integration: run server, verify UI loads exploration\n- Run: \\`cd packages/cli \u0026\u0026 bun test\\`","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-19T15:24:17.165995728-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:41:40.366719485-05:00","closed_at":"2026-01-19T17:41:40.366719485-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-kqu","depends_on_id":"bf-x9t","type":"blocks","created_at":"2026-01-19T15:25:17.283902407-05:00","created_by":"ubuntu"}]}
{"id":"bf-l7h","title":"Add overall comment field to Review UI","notes":"# Context \u0026 Goal\n\nUsers need a place to write overall feedback about the exploration, not just per-step comments. This is where they summarize findings for Claude.\n\n## Current State\n\nNo overall comment field exists. Only per-step comments.\n\n## Target State\n\nAdd an overall comment textarea to the Review UI header or footer:\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│  BrowserFlow Review: add-todo                                           │\n│  ─────────────────────────────                                          │\n│  Overall Notes:                                                         │\n│  ┌─────────────────────────────────────────────────────────────────────┐│\n│  │ The add todo flow mostly works but step 3 shows the item in the    ││\n│  │ wrong position. See highlighted area on that step.                 ││\n│  └─────────────────────────────────────────────────────────────────────┘│\n│                                                      [Submit Report]    │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n**Files MODIFIED:**\n- `packages/review-ui/src/pages/ReviewPage.tsx` (header section) - Add overall comment textarea\n- `packages/review-ui/src/hooks/useReviewState.ts` - Add overallComment state\n\n**Files READ:**\n- `packages/review-ui/src/App.tsx` - Understand submit flow\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill)\n- bf-lkz (screenshots)\n- bf-17e (server wiring)\n\n**Must Wait For:**\n- bf-3el (should coordinate with UI changes)\n\n## Estimated Scope\n- **Size:** Small (30-50 lines)\n- **Risk:** Low (additive UI change)\n\n## Acceptance Criteria\n- [ ] Overall comment textarea visible in header or footer\n- [ ] Value persists across step navigation\n- [ ] Included in submitted review.json\n- [ ] Placeholder text guides user\n\n## Testing Requirements\n- Open Review UI\n- Enter overall comment\n- Navigate between steps - comment should persist\n- Submit - overall_comment in review.json\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-20T00:21:18.888096769-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:21:18.888096769-05:00","dependencies":[{"issue_id":"bf-l7h","depends_on_id":"bf-3el","type":"blocks","created_at":"2026-01-20T00:22:02.819187257-05:00","created_by":"ubuntu"}]}
{"id":"bf-lkz","title":"Fix exploration screenshot saving","notes":"# Context \u0026 Goal\n\nThe exploration engine records screenshot paths in exploration.json but does NOT actually write screenshot files to disk. This breaks the entire review workflow since the Review UI needs actual images to display.\n\n## Current State\n\n**File:** `packages/exploration/src/explorer.ts` (lines 238-248)\n\nThe `executeStepWithEvidence()` method calls `this.browser!.screenshot()` but **discards the return value** instead of saving to disk:\n\n```typescript\n// Take before screenshot\nawait this.browser!.screenshot();  // \u003c-- Result discarded!\n\n// Get snapshot for element finding\nsnapshotBefore = await this.browser!.getSnapshot({ interactive: true });\n\n// Execute the step\nconst execution = await this.executeAction(step, snapshotBefore, baseUrl);\n\n// Take after screenshot  \nawait this.browser!.screenshot();  // \u003c-- Result discarded!\n```\n\nThe screenshot paths are then hard-coded without any actual files:\n```typescript\nscreenshots: {\n  before: screenshotBeforePath,  // \"screenshots/step-00-before.png\"\n  after: screenshotAfterPath,    // \"screenshots/step-00-after.png\"\n},\n```\n\n**Note:** There IS working screenshot capture code:\n- `evidence.ts` has `captureScreenshot()` that writes to disk (lines 86-118)\n- `explorer.ts` has `captureEvidence()` method that calls it (lines 480-481)\n- `step-executor.ts` uses this correctly (lines 136-147)\n\nBut the main `explore()` flow doesnt use any of this!\n\n## Target State\n\nThe `executeStepWithEvidence()` method should:\n1. Call `this.evidenceCollector.captureScreenshot()` instead of `this.browser!.screenshot()`\n2. Or use `this.captureEvidence()` which already wraps this\n\n**Fix approach:**\n```typescript\n// Take before screenshot - SAVE IT\nconst beforePath = await this.evidenceCollector.captureScreenshot(\n  explorationId, \n  `step-${String(stepIndex).padStart(2, \"0\")}-before`\n);\n\n// ... execute step ...\n\n// Take after screenshot - SAVE IT  \nconst afterPath = await this.evidenceCollector.captureScreenshot(\n  explorationId,\n  `step-${String(stepIndex).padStart(2, \"0\")}-after`\n);\n```\n\n**Files MODIFIED:**\n- `packages/exploration/src/explorer.ts` (lines 224-286) - Fix `executeStepWithEvidence()` to save screenshots\n\n**Files READ:**\n- `packages/exploration/src/evidence.ts` - Existing `captureScreenshot()` implementation\n- `packages/exploration/src/step-executor.ts` - Example of correct usage\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-4gk (skill creation - different files)\n- Review UI beads (different package)\n\n**Cannot Run In Parallel With:**\n- Any other exploration package beads\n\n## Estimated Scope\n- **Size:** Small (10-20 lines changed)\n- **Risk:** Low (simple fix - wiring existing code)\n\n## Acceptance Criteria\n- [ ] Screenshots directory created at `.browserflow/explorations/{id}/screenshots/`\n- [ ] Before/after screenshots exist as PNG files for each step\n- [ ] exploration.json paths point to actual existing files\n- [ ] `ls .browserflow/explorations/exp-*/screenshots/` shows PNG files after exploration\n- [ ] PNG files contain actual browser content (not empty/corrupt)\n\n## Testing Requirements\n1. Run `bf explore --spec add-todo --url http://localhost:3001`\n2. Verify `ls .browserflow/explorations/exp-*/screenshots/` shows PNG files\n3. Open a PNG manually to verify it contains expected browser content\n4. Check exploration.json paths match actual files","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-20T00:20:11.984852777-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:40:38.990692389-05:00","closed_at":"2026-01-20T00:40:38.990692389-05:00","close_reason":"Closed"}
{"id":"bf-lp7","title":"G.1: Implement bf baseline commands","description":"# Task: Implement bf baseline Commands\n\n## Context\nBaseline management commands let users view diff status, accept new baselines, and manage visual regression expectations. Baselines should NEVER update implicitly.\n\n## What to Build\n\\`\\`\\`typescript\n// bf baseline status --spec \u003cname\u003e\n// bf baseline diff --spec \u003cname\u003e\n// bf baseline accept --spec \u003cname\u003e [--run-id \u003cid\u003e] [--all]\n// bf baseline update --spec \u003cname\u003e  (convenience alias for accept from latest)\n\nexport async function baselineStatus(specName: string): Promise\u003cvoid\u003e {\n  const baselines = await getBaselinesForSpec(specName);\n  const latestRun = await getLatestRun(specName);\n  const actuals = await getActualsFromRun(latestRun);\n  \n  console.log(\\`Baseline status for: \\${specName}\\n\\`);\n  \n  for (const baseline of baselines) {\n    const actual = actuals.find(a =\u003e a.name === baseline.name);\n    const status = actual ? await compareImages(baseline.path, actual.path) : 'missing';\n    \n    const icon = status === 'match' ? '✓' : status === 'diff' ? '✗' : '?';\n    console.log(\\`  \\${icon} \\${baseline.name}\\`);\n    if (status === 'diff') {\n      console.log(\\`    → Differs by \\${status.diffPercent}%\\`);\n    }\n  }\n}\n\nexport async function baselineAccept(\n  specName: string,\n  options: { runId?: string; all?: boolean; screenshot?: string }\n): Promise\u003cvoid\u003e {\n  const runId = options.runId || await getLatestRunId(specName);\n  const runDir = getRunDir(specName, runId);\n  \n  // Get actuals from run\n  const actuals = await getActualsFromRun(runDir);\n  \n  // Filter if specific screenshot requested\n  const toAccept = options.screenshot\n    ? actuals.filter(a =\u003e a.name === options.screenshot)\n    : actuals;\n  \n  // Confirm if not --all\n  if (!options.all) {\n    console.log('Screenshots to accept as new baselines:');\n    for (const actual of toAccept) {\n      console.log(\\`  • \\${actual.name}\\`);\n    }\n    const confirmed = await confirm('Accept these baselines?');\n    if (!confirmed) return;\n  }\n  \n  // Copy actuals to baselines\n  for (const actual of toAccept) {\n    const baselinePath = \\`baselines/\\${specName}/\\${actual.name}.png\\`;\n    \n    // Record metadata\n    await recordBaselineAcceptance(baselinePath, {\n      accepted_at: new Date().toISOString(),\n      accepted_by: process.env.USER || 'unknown',\n      run_id: runId,\n      previous_hash: await hashFile(baselinePath).catch(() =\u003e null),\n      current_hash: await hashFile(actual.path)\n    });\n    \n    // Copy file\n    await copyFile(actual.path, baselinePath);\n    console.log(\\`✓ Accepted: \\${actual.name}\\`);\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bf baseline status\\` shows current state\n- [ ] \\`bf baseline accept\\` requires explicit confirmation\n- [ ] Acceptance records metadata (who, when, from which run)\n- [ ] \\`bf baseline diff\\` opens Review UI with diff gallery\n- [ ] Works with multiple screenshots per spec","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:45:31.999071121-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.442698831-05:00","closed_at":"2026-01-15T23:04:35.442698831-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-lp7","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:16.671437881-05:00","created_by":"ubuntu"},{"issue_id":"bf-lp7","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.771398602-05:00","created_by":"ubuntu"}]}
{"id":"bf-mtk","title":"I.1: Implement bf repair command","description":"# Task: Implement bf repair Command\n\n## Context\n\\`bf repair\\` loads a failure bundle and guides the user through fixing the broken test. It can suggest deterministic fixes or use AI for more complex repairs.\n\n## What to Build\n\\`\\`\\`typescript\n// bf repair [options]\n// Options:\n//   --spec \u003cname\u003e         Repair specific spec\n//   --from-run \u003cpath\u003e     Path to failure.json\n//   --ai                  Enable AI-assisted repair\n//   --apply               Auto-apply suggestions\n//   --headed              Show browser during repair\n\nexport async function repair(options: RepairOptions): Promise\u003cvoid\u003e {\n  // 1. Load failure bundle\n  const failurePath = options.fromRun || await findLatestFailure(options.spec);\n  const failure = await loadFailureBundle(failurePath);\n  \n  console.log(\\`Repairing: \\${failure.spec_name}\\`);\n  console.log(\\`Failure: \\${failure.failure.error_type} at step \"\\${failure.failure.step_id}\"\\`);\n  console.log(\\`Message: \\${failure.failure.error_message}\\n\\`);\n  \n  // 2. Load current spec and lockfile\n  const spec = await loadSpec(failure.spec_name);\n  const lockfile = await loadLockfile(failure.run_id);\n  \n  // 3. Analyze and generate deterministic suggestions\n  const suggestions = analyzeFailure(failure, lockfile);\n  \n  // 4. (Optional) AI repair proposals\n  if (options.ai) {\n    const aiSuggestions = await aiRepairProposal(failure, spec, lockfile);\n    suggestions.push(...aiSuggestions);\n  }\n  \n  // 5. Present suggestions\n  if (suggestions.length === 0) {\n    console.log('No automatic repair suggestions. Manual intervention needed.');\n    return;\n  }\n  \n  for (const suggestion of suggestions) {\n    console.log(\\`Suggestion: \\${suggestion.description}\\`);\n    console.log(\\`  Type: \\${suggestion.type}\\`);\n    console.log(\\`  Confidence: \\${Math.round(suggestion.confidence * 100)}%\\`);\n  }\n  \n  // 6. Apply or open repair UI\n  if (options.apply) {\n    await applySuggestions(suggestions, lockfile);\n    await regenerateTest(spec, lockfile);\n    await verifyRepair(spec);\n  } else {\n    // Open repair UI\n    await openRepairUI(failure, suggestions);\n  }\n}\n\nfunction analyzeFailure(failure: FailureBundle, lockfile: Lockfile): RepairSuggestion[] {\n  const suggestions: RepairSuggestion[] = [];\n  \n  switch (failure.failure.error_type) {\n    case 'locator_not_found':\n      // Try fallback locators\n      const locator = lockfile.locators[failure.failure.step_id];\n      if (locator.fallbacks.length \u003e 0) {\n        suggestions.push({\n          type: 'use_fallback',\n          description: 'Try fallback locator',\n          confidence: 0.8,\n          patch: { preferred: locator.fallbacks[0] }\n        });\n      }\n      break;\n      \n    case 'timeout':\n      suggestions.push({\n        type: 'increase_timeout',\n        description: 'Double the timeout',\n        confidence: 0.6\n      });\n      break;\n      \n    case 'screenshot_diff':\n      suggestions.push({\n        type: 'update_baseline',\n        description: 'Accept new baseline',\n        confidence: 0.5\n      });\n      suggestions.push({\n        type: 'add_mask',\n        description: 'Add mask for changed region',\n        confidence: 0.7\n      });\n      break;\n  }\n  \n  return suggestions;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Loads failure bundle correctly\n- [ ] Deterministic suggestions work (fallbacks, timeout)\n- [ ] AI suggestions when --ai flag\n- [ ] Human approval required before applying\n- [ ] Regenerates test after repair\n- [ ] Verification run confirms fix","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:46:09.072264268-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.444099089-05:00","closed_at":"2026-01-15T23:04:35.444099089-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-mtk","depends_on_id":"bf-dcs","type":"blocks","created_at":"2026-01-15T17:47:16.964901908-05:00","created_by":"ubuntu"}]}
{"id":"bf-n3d","title":"Epic J: Documentation \u0026 Examples","description":"# Epic J: Documentation \u0026 Examples\n\n## Strategic Context\n\n**\"Install in minutes; minimal project changes required\"** is only possible with excellent documentation. This epic makes BrowserFlow accessible to new users without hand-holding.\n\n## Why This Matters\n\nGreat tools fail without great docs. BrowserFlow's workflow (spec → explore → review → generate → run → repair) is novel - users need guidance.\n\nGoals:\n- Zero-to-first-test in \u003c10 minutes\n- Self-service troubleshooting\n- CI integration \"just works\"\n\n## Deliverables\n\n1. **Getting started guide**:\n   - Installation\n   - First spec\n   - First exploration\n   - Review walkthrough\n   - CI setup\n2. **Configuration reference**:\n   - All browserflow.yaml options\n   - Environment variables\n   - Per-spec overrides\n3. **API reference** (for programmatic use):\n   - Core types\n   - Adapter interface\n4. **Example project**:\n   - Demo web app\n   - Multiple specs covering different patterns\n   - Pre-recorded exploration for offline testing\n5. **CI templates**:\n   - GitHub Actions\n   - GitLab CI\n   - Generic shell script\n6. **Inline CLI help**:\n   - \\`bf \u003ccmd\u003e --help\\` is comprehensive\n   - Examples in help text\n\n## Acceptance Criteria\n\n- [ ] New user can follow getting-started and have working test in \u003c10 minutes\n- [ ] All configuration options documented\n- [ ] Example project runs successfully\n- [ ] GitHub Actions template works on real repo\n- [ ] GitLab CI template works on real repo\n- [ ] --help output is comprehensive and accurate\n\n## Dependencies\n\n- **Depends on all other epics** - Can't document what doesn't exist\n- Can start in parallel with examples/templates\n\n## Documentation Principles\n\nFrom the spec:\n- **Progressive disclosure**: Start simple, link to advanced\n- **Actionable errors**: Every error message has a fix\n- **Examples over prose**: Show, don't just tell\n\n## Structure\n\n\\`\\`\\`\ndocs/\n├── getting-started.md      # 10-minute quickstart\n├── configuration.md        # All config options\n├── spec-format.md          # YAML v2 schema guide\n├── cli-reference.md        # All bf commands\n├── review-ui.md            # Review UI guide\n├── repair-mode.md          # Maintenance workflow\n├── ci-integration.md       # CI setup guides\n└── api-reference.md        # Programmatic usage\n\nexamples/\n└── demo-app/\n    ├── README.md           # How to run the example\n    ├── src/                # Simple web app\n    ├── specs/\n    │   ├── homepage.yaml\n    │   ├── login.yaml\n    │   └── checkout.yaml\n    └── browserflow.yaml\n\\`\\`\\`\n\n## CI Template (GitHub Actions)\n\n\\`\\`\\`yaml\nname: E2E Tests\non: [push, pull_request]\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: oven-sh/setup-bun@v1\n      \n      - name: Install BrowserFlow\n        run: bun add -g browserflow\n        \n      - name: Install Playwright browsers\n        run: bunx playwright install --with-deps chromium\n        \n      - name: Start app\n        run: bun run dev \u0026\n        \n      - name: Run tests\n        run: bf run\n        \n      - name: Upload failure artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: browserflow-failures\n          path: .browserflow/runs/**/failure.json\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 14: CLI Specification (--help content)\n- Section 22: Definitions of Done (documentation requirements)","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-15T17:37:02.407431094-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.741745293-05:00","closed_at":"2026-01-16T17:18:41.741745293-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-n3d","depends_on_id":"bf-bwv","type":"blocks","created_at":"2026-01-15T17:47:01.164510079-05:00","created_by":"ubuntu"}]}
{"id":"bf-o9t","title":"C.1: Create @browserflow/exploration package","description":"# Task: Create Exploration Package\n\n## Context\nThe exploration package contains the AI-powered exploration engine that drives a browser to execute spec steps and collect evidence.\n\n## What to Build\n\\`\\`\\`\npackages/exploration/\n├── src/\n│   ├── index.ts              # Public exports\n│   ├── explorer.ts           # Main orchestrator\n│   ├── step-executor.ts      # Execute individual steps\n│   ├── evidence.ts           # Screenshot/trace capture\n│   ├── locator-candidates.ts # Generate locator options\n│   └── adapters/\n│       ├── index.ts\n│       ├── types.ts          # AIAdapter interface\n│       └── claude.ts         # Claude implementation\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/exploration\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"agent-browser\": \"^0.5.0\",\n    \"@anthropic-ai/sdk\": \"^0.26.0\"\n  }\n}\n\\`\\`\\`\n\n## Main Export\n\\`\\`\\`typescript\nexport { Explorer } from './explorer';\nexport { ClaudeAdapter } from './adapters/claude';\nexport type { AIAdapter, ExploreParams, ExplorationOutput } from './adapters/types';\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles\n- [ ] Imports from agent-browser work\n- [ ] Adapter interface defined\n- [ ] Exports accessible from CLI package","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:24.268831416-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:36:44.951588173-05:00","closed_at":"2026-01-15T21:36:44.951588173-05:00","close_reason":"Closed"}
{"id":"bf-oua","title":"Rename ExplorationLockfile to ExplorationReport","notes":"## Context \u0026 Goal\n\n**Problem:** `ExplorationLockfile` in core/src/lockfile.ts is misnamed - its an exploration report/output, not the deterministic lockfile. This causes confusion.\n\n**Why it matters:** Naming confusion leads to bugs and contributor confusion.\n\n**Project goal served:** Clear type naming - lockfile means post-review deterministic truth.\n\n## Current State vs Target State\n\n**Current (packages/core/src/lockfile.ts):**\n```typescript\n// Legacy types for backwards compatibility\nexport interface ExplorationLockfile {\n  spec: string;\n  spec_path: string;\n  exploration_id: string;\n  timestamp: string;\n  duration_ms: number;\n  // ...\n}\n```\n\n**Target:**\n```typescript\n// Exploration output - NOT the deterministic lockfile\nexport interface ExplorationReport {\n  spec: string;\n  spec_path: string;\n  exploration_id: string;\n  timestamp: string;\n  duration_ms: number;\n  // ...\n}\n\n// Keep type alias for backward compat\n/** @deprecated Use ExplorationReport instead */\nexport type ExplorationLockfile = ExplorationReport;\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/core/src/lockfile.ts - rename interface, add deprecation alias\n- packages/core/src/index.ts - export ExplorationReport\n\n**Files READ (reference only):**\n- packages/exploration/src/adapters/types.ts - check if ExplorationOutput exists there\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-add-schema-actions (different concern)\n- bead-navigate-url-field (different files)\n- bead-duration-types (different concern)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying lockfile.ts\n\n**Blocking Reason:** Type rename may affect consumers\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (type rename with deprecation alias)\n\n## Acceptance Criteria\n- [ ] ExplorationReport interface exists\n- [ ] ExplorationLockfile is deprecated alias\n- [ ] No TypeScript errors in consuming packages\n- [ ] `bun run test` passes across all packages\n\n## Testing Requirements\n- Existing tests should pass unchanged\n- Run: `bun run test` in root\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T18:19:23.339757266-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:54:27.332382844-05:00","closed_at":"2026-01-19T15:54:27.332382844-05:00","close_reason":"Closed"}
{"id":"bf-p1n","title":"Add duration string parsing layer","notes":"## Context \u0026 Goal\n\n**Problem:** Schema says duration is a string (\"500ms\"), but SpecStep types define duration as number, and step-executor uses it directly without parsing. No parsing layer bridges the gap.\n\n**Why it matters:** Specs using duration strings will cause runtime type errors or NaN values.\n\n**Project goal served:** Spec coherence - duration handling must be consistent.\n\n## Current State vs Target State\n\n**parseDuration already exists in packages/core/src/duration.ts (line 71) and is exported.**\n\n**The gap is in the usage:**\n\n**Current (packages/exploration/src/adapters/types.ts:96-97):**\n```typescript\ntimeout?: number;\nduration?: number;\n```\n\n**Current (packages/exploration/src/step-executor.ts:466-467):**\n```typescript\nif (step.duration \u0026\u0026 this.browser\\!.waitForTimeout) {\n  await this.browser\\!.waitForTimeout(step.duration);  // Expects number\\!\n}\n```\n\n**Target Option A - Parse at executor boundary:**\n```typescript\n// step-executor.ts - import and use parseDuration\nimport { parseDuration } from '@browserflow/core';\n\n// In executeWait:\nif (step.duration \u0026\u0026 this.browser\\!.waitForTimeout) {\n  const ms = typeof step.duration === 'string' \n    ? parseDuration(step.duration) \n    : step.duration;\n  await this.browser\\!.waitForTimeout(ms);\n}\n```\n\n**Target Option B - Parse in spec loader (preferred - do it once):**\n```typescript\n// In spec loading, normalize all duration/timeout fields:\nfunction normalizeStep(step: RawStep): SpecStep {\n  return {\n    ...step,\n    duration: step.duration ? parseDuration(step.duration) : undefined,\n    timeout: step.timeout ? parseDuration(step.timeout) : undefined,\n  };\n}\n```\n\n**Also update types to accept both:**\n```typescript\n// adapters/types.ts - allow string input\ntimeout?: number | string;\nduration?: number | string;\n\n// Or keep as number and normalize at load time\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/exploration/src/step-executor.ts (lines 444, 466-467) - use parseDuration\n- packages/exploration/src/adapters/types.ts (lines 96-97) - allow string | number\n\n**Files READ (reference only):**\n- packages/core/src/duration.ts - parseDuration already exists\n- packages/core/src/index.ts - already exports parseDuration\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bead-add-schema-actions (different concern)\n- bead-navigate-url-field (can coordinate on step-executor changes)\n- bead-preconditions-format (different files)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying step-executor.ts (bf-el2, bf-cj8)\n\n**Blocking Reason:** Duration parsing affects wait/timeout behavior\n\n## Estimated Scope\n- **Size:** Small (20-40 lines)\n- **Risk:** Medium (affects timing behavior)\n\n## Acceptance Criteria\n- [ ] `step.duration: \"500ms\"` works in wait action\n- [ ] `step.timeout: \"5s\"` works in all actions  \n- [ ] Numeric values still work (backward compat)\n- [ ] `bun run test` passes in packages/exploration\n\n## Testing Requirements\n- Add test: wait with string duration \"500ms\"\n- Add test: wait with numeric duration 500\n- Verify parseDuration is called\n- Run: `cd packages/exploration \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:19:20.76411368-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:15:39.227612098-05:00","closed_at":"2026-01-19T17:15:39.227612098-05:00","close_reason":"Closed"}
{"id":"bf-p8r","title":"Epic B: CLI Foundation","description":"# Epic B: CLI Foundation\n\n## Strategic Context\n\nThe CLI is the **primary interface** between developers and BrowserFlow. A well-designed CLI establishes the UX patterns that will carry through to all features. We're building \"bf\" as a single entry point with subcommands.\n\n## Why This Matters\n\n**Low setup overhead** is a product goal. The CLI must:\n- Be discoverable (great --help output)\n- Provide actionable feedback (not raw errors)\n- Guide users to next steps\n- Work consistently across platforms\n\nThe commands we build here (\\`init\\`, \\`doctor\\`, \\`lint\\`) are the **onboarding experience**. If these are polished, users trust the tool.\n\n## Deliverables\n\n1. **bf command** with Commander.js\n2. **bf init** - Creates project structure:\n   - browserflow.yaml (config)\n   - specs/ directory\n   - .gitignore entries for .browserflow/\n   - Example spec (optional)\n3. **bf doctor** - Environment checker:\n   - Node.js version (\u003e=18)\n   - agent-browser installation\n   - Playwright browsers installed\n   - Config validity\n   - Port availability\n4. **bf lint** - Spec validator:\n   - Schema compliance\n   - Required fields (version, name, steps, step ids)\n   - Duration string format\n   - No duplicate step IDs\n   - Actionable error messages\n\n## Acceptance Criteria\n\n- [ ] \\`bf init\\` creates correct directory structure\n- [ ] \\`bf init --example\\` includes working example spec\n- [ ] \\`bf doctor\\` identifies missing dependencies with fix instructions\n- [ ] \\`bf lint\\` catches schema violations with line numbers\n- [ ] Exit codes are correct (0=success, 1=error, 2=args, 3=validation)\n- [ ] \\`--json\\` output mode works for scripting\n- [ ] Colors/formatting work in terminal\n\n## Dependencies\n\n- **Depends on Epic A** - Needs core types and schemas\n\n## Technical Decisions\n\n**Why Commander.js?**\n- Simple, well-documented\n- Widespread adoption means familiar patterns\n- Good TypeScript support\n- Subcommand support built-in\n\n**CLI UX Guidelines (from spec):**\n- Crisp output: minimal, informative\n- Consistent formatting: icons, colors, indentation\n- Next steps: always suggest what to do next\n- Never dump raw JSON unless --json flag\n\n## User Journey\n\n\\`\\`\\`\nDeveloper discovers BrowserFlow\n    ↓\nRuns: bf init\n    ↓\nGets: Clean project structure with example\n    ↓\nRuns: bf doctor\n    ↓\nGets: \"All dependencies OK\" or \"Install X with: \u003ccommand\u003e\"\n    ↓\nWrites: specs/my-test.yaml\n    ↓\nRuns: bf lint\n    ↓\nGets: \"Valid!\" or \"Line 12: missing required field 'id'\"\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 14: CLI Specification\n- Section 15: Configuration\n- Section 22: Definitions of Done (CLI requirements)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:04.712526118-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.720609435-05:00","closed_at":"2026-01-16T17:18:41.720609435-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-p8r","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:46:59.799053338-05:00","created_by":"ubuntu"}]}
{"id":"bf-qff","title":"F.1: Implement bf run command","description":"# Task: Implement bf run Command\n\n## Context\n\\`bf run\\` wraps Playwright Test execution, collecting artifacts into the BrowserFlow run directory structure and producing human-friendly output.\n\n## What to Build\n\\`\\`\\`typescript\n// bf run [options] [specs...]\n// Options:\n//   --spec \u003cname\u003e     Run specific spec\n//   --tag \u003ctag\u003e       Filter by tag\n//   --parallel \u003cn\u003e    Worker count\n//   --headed          Show browser\n//   --trace \u003cmode\u003e    on | off | on-first-retry\n\nimport { spawn } from 'child_process';\n\nexport async function run(options: RunOptions): Promise\u003cRunResult\u003e {\n  const runStore = new RunStore();\n  \n  // 1. Determine which specs to run\n  const specs = await resolveSpecs(options);\n  \n  // 2. Create run directory for this execution\n  const runDir = await runStore.createRun('_execution');\n  \n  // 3. Build Playwright command\n  const args = [\n    'playwright', 'test',\n    '--config', 'e2e/playwright.config.ts',\n    '--reporter', 'json',\n    '--output', path.join(runDir, 'artifacts')\n  ];\n  \n  if (options.parallel) {\n    args.push('--workers', String(options.parallel));\n  }\n  if (options.headed) {\n    args.push('--headed');\n  }\n  if (options.trace) {\n    args.push('--trace', options.trace);\n  }\n  \n  // Add spec filters\n  for (const spec of specs) {\n    args.push(\\`e2e/tests/\\${spec}.spec.ts\\`);\n  }\n  \n  // 4. Execute\n  const result = await executePlaywright(args);\n  \n  // 5. Collect results and generate summary\n  const summary = await collectResults(runDir, result);\n  \n  // 6. Print human-friendly output\n  printRunSummary(summary);\n  \n  // 7. If failures, generate failure bundles\n  if (summary.failed \u003e 0) {\n    await generateFailureBundles(runDir, summary.failures);\n  }\n  \n  return summary;\n}\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf run --spec checkout-cart\n\nRunning: checkout-cart\n\n  checkout-cart\n    ✓ add_first_product (1.2s)\n    ✓ cart_toast (0.8s)\n    ✓ open_cart (0.5s)\n    ✓ verify_cart_state (0.3s)\n    ✓ cart_visual (1.5s)\n    ✓ proceed_checkout (0.9s)\n    ✓ verify_checkout_state (0.4s)\n\n  7 passed (5.6s)\n\nRun complete. Results at: .browserflow/runs/_execution/run-xxx/\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Runs generated Playwright tests\n- [ ] Collects artifacts to .browserflow/runs/\n- [ ] Human-friendly step-by-step output\n- [ ] --parallel maps to Playwright workers\n- [ ] --headed shows browser\n- [ ] Exit code 5 on test failure","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:57.394154328-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:38:02.022981521-05:00","closed_at":"2026-01-15T21:38:02.022981521-05:00","close_reason":"Closed"}
{"id":"bf-sdb","title":"Add review completeness widget","notes":"## Context \u0026 Goal\n\n**Problem:** Users dont know if their review is complete before submission.\n\n**Why it matters:** Incomplete reviews lead to incomplete lockfiles and test failures.\n\n**Project goal served:** Premium UX - guide users through review.\n\n## Current State vs Target State\n\n**Current:**\n- No completeness indicator\n- Users must manually check each step\n\n**Target:**\nAdd widget showing:\n- \"3 steps need locators\"\n- \"1 step needs an assertion\"\n- \"2 steps have no verdict\"\n\n```typescript\n// packages/review-ui/src/components/ReviewCompleteness.tsx\nfunction ReviewCompleteness({ steps, reviewData }: Props) {\n  const stats = useMemo(() =\u003e {\n    const stepsNeedingLocator = steps.filter((s, i) =\u003e \n      s.needsLocator \u0026\u0026 !reviewData[i]?.lockedLocator\n    );\n    const stepsNeedingVerdict = steps.filter((s, i) =\u003e \n      !reviewData[i]?.status || reviewData[i].status === 'pending'\n    );\n    return { stepsNeedingLocator, stepsNeedingVerdict };\n  }, [steps, reviewData]);\n  \n  const isComplete = stats.stepsNeedingLocator.length === 0 \n    \u0026\u0026 stats.stepsNeedingVerdict.length === 0;\n  \n  return (\n    \u003cdiv className=\"review-completeness\"\u003e\n      {isComplete ? (\n        \u003cspan className=\"complete\"\u003eReady to submit\u003c/span\u003e\n      ) : (\n        \u003cul\u003e\n          {stats.stepsNeedingLocator.length \u003e 0 \u0026\u0026 (\n            \u003cli\u003e{stats.stepsNeedingLocator.length} steps need locators\u003c/li\u003e\n          )}\n          {stats.stepsNeedingVerdict.length \u003e 0 \u0026\u0026 (\n            \u003cli\u003e{stats.stepsNeedingVerdict.length} steps need approval\u003c/li\u003e\n          )}\n        \u003c/ul\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/ReviewPage.tsx - add completeness widget\n\n**Files READ (reference only):**\n- packages/review-ui/src/hooks/useReviewState.ts - understand state shape\n\n**Files CREATED:**\n- packages/review-ui/src/components/ReviewCompleteness.tsx\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1/2/3 beads (different concern)\n- Most Phase 4 beads\n\n**Cannot Run In Parallel With:**\n- None specifically\n\n**Blocking Reason:** None - nice-to-have polish\n\n## Estimated Scope\n- **Size:** Small (40-60 lines)\n- **Risk:** Low (additive UI)\n\n## Acceptance Criteria\n- [ ] Widget shows count of incomplete items\n- [ ] Updates in real-time as user reviews\n- [ ] Shows \"Ready to submit\" when complete\n- [ ] Clickable items jump to relevant step\n- [ ] `bun run test` passes\n\n## Testing Requirements\n- Test: shows correct counts\n- Test: updates when step approved\n- Test: shows ready when all complete\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-16T18:23:08.02235975-05:00","created_by":"ubuntu","updated_at":"2026-01-16T18:23:08.02235975-05:00"}
{"id":"bf-tr3","title":"Switch CLI run to JSON reporter","notes":"## Context \u0026 Goal\n\n**Problem:** CLI `bf run` uses `--reporter list` and parses stdout with regex. This is brittle and loses structured failure info.\n\n**Why it matters:** Playwright output format changes break result parsing. JSON reporter provides stable API.\n\n**Project goal served:** Deterministic CI with actionable failures.\n\n## Current State vs Target State\n\n**Current (packages/cli/src/run/executor.ts:77):**\n```typescript\nargs.push('--reporter', 'list');\n```\n\n**Current result parsing (packages/cli/src/run/results.ts) uses regex on text output.**\n\n**Target (packages/cli/src/run/executor.ts:77-78):**\n```typescript\nargs.push('--reporter', 'json');\nargs.push('--output-file', path.join(runDir, 'results.json'));\n```\n\n**New result parsing (packages/cli/src/run/results.ts):**\n```typescript\nexport async function parsePlaywrightResults(resultsPath: string): Promise\u003cRunResult\u003e {\n  const json = JSON.parse(await fs.readFile(resultsPath, 'utf-8'));\n  return {\n    passed: json.stats.expected,\n    failed: json.stats.unexpected,\n    skipped: json.stats.skipped,\n    duration: json.stats.duration,\n    specs: json.suites.flatMap(suite =\u003e \n      suite.specs.map(spec =\u003e ({\n        name: spec.title,\n        status: spec.ok ? 'passed' : 'failed',\n        duration: spec.tests[0]?.results[0]?.duration ?? 0,\n        error: spec.tests[0]?.results[0]?.error?.message,\n      }))\n    ),\n  };\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/cli/src/run/executor.ts (line 77) - change reporter to json\n- packages/cli/src/run/results.ts - rewrite to parse JSON not stdout\n\n**Files READ (reference only):**\n- Playwright JSON reporter output format docs\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different package)\n- bead-fix-testid-args (different package)\n- bead-region-mask-support (different package)\n\n**Cannot Run In Parallel With:**\n- bead-unify-run-store (both touch CLI run infrastructure)\n\n**Blocking Reason:** Reporter format affects all downstream result processing\n\n## Estimated Scope\n- **Size:** Medium (50-100 lines)\n- **Risk:** Medium (changes CLI output processing)\n\n## Acceptance Criteria\n- [ ] `bf run` uses `--reporter json`\n- [ ] Results parsed from JSON file, not stdout\n- [ ] Failure details include error messages\n- [ ] Exit codes unchanged (0 success, 5 test failure)\n- [ ] `bun run test` passes in packages/cli\n\n## Testing Requirements\n- Mock Playwright JSON output, verify parsing\n- Integration: run actual test, verify results.json created\n- Run: `cd packages/cli \u0026\u0026 bun test`\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-16T18:20:52.810619664-05:00","created_by":"ubuntu","updated_at":"2026-01-17T18:14:33.695760742-05:00","closed_at":"2026-01-17T18:14:33.695760742-05:00","close_reason":"Closed"}
{"id":"bf-u2n","title":"Epic E: Generator","description":"# Epic E: Generator (Playwright TypeScript)\n\n## Strategic Context\n\nThe generator is where **lockfile becomes code**. This is the transition from human-approved decisions to deterministic, runnable tests. No AI involved - pure code generation from structured data.\n\n## Why This Matters\n\n**Deterministic CI execution** is a core product goal. The generated tests must:\n- Produce the same result every run\n- Never call AI during execution\n- Use the exact locators approved in review\n- Generate proper artifacts on failure\n\nThis is also where BrowserFlow's **value proposition crystallizes**: you paid tokens once during exploration/review, now tests run forever for free.\n\n## Deliverables\n\n1. **@browserflow/generator package**\n2. **Playwright TS test generator**:\n   - Convert lockfile to test file\n   - Emit \\`test.step()\\` for each step\n   - Include comments with original intent\n   - Add generation metadata header\n3. **Locator-to-code converter**:\n   - LocatorObject → Playwright locator chain\n   - Handle scoping (within, nth)\n   - Prefer testid \u003e role \u003e css\n4. **Visual check generator**:\n   - \\`toHaveScreenshot()\\` with masks\n   - Threshold from lockfile\n5. **Config generator**:\n   - Create playwright.config.ts if absent\n   - Configure trace, video, reporters\n\n## Acceptance Criteria\n\n- [ ] Generated tests compile with TypeScript\n- [ ] Generated tests run deterministically\n- [ ] Visual checks include masks and thresholds\n- [ ] Tests produce trace on failure\n- [ ] Generation metadata in file header\n- [ ] \\`bf generate --spec X\\` creates e2e/tests/X.spec.ts\n- [ ] Existing tests not overwritten without --force\n\n## Dependencies\n\n- **Depends on Epic A** - Core types, lockfile schema\n- **Depends on Epic D** - Lockfile output from review\n\n## Technical Decisions\n\n**Why Playwright Test specifically?**\n- Industry standard, excellent documentation\n- Built-in visual comparison (\\`toHaveScreenshot\\`)\n- Native trace recording\n- Parallel execution\n- Great TypeScript support\n\n**Generated test structure:**\n\\`\\`\\`typescript\ntest.describe('checkout-cart', () =\u003e {\n  test('checkout-cart', async ({ page }) =\u003e {\n    // Step: add_first_product\n    await test.step('add_first_product', async () =\u003e {\n      await page.getByTestId('add-to-cart').click();\n    });\n    \n    // Step: cart_visual\n    await test.step('cart_visual', async () =\u003e {\n      await expect(page).toHaveScreenshot('cart-with-item.png', {\n        mask: [page.locator('.timestamp')],\n        maxDiffPixelRatio: 0.05,\n      });\n    });\n  });\n});\n\\`\\`\\`\n\n**Locator generation rules:**\n\\`\\`\\`typescript\nfunction generateLocator(locator: LocatorObject): string {\n  let code = 'page';\n  \n  // Apply scoping first\n  if (locator.scoping?.within) {\n    code += generateStrategy(locator.scoping.within[0]);\n  }\n  \n  // Apply preferred strategy\n  code += generateStrategy(locator.preferred);\n  \n  // Apply nth if needed\n  if (locator.scoping?.nth !== undefined) {\n    code += locator.scoping.nth === 0 ? '.first()' : \\`.nth(\\${locator.scoping.nth})\\`;\n  }\n  \n  return code;\n}\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 10: Generation Phase\n- Section 11: Runtime \u0026 Runner (generated tests are run)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:35:14.717950617-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.729439415-05:00","closed_at":"2026-01-16T17:18:41.729439415-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-u2n","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:47:00.247352105-05:00","created_by":"ubuntu"},{"issue_id":"bf-u2n","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.338432927-05:00","created_by":"ubuntu"}]}
{"id":"bf-ulm","title":"Fix getByTestId args bug in LocatorPicker","notes":"## Context \u0026 Goal\n\n**Problem:** In Review UI LocatorPicker, `candidateToLocator` uses `{ text: strategy.value }` for getByTestId but generator expects `{ testId: strategy.value }`. This breaks locked testid locators.\n\n**Why it matters:** CRITICAL BUG - users lock a locator in Review UI, generation throws error, test fails.\n\n**Project goal served:** Locator locking must be accurate.\n\n## Current State vs Target State\n\n**Current (packages/review-ui/src/components/LocatorPicker.tsx:188-192):**\n```typescript\ncase 'testid':\n  return {\n    method: 'getByTestId' as LocatorMethod,\n    args: { text: strategy.value },  // BUG!\n  };\n```\n\n**Target:**\n```typescript\ncase 'testid':\n  return {\n    method: 'getByTestId' as LocatorMethod,\n    args: { testId: strategy.value },  // FIXED\n  };\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/review-ui/src/components/LocatorPicker.tsx (line 191) - fix args key\n\n**Files READ (reference only):**\n- packages/generator/src/locator-emit.ts (lines 181-186) - verify expected arg name\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (different package)\n- bead-fix-diff-hotkey (different component)\n- bead-fix-mask-generation (different package)\n\n**Cannot Run In Parallel With:**\n- Other tasks modifying LocatorPicker.tsx\n\n**Blocking Reason:** None - this is a leaf fix\n\n## Estimated Scope\n- **Size:** Tiny (1 line change)\n- **Risk:** Low (isolated fix)\n\n## Acceptance Criteria\n- [ ] `candidateToLocator` returns `{ testId: value }` for testid strategy\n- [ ] Test updated to expect `testId` not `text`\n- [ ] Locked testid locators generate valid Playwright code\n- [ ] `bun run test` passes in packages/review-ui\n\n## Testing Requirements\n- Update LocatorPicker.test.ts line ~117-122 to expect `testId`\n- Integration: lock a testid locator, verify generator accepts it\n- Run: `cd packages/review-ui \u0026\u0026 bun test`\n","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-16T18:20:07.179603901-05:00","created_by":"ubuntu","updated_at":"2026-01-17T18:12:46.829286605-05:00","closed_at":"2026-01-17T18:12:46.829286605-05:00","close_reason":"Closed"}
{"id":"bf-v8m","title":"Deprecate legacy bash CLI","notes":"## Context \u0026 Goal\n\n**Problem:** Two CLI implementations exist with diverging command sets:\n- `bin/bf` (bash) - Has explore/review/codify commands that are stubs\n- `packages/cli/bin/bf.js` (TypeScript) - Has init/doctor/lint/run/baseline/repair\n\n**Why it matters:** Users don't know which CLI to use. The bash CLI appears more feature-complete (more commands) but those commands don't actually work. This creates confusion and broken expectations.\n\n**Project goal served:** Single source of truth for CLI interface.\n\n## Current State vs Target State\n\n**Current (bin/bf:1-50):**\n```bash\n#!/bin/bash\n# Shows explore/review/codify/run/ci commands\n# Most are stubs that don't do anything\n```\n\n**Current (packages/cli/src/index.ts:1-38):**\n```typescript\n// Working commands: init, doctor, lint, run, baseline, repair\n// No explore, review, or codify commands yet\n```\n\n**Target:**\n1. Delete `bin/bf` entirely\n2. Update package.json to only reference the TypeScript CLI\n3. Update any documentation referencing the bash CLI\n\n## Files Inventory\n\n**Files DELETED:**\n- bin/bf - entire legacy bash CLI\n\n**Files MODIFIED (write):**\n- package.json (root) - remove bin/bf from bin field if present\n- README.md (if exists) - update CLI usage docs\n\n**Files READ (reference only):**\n- packages/cli/src/index.ts - verify current command coverage\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads (no shared files)\n\n**Cannot Run In Parallel With:**\n- None\n\n**Blocking Reason:** None - simple deletion task\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Low (removing dead code)\n\n## Acceptance Criteria\n- [ ] bin/bf file deleted\n- [ ] No references to bin/bf in package.json\n- [ ] TypeScript CLI is the only bf entry point\n- [ ] bun run build succeeds\n\n## Testing Requirements\n- Verify `bunx bf --help` shows TypeScript CLI\n- Verify `bunx bf init`, `bunx bf lint`, `bunx bf run` work\n- No tests to add (removing code)","status":"closed","priority":1,"issue_type":"chore","created_at":"2026-01-19T15:23:10.448988602-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:51:51.309414693-05:00","closed_at":"2026-01-19T15:51:51.309414693-05:00","close_reason":"Closed"}
{"id":"bf-vnd","title":"B.1: Set up CLI package with Commander.js","description":"# Task: Set Up CLI Package with Commander.js\n\n## Context\nThe CLI is the primary interface to BrowserFlow. We use Commander.js for argument parsing and subcommand handling. This task sets up the package structure and command framework.\n\n## What to Build\n\\`\\`\\`\npackages/cli/\n├── src/\n│   ├── index.ts           # Entry point\n│   ├── commands/\n│   │   ├── init.ts\n│   │   ├── doctor.ts\n│   │   ├── lint.ts\n│   │   └── ... (others added in later tasks)\n│   └── ui/\n│       ├── spinner.ts     # Progress indicators\n│       ├── colors.ts      # Chalk wrapper\n│       └── prompts.ts     # User interaction\n├── bin/\n│   └── bf.js              # Shebang entry\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/cli\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"bf\": \"./bin/bf.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\"\n  },\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"commander\": \"^11.0.0\",\n    \"chalk\": \"^5.3.0\",\n    \"ora\": \"^7.0.0\"\n  }\n}\n\\`\\`\\`\n\n## bin/bf.js\n\\`\\`\\`javascript\n#!/usr/bin/env node\nimport '../dist/index.js';\n\\`\\`\\`\n\n## src/index.ts\n\\`\\`\\`typescript\nimport { Command } from 'commander';\nimport { version } from '../package.json';\n\nconst program = new Command();\n\nprogram\n  .name('bf')\n  .description('BrowserFlow - Human-in-the-Loop E2E Test Generation')\n  .version(version);\n\n// Subcommands added by other tasks\nprogram.command('init').description('Initialize BrowserFlow');\nprogram.command('doctor').description('Check environment');\nprogram.command('lint').description('Validate specs');\n// ... etc\n\nprogram.parse();\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bf --help\\` shows all commands\n- [ ] \\`bf --version\\` shows version\n- [ ] Commands are modular (one file per command)\n- [ ] Colors work in terminal\n- [ ] Builds and runs via \\`bun run dev\\`","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:05.467852311-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:34:58.817312149-05:00","closed_at":"2026-01-15T21:34:58.817312149-05:00","close_reason":"Closed"}
{"id":"bf-wjz","title":"Implement pixelmatch image diff for baselines","notes":"## Context \u0026 Goal\n\n**Problem:** Baseline comparison uses byte-level comparison instead of visual image diff.\n\\`packages/cli/src/commands/baseline.ts:136-159\\` - \\`compareImages()\\` just compares raw bytes.\n\n**Why it matters:** Byte comparison produces false positives (identical images with different metadata) and false negatives (visually identical images with slight encoding differences). Visual regression testing needs actual pixel comparison.\n\n**Project goal served:** Reliable visual regression detection.\n\n## Current State vs Target State\n\n**Current (packages/cli/src/commands/baseline.ts:136-159):**\n\\`\\`\\`typescript\nasync function compareImages(path1: string, path2: string): Promise\u003c{ match: boolean; diffPercent?: number }\u003e {\n  try {\n    const [content1, content2] = await Promise.all([readFile(path1), readFile(path2)]);\n\n    // Simple byte comparison for now\n    // In a real implementation, we'd use an image diffing library like pixelmatch\n    if (content1.equals(content2)) {\n      return { match: true };\n    }\n\n    // Calculate approximate difference (placeholder - real implementation would use pixelmatch)\n    let diffBytes = 0;\n    // ... byte counting ...\n    const diffPercent = (diffBytes / Math.max(content1.length, content2.length)) * 100;\n    return { match: false, diffPercent };\n  } catch {\n    return { match: false };\n  }\n}\n\\`\\`\\`\n\n**Target:**\n\\`\\`\\`typescript\nimport { PNG } from 'pngjs';\nimport pixelmatch from 'pixelmatch';\n\nasync function compareImages(\n  path1: string, \n  path2: string,\n  options: { threshold?: number; generateDiff?: boolean; diffPath?: string } = {}\n): Promise\u003c{ match: boolean; diffPercent: number; diffPath?: string }\u003e {\n  const { threshold = 0.1, generateDiff = true, diffPath } = options;\n  \n  const [img1Buffer, img2Buffer] = await Promise.all([\n    readFile(path1),\n    readFile(path2),\n  ]);\n  \n  const img1 = PNG.sync.read(img1Buffer);\n  const img2 = PNG.sync.read(img2Buffer);\n  \n  // Handle size mismatch\n  if (img1.width !== img2.width || img1.height !== img2.height) {\n    return { match: false, diffPercent: 100 };\n  }\n  \n  const { width, height } = img1;\n  const diff = generateDiff ? new PNG({ width, height }) : null;\n  \n  const mismatchedPixels = pixelmatch(\n    img1.data,\n    img2.data,\n    diff?.data ?? null,\n    width,\n    height,\n    { threshold }\n  );\n  \n  const totalPixels = width * height;\n  const diffPercent = (mismatchedPixels / totalPixels) * 100;\n  const match = mismatchedPixels === 0;\n  \n  // Write diff image if requested\n  if (!match \u0026\u0026 diff \u0026\u0026 diffPath) {\n    await writeFile(diffPath, PNG.sync.write(diff));\n  }\n  \n  return { match, diffPercent, diffPath: match ? undefined : diffPath };\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/cli/src/commands/baseline.ts (lines 136-159) - replace compareImages\n- packages/cli/package.json - add pixelmatch and pngjs dependencies\n\n**Files READ (reference only):**\n- packages/cli/src/run/failure-bundle.ts - may also use image comparison\n\n**Files CREATED:**\n- None (or packages/cli/src/utils/image-diff.ts if extracting utility)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads except those modifying baseline.ts\n\n**Cannot Run In Parallel With:**\n- bf-10c (baseline accept confirmation) - both modify baseline.ts\n\n**Blocking Reason:** None\n\n## Estimated Scope\n- **Size:** Medium (50-100 lines)\n- **Risk:** Medium (adds dependencies, changes comparison logic)\n\n## Acceptance Criteria\n- [ ] pixelmatch and pngjs added to dependencies\n- [ ] compareImages uses pixel-level comparison\n- [ ] Diff image generated when mismatch detected\n- [ ] Threshold configurable (default 0.1)\n- [ ] Size mismatch handled gracefully\n- [ ] \\`bun run test\\` passes in packages/cli\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Add test with identical images -\u003e match\n- Add test with different images -\u003e diff percentage accurate\n- Add test with different sizes -\u003e 100% diff\n- Verify diff image written correctly\n- Run: \\`cd packages/cli \u0026\u0026 bun test\\`","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-19T15:24:40.015712611-05:00","created_by":"ubuntu","updated_at":"2026-01-19T17:22:50.335176631-05:00","closed_at":"2026-01-19T17:22:50.335176631-05:00","close_reason":"Closed"}
{"id":"bf-wld","title":"Update CLAUDE.md with BrowserFlow workflow","notes":"# Context \u0026 Goal\n\nThe project CLAUDE.md should document the BrowserFlow workflow for any Claude session working in this repo. This complements the skill by providing project-specific context.\n\n## Current State\n\n**File:** `/data/projects/browserflow/CLAUDE.md`\n\nCurrently only documents Playwright/Bun compatibility issues.\n\n## Target State\n\nAdd section explaining:\n1. BrowserFlow is a tool for Claude to use\n2. The explore → review → test workflow\n3. How to read exploration.json\n4. How to read review.json feedback\n5. How to generate Playwright tests from artifacts\n\n**Files MODIFIED:**\n- `CLAUDE.md` - Add workflow documentation\n\n**Files READ:**\n- `.browserflow/explorations/*/exploration.json` - Example structure\n- `.browserflow/explorations/*/review.json` - Example structure\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads (documentation)\n\n## Estimated Scope\n- **Size:** Small (50-80 lines)\n- **Risk:** Low (documentation only)\n\n## Acceptance Criteria\n- [ ] CLAUDE.md explains explore → review → test workflow\n- [ ] Documents exploration.json structure\n- [ ] Documents review.json structure  \n- [ ] Explains how Claude should diagnose issues from feedback\n- [ ] Links to skill for detailed guidance\n\n## Testing Requirements\n- Read CLAUDE.md - should be clear\n- New Claude session should understand workflow\n","status":"open","priority":2,"issue_type":"chore","created_at":"2026-01-20T00:21:43.883982386-05:00","created_by":"ubuntu","updated_at":"2026-01-20T00:21:43.883982386-05:00"}
{"id":"bf-wvu","title":"Fix generator output path to match CLI expectation","notes":"## Context \u0026 Goal\n\n**Problem:** Generator emits tests to \\`tests/\\` but CLI expects them at \\`e2e/tests/\\`.\n- Generator: \\`packages/generator/src/playwright-ts.ts:113\\` returns \\`path: \\`tests/\\${lockfile.spec}.spec.ts\\`\\`\n- CLI executor: \\`packages/cli/src/run/executor.ts:113\\` pushes \\`e2e/tests/\\${spec}.spec.ts\\`\n\n**Why it matters:** Generated tests won't be found by \\`bf run\\` - the paths don't match. This silently breaks the pipeline.\n\n**Project goal served:** Spec coherence - generated tests must be runnable by CLI.\n\n## Current State vs Target State\n\n**Current (packages/generator/src/playwright-ts.ts:112-118):**\n\\`\\`\\`typescript\nreturn {\n  path: \\`tests/\\${lockfile.spec}.spec.ts\\`,  // WRONG - missing e2e/ prefix\n  content,\n  specName: lockfile.spec,\n  explorationId: lockfile.exploration_id,\n  generatedAt: new Date().toISOString(),\n};\n\\`\\`\\`\n\n**Current (packages/cli/src/run/executor.ts:112-114):**\n\\`\\`\\`typescript\nfor (const spec of specs) {\n  args.push(\\`e2e/tests/\\${spec}.spec.ts\\`);  // Expects e2e/tests/\n}\n\\`\\`\\`\n\n**Target (packages/generator/src/playwright-ts.ts:112-118):**\n\\`\\`\\`typescript\nreturn {\n  path: \\`e2e/tests/\\${lockfile.spec}.spec.ts\\`,  // Fixed - matches CLI\n  content,\n  specName: lockfile.spec,\n  explorationId: lockfile.exploration_id,\n  generatedAt: new Date().toISOString(),\n};\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- packages/generator/src/playwright-ts.ts (line 113) - change path prefix\n\n**Files READ (reference only):**\n- packages/cli/src/run/executor.ts - verify expected path format\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads except those modifying playwright-ts.ts\n\n**Cannot Run In Parallel With:**\n- Any other bead touching playwright-ts.ts (none currently open)\n\n**Blocking Reason:** None\n\n## Estimated Scope\n- **Size:** Tiny (1 line change)\n- **Risk:** Low (simple string change)\n\n## Acceptance Criteria\n- [ ] Generator outputs to e2e/tests/ directory\n- [ ] \\`bf run --spec checkout\\` finds generated test file\n- [ ] \\`bun run test\\` passes in packages/generator\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Update any generator tests that assert on output path\n- Verify path format: \\`e2e/tests/{specName}.spec.ts\\`\n- Run: \\`cd packages/generator \u0026\u0026 bun test\\`","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-19T15:23:29.181037478-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:51:51.311076565-05:00","closed_at":"2026-01-19T15:51:51.311076565-05:00","close_reason":"Closed"}
{"id":"bf-x1q","title":"A.4: Implement duration string parser","description":"# Task: Implement Duration String Parser\n\n## Context\nAll timeouts and durations in BrowserFlow use human-readable strings like \"3s\", \"2m\", \"500ms\". This utility converts them to milliseconds for use with Playwright APIs.\n\n## What to Build\n\\`\\`\\`typescript\n// Parse duration string to milliseconds\nfunction parseDuration(input: string): number;\n\n// Format milliseconds back to canonical string\nfunction formatDuration(ms: number): string;\n\n// Validate without parsing (for schema validation)\nfunction isValidDuration(input: string): boolean;\n\\`\\`\\`\n\n## Supported Formats (from Appendix C)\n| Input | Output (ms) |\n|-------|-------------|\n| 500ms | 500 |\n| 3s | 3000 |\n| 2m | 120000 |\n| 1h | 3600000 |\n| 1m30s | 90000 |\n| 1h30m | 5400000 |\n\n## Implementation\n\\`\\`\\`typescript\nconst UNITS: Record\u003cstring, number\u003e = {\n  ms: 1,\n  s: 1000,\n  m: 60 * 1000,\n  h: 60 * 60 * 1000,\n};\n\nexport function parseDuration(input: string): number {\n  if (typeof input !== 'string' || !input.trim()) {\n    throw new Error('Duration must be a non-empty string');\n  }\n  \n  const regex = /(\\d+)(ms|s|m|h)/g;\n  let total = 0;\n  let match;\n  let hasMatch = false;\n  \n  while ((match = regex.exec(input)) !== null) {\n    hasMatch = true;\n    const [, value, unit] = match;\n    total += parseInt(value, 10) * UNITS[unit];\n  }\n  \n  if (!hasMatch) {\n    throw new Error(\n      \\`Invalid duration \"\\${input}\". Use format like \"3s\", \"2m\", \"500ms\", or \"1m30s\"\\`\n    );\n  }\n  \n  return total;\n}\n\nexport function formatDuration(ms: number): string {\n  if (ms \u003c 1000) return \\`\\${ms}ms\\`;\n  if (ms \u003c 60000) return \\`\\${ms / 1000}s\\`;\n  if (ms \u003c 3600000) return \\`\\${ms / 60000}m\\`;\n  return \\`\\${ms / 3600000}h\\`;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Parses all documented formats correctly\n- [ ] Throws clear error for invalid input like \"3 seconds\" or \"abc\"\n- [ ] formatDuration() produces canonical shortest form\n- [ ] Unit tests cover: basic units, combinations, edge cases, errors\n- [ ] Zero/negative handling documented","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:46.785472918-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.063679429-05:00","closed_at":"2026-01-15T22:27:55.063679429-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-x1q","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.435436508-05:00","created_by":"ubuntu"}]}
{"id":"bf-x9t","title":"Implement bf explore CLI command","notes":"## Context \u0026 Goal\n\n**Problem:** The exploration engine exists (\\`@browserflow/exploration\\`) but there's no CLI command to invoke it. Users can't run AI-driven exploration from the command line.\n\n**Why it matters:** This is the **core differentiator** of BrowserFlow - AI exploration is the main value prop. Without \\`bf explore\\`, the tool is just a Playwright runner.\n\n**Project goal served:** Enable the AI exploration workflow from CLI.\n\n## Current State vs Target State\n\n**Current (packages/cli/src/index.ts:1-38):**\n\\`\\`\\`typescript\n// Commands: init, doctor, lint, run, baseline, repair\n// NO explore command!\n\\`\\`\\`\n\n**Target - add exploreCommand to CLI:**\n\n\\`\\`\\`typescript\n// packages/cli/src/index.ts\nimport { exploreCommand } from './commands/explore.js';\n\n// In createProgram():\nprogram.addCommand(exploreCommand());\n\\`\\`\\`\n\n**New file packages/cli/src/commands/explore.ts:**\n\\`\\`\\`typescript\nimport { Command } from 'commander';\nimport { readFile } from 'node:fs/promises';\nimport { parse as parseYaml } from 'yaml';\nimport { specSchema } from '@browserflow/core';\nimport { Explorer, ClaudeAdapter, createBrowserSession } from '@browserflow/exploration';\nimport { colors } from '../ui/colors.js';\n\nexport function exploreCommand(): Command {\n  return new Command('explore')\n    .description('Run AI exploration for a spec')\n    .requiredOption('--spec \u003cname\u003e', 'Spec name to explore')\n    .option('--url \u003curl\u003e', 'Base URL (overrides config)')\n    .option('--headed', 'Run browser in headed mode')\n    .option('--adapter \u003cname\u003e', 'AI adapter (default: claude)', 'claude')\n    .action(async (options) =\u003e {\n      // 1. Load and validate spec from specs/{name}.yaml\n      const specPath = \\`specs/\\${options.spec}.yaml\\`;\n      const content = await readFile(specPath, 'utf-8');\n      const rawSpec = parseYaml(content);\n      const spec = specSchema.parse(rawSpec);\n      \n      // 2. Create browser session and AI adapter\n      const browser = createBrowserSession();\n      const adapter = new ClaudeAdapter();\n      \n      // 3. Create and run explorer\n      const explorer = new Explorer({\n        browser,\n        adapter,\n        headless: !options.headed,\n      });\n      \n      // 4. Run exploration\n      const result = await explorer.runExploration(spec, options.url);\n      \n      // 5. Write exploration output to .browserflow/explorations/\n      await writeExplorationOutput(result);\n      \n      // 6. Print summary\n      console.log(colors.success(\\`Exploration complete: \\${result.explorationId}\\`));\n      console.log(\\`Run \\\\\\`bf review --exploration \\${result.explorationId}\\\\\\` to review\\`);\n    });\n}\n\nasync function writeExplorationOutput(result: ExplorationOutput): Promise\u003cvoid\u003e {\n  const outputDir = \\`.browserflow/explorations/\\${result.explorationId}\\`;\n  await mkdir(outputDir, { recursive: true });\n  await writeFile(\n    \\`\\${outputDir}/exploration.json\\`,\n    JSON.stringify(result, null, 2)\n  );\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files CREATED:**\n- packages/cli/src/commands/explore.ts (~120 lines) - new explore command\n\n**Files MODIFIED (write):**\n- packages/cli/src/index.ts (lines 1-10, 19-25) - import and register command\n- packages/cli/package.json - add \\`@browserflow/exploration\\` dependency\n\n**Files READ (reference only):**\n- packages/exploration/src/explorer.ts - Explorer API\n- packages/exploration/src/agent-browser-session.ts - createBrowserSession API\n- packages/exploration/src/adapters/claude.ts - ClaudeAdapter API\n- packages/cli/src/commands/lint.ts - reference for spec loading pattern\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- bf-v8m (deprecate bash CLI) - different files\n- bf-wvu (generator path) - different package\n- bf-2ts (screenshot evidence) - different package\n- bf-8h2 (schema sync) - different package\n- bf-p1n (duration parsing) - different package\n\n**Cannot Run In Parallel With:**\n- bf-kqu (review command) - both modify packages/cli/src/index.ts\n- bf-ari (codify command) - both modify packages/cli/src/index.ts\n\n**Blocking Reason:** Must complete before bf-kqu (review server needs explorations to serve)\n\n## Estimated Scope\n- **Size:** Medium (100-150 lines)\n- **Risk:** Medium (new integration point, adds package dependency)\n\n## Acceptance Criteria\n- [ ] \\`@browserflow/exploration\\` added to CLI package.json dependencies\n- [ ] \\`bf explore --help\\` shows explore command\n- [ ] \\`bf explore --spec checkout --url http://localhost:3000\\` runs exploration\n- [ ] Exploration output written to .browserflow/explorations/{id}/\n- [ ] Exploration ID printed for use with \\`bf review\\`\n- [ ] Spec validation errors shown clearly\n- [ ] \\`bun run test\\` passes in packages/cli\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Mock exploration to test CLI integration\n- Test option parsing: --spec, --url, --headed, --adapter\n- Test error handling for missing spec file\n- Test error handling for invalid spec YAML\n- Run: \\`cd packages/cli \u0026\u0026 bun test\\`","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-19T15:23:52.939881468-05:00","created_by":"ubuntu","updated_at":"2026-01-19T15:58:54.126565798-05:00","closed_at":"2026-01-19T15:58:54.126565798-05:00","close_reason":"Closed"}
{"id":"bf-xx5","title":"Epic F: Runner \u0026 Failure Bundles","description":"# Epic F: Runner \u0026 Failure Bundles\n\n## Strategic Context\n\nThe runner wraps Playwright execution and produces **failure bundles** that enable repair mode. This is critical for the maintenance story - when tests break, developers need actionable information.\n\n## Why This Matters\n\n**\"Failures are actionable with rich artifacts\"** is a product goal.\n\nA failure bundle must contain everything needed to:\n1. Understand what failed and why\n2. See the UI state at failure time\n3. Reproduce the issue locally\n4. Potentially auto-fix with repair mode\n\nWithout good failure bundles, broken tests become time sinks.\n\n## Deliverables\n\n1. **bf run command** - Wraps Playwright Test\n2. **Artifact collection** - Gather into .browserflow/runs/\n3. **Failure bundle generation**:\n   - trace.zip (Playwright trace)\n   - screenshots/failure.png\n   - diffs/ (baseline vs actual vs diff)\n   - logs/console.json\n   - logs/network.json\n   - failure.json (machine-readable summary)\n4. **Human-friendly CLI output**:\n   - Step-by-step progress\n   - Clear failure messages\n   - \"Next steps\" suggestions\n5. **Exit codes** per spec section 14.4\n\n## Acceptance Criteria\n\n- [ ] \\`bf run\\` executes generated tests\n- [ ] Failing tests produce complete failure bundles\n- [ ] CLI output shows pass/fail per step\n- [ ] \"Next steps\" suggests \\`bf repair\\` on failure\n- [ ] Artifacts are in .browserflow/runs/spec/run-id/\n- [ ] \\`--parallel N\\` maps to Playwright workers\n- [ ] \\`--headed\\` shows browser window\n- [ ] Exit codes match spec (0=pass, 5=test fail)\n\n## Dependencies\n\n- **Depends on Epic E** - Generated tests to run\n\n## Technical Decisions\n\n**Why wrap Playwright instead of using it directly?**\n- Collect artifacts into our run directory structure\n- Generate failure.json in our format\n- Add \"next steps\" and repair suggestions\n- Maintain immutable run history\n\n**Failure bundle structure:**\n\\`\\`\\`\n.browserflow/runs/checkout-cart/run-xxx/\n├── failure.json          # Machine-readable\n├── artifacts/\n│   ├── trace.zip         # Playwright trace\n│   ├── screenshots/\n│   │   └── failure.png\n│   ├── diffs/\n│   │   ├── cart-with-item-baseline.png\n│   │   ├── cart-with-item-actual.png\n│   │   └── cart-with-item-diff.png\n│   └── logs/\n│       ├── console.json\n│       └── network.json\n\\`\\`\\`\n\n**failure.json schema:**\n\\`\\`\\`json\n{\n  \"run_id\": \"run-xxx\",\n  \"spec_name\": \"checkout-cart\",\n  \"failure\": {\n    \"step_id\": \"cart_visual\",\n    \"action\": \"screenshot\",\n    \"error_type\": \"screenshot_diff\",\n    \"error_message\": \"Screenshot differs by 12.3%\"\n  },\n  \"artifacts\": {\n    \"trace\": \"artifacts/trace.zip\",\n    \"diff\": { ... }\n  },\n  \"suggestions\": [\n    { \"type\": \"update_baseline\", \"confidence\": 0.8 }\n  ]\n}\n\\`\\`\\`\n\n## CLI Output Example\n\n\\`\\`\\`\n┌────────────────────────────────────────────────────────┐\n│  BrowserFlow Test Results                               │\n├────────────────────────────────────────────────────────┤\n│  checkout-cart ──────────────────────────────────────  │\n│    ✓ add_first_product (1.2s)                          │\n│    ✓ cart_toast (0.8s)                                 │\n│    ✗ cart_visual (2.1s)                                │\n│      Screenshot differs from baseline by 12.3%         │\n│                                                        │\n│  1 failed │ 2 passed │ 4.1s total                      │\n│                                                        │\n│  Next steps:                                           │\n│    • bf baseline accept --spec checkout-cart           │\n│    • bf repair --spec checkout-cart                    │\n└────────────────────────────────────────────────────────┘\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 11: Runtime \u0026 Runner\n- Section 12: Repair Mode (uses failure bundles)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:35:38.559658619-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.732075934-05:00","closed_at":"2026-01-16T17:18:41.732075934-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-xx5","depends_on_id":"bf-u2n","type":"blocks","created_at":"2026-01-15T17:47:00.423629045-05:00","created_by":"ubuntu"}]}
{"id":"bf-yi8","title":"Implement agent-browser BrowserSession adapter","notes":"## Context \u0026 Goal\n\n**Problem:** The `BrowserSession` interface in `packages/exploration/src/explorer.ts` is designed for agent-browser integration, but there's no concrete implementation. The `agent-browser` package is listed as a dependency and installed, but never actually imported or used. All tests use mocks, so the exploration engine cannot actually automate a browser.\n\n**Why it matters:** This is the **critical missing piece** that prevents BrowserFlow from actually running explorations. Without this adapter:\n- `bf explore` cannot execute specs against real browsers\n- Screenshots are stubs (no actual files written)\n- The entire exploration pipeline is non-functional for real use\n\n**Project goal served:** Core promise of AI-driven browser automation requires a working browser.\n\n## Current State vs Target State\n\n**Current State:**\n- `BrowserSession` interface defined (`explorer.ts:30-69`)\n- `agent-browser@0.5.0` in package.json but never imported\n- All browser operations are mocked in tests\n- Evidence collector has TODO comments referencing agent-browser\n\n**Target State:**\nCreate `packages/exploration/src/agent-browser-session.ts` that implements `BrowserSession` using `BrowserManager` from agent-browser.\n\n## Files Inventory\n\n**Files CREATED:**\n- `packages/exploration/src/agent-browser-session.ts` - Main adapter implementation (~150 lines)\n- `packages/exploration/src/agent-browser-session.test.ts` - Integration tests\n\n**Files MODIFIED (write):**\n- `packages/exploration/src/index.ts` - Add exports for new adapter\n\n**Files READ (reference only):**\n- `packages/exploration/src/explorer.ts` (lines 30-69) - BrowserSession interface\n- `packages/exploration/src/adapters/types.ts` (lines 164-167) - EnhancedSnapshot type\n- `node_modules/.bun/agent-browser@0.5.0/.../dist/browser.d.ts` - BrowserManager API\n\n## Parallelization Info\n\n**Can Run In Parallel With:** All existing beads (creates new file, no conflicts)\n\n**Blocking:** Unblocks bf-2ts (screenshot evidence), bf-7fc (integration tests)\n\n## Estimated Scope\n- **Size:** Medium (~150 lines + ~100 lines tests)\n- **Risk:** Medium (isolated new code)\n\n## Acceptance Criteria\n- [ ] AgentBrowserSession implements full BrowserSession interface\n- [ ] All methods delegate to BrowserManager correctly\n- [ ] Factory function createBrowserSession() exported\n- [ ] TypeScript compiles without errors\n- [ ] Basic integration test passes (launch, navigate, screenshot, close)\n- [ ] bun run test passes in packages/exploration\n\n## Implementation Notes\n\nSee full implementation code in bead description file or ask agent to regenerate based on BrowserSession interface (explorer.ts:30-69) and BrowserManager API (agent-browser/dist/browser.d.ts).\n\nKey points:\n1. Wrap BrowserManager in try/catch for better errors\n2. getLocator() accepts refs like @e1 or e1\n3. Default viewport 1280x720\n4. Uses chromium browser","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-17T18:50:30.306005331-05:00","created_by":"ubuntu","updated_at":"2026-01-17T19:17:55.72775202-05:00","closed_at":"2026-01-17T19:17:55.72775202-05:00","close_reason":"Closed"}
