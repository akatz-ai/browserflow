{"id":"bf-0fe","title":"A.1: Initialize monorepo structure","description":"# Task: Initialize Monorepo Structure\n\n## Context\nThis is the first task - setting up the bun workspace monorepo that all packages will live in. This foundational structure enables clean separation of concerns and independent package development.\n\n## What to Build\n- Root package.json with workspaces config pointing to packages/*\n- packages/ directory with subdirectories for each package\n- tsconfig.base.json with shared TypeScript settings\n- .gitignore updates for node_modules, dist, .browserflow\n- Basic README.md with project overview\n\n## Monorepo Layout\n\\`\\`\\`\nbrowserflow/\n├── packages/\n│   ├── core/           # Shared types, schemas, utilities\n│   ├── exploration/    # AI exploration engine\n│   ├── review-ui/      # React review application  \n│   ├── generator/      # Playwright test generator\n│   └── cli/            # bf command-line tool\n├── schemas/            # JSON Schema exports\n├── examples/           # Example projects\n├── docs/               # Documentation\n├── package.json        # Workspace root\n├── bun.lockb\n├── tsconfig.base.json\n└── README.md\n\\`\\`\\`\n\n## Root package.json\n\\`\\`\\`json\n{\n  \"name\": \"browserflow\",\n  \"private\": true,\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": {\n    \"build\": \"bun run --filter '*' build\",\n    \"test\": \"bun run --filter '*' test\",\n    \"typecheck\": \"bun run --filter '*' typecheck\",\n    \"dev\": \"bun run --filter @browserflow/cli dev\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.3.0\",\n    \"@types/node\": \"^20.10.0\"\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bun install\\` succeeds at repo root\n- [ ] Each package directory exists with minimal package.json\n- [ ] tsconfig.base.json has proper module/target settings\n- [ ] .gitignore includes .browserflow/, node_modules/, dist/\n- [ ] README has project overview\n\n## Why Bun Over npm/yarn/pnpm?\n- Faster installs (important for CI)\n- Native workspace support without extra config\n- Better TypeScript/ESM handling out of the box\n- Single lockfile (bun.lockb) instead of multiple","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:08.458673198-05:00","created_by":"ubuntu","updated_at":"2026-01-15T19:33:03.678827936-05:00","closed_at":"2026-01-15T19:33:03.678827936-05:00","close_reason":"Closed"}
{"id":"bf-0vx","title":"D.2: Implement step timeline component","description":"# Task: Implement Step Timeline Component\n\n## Context\nThe step timeline is the left rail of the Review UI, showing all steps with thumbnails and status indicators. Users click to select a step for detailed review.\n\n## What to Build\n\\`\\`\\`typescript\ninterface StepTimelineProps {\n  steps: ExplorationStep[];\n  currentStepId: string;\n  reviewStatus: Record\u003cstring, 'approved' | 'rejected' | 'pending'\u003e;\n  onSelectStep: (stepId: string) =\u003e void;\n}\n\nexport function StepTimeline({ steps, currentStepId, reviewStatus, onSelectStep }: StepTimelineProps) {\n  return (\n    \u003cdiv className=\"w-48 border-r overflow-y-auto\"\u003e\n      \u003cdiv className=\"p-2 border-b\"\u003e\n        \u003ch2 className=\"font-semibold\"\u003eSteps\u003c/h2\u003e\n        \u003cdiv className=\"text-sm text-muted-foreground\"\u003e\n          {countApproved(reviewStatus)} / {steps.length} approved\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      \u003cdiv className=\"space-y-1 p-2\"\u003e\n        {steps.map((step, index) =\u003e (\n          \u003cStepThumbnail\n            key={step.step_id}\n            step={step}\n            index={index}\n            status={reviewStatus[step.step_id] || 'pending'}\n            isSelected={step.step_id === currentStepId}\n            onClick={() =\u003e onSelectStep(step.step_id)}\n          /\u003e\n        ))}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction StepThumbnail({ step, index, status, isSelected, onClick }) {\n  return (\n    \u003cbutton\n      onClick={onClick}\n      className={cn(\n        \"w-full p-2 rounded text-left transition-colors\",\n        isSelected \u0026\u0026 \"bg-accent\",\n        !isSelected \u0026\u0026 \"hover:bg-muted\"\n      )}\n    \u003e\n      \u003cdiv className=\"flex items-center gap-2\"\u003e\n        {/* Status indicator */}\n        \u003cStatusIcon status={status} /\u003e\n        \n        {/* Step number and ID */}\n        \u003cdiv className=\"flex-1 min-w-0\"\u003e\n          \u003cdiv className=\"text-sm font-medium truncate\"\u003e\n            {index + 1}. {step.step_id}\n          \u003c/div\u003e\n          \u003cdiv className=\"text-xs text-muted-foreground truncate\"\u003e\n            {step.intent.action}\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      {/* Thumbnail image */}\n      {step.evidence.screenshots?.after \u0026\u0026 (\n        \u003cimg\n          src={step.evidence.screenshots.after}\n          alt=\"\"\n          className=\"mt-2 w-full h-16 object-cover rounded\"\n        /\u003e\n      )}\n    \u003c/button\u003e\n  );\n}\n\nfunction StatusIcon({ status }: { status: 'approved' | 'rejected' | 'pending' }) {\n  switch (status) {\n    case 'approved':\n      return \u003cCheckCircle className=\"h-4 w-4 text-green-500\" /\u003e;\n    case 'rejected':\n      return \u003cXCircle className=\"h-4 w-4 text-red-500\" /\u003e;\n    case 'pending':\n      return \u003cCircle className=\"h-4 w-4 text-yellow-500\" /\u003e;\n  }\n}\n\\`\\`\\`\n\n## Features\n- Thumbnail preview of \"after\" screenshot\n- Status indicator (approved/rejected/pending)\n- Current step highlighted\n- Scrollable for many steps\n- Shows approval progress count\n\n## Acceptance Criteria\n- [ ] Shows all steps with thumbnails\n- [ ] Status icons reflect review state\n- [ ] Current step visually highlighted\n- [ ] Click navigates to step\n- [ ] Scrollable when many steps\n- [ ] Progress count updates in real-time","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:02.682829183-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.602289857-05:00","closed_at":"2026-01-15T22:02:18.602289857-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-0vx","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:15.909564984-05:00","created_by":"ubuntu"}]}
{"id":"bf-0wt","title":"J.2: Create CI templates (GitHub Actions, GitLab)","description":"# Task: Create CI Templates\n\n## Context\nCI templates enable users to integrate BrowserFlow into their CI/CD pipelines with minimal effort.\n\n## What to Build\n\n### GitHub Actions Template\n\\`\\`\\`yaml\n# .github/workflows/e2e.yml\nname: E2E Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      - name: Install dependencies\n        run: bun install\n      \n      - name: Install BrowserFlow\n        run: bun add -g browserflow\n      \n      - name: Install Playwright browsers\n        run: bunx playwright install --with-deps chromium\n      \n      - name: Start application\n        run: |\n          bun run dev \u0026\n          sleep 5\n      \n      - name: Run E2E tests\n        run: bf run\n      \n      - name: Upload failure artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: browserflow-failures\n          path: |\n            .browserflow/runs/**/failure.json\n            .browserflow/runs/**/artifacts/\n\\`\\`\\`\n\n### GitLab CI Template\n\\`\\`\\`yaml\n# .gitlab-ci.yml\ne2e:\n  stage: test\n  image: oven/bun:latest\n  \n  before_script:\n    - bun add -g browserflow\n    - bunx playwright install --with-deps chromium\n  \n  script:\n    - bun install\n    - bun run dev \u0026\n    - sleep 5\n    - bf run\n  \n  artifacts:\n    when: on_failure\n    paths:\n      - .browserflow/runs/**/failure.json\n      - .browserflow/runs/**/artifacts/\n    expire_in: 1 week\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] GitHub Actions template works on real repo\n- [ ] GitLab CI template works on real repo\n- [ ] Artifacts uploaded on failure\n- [ ] Documentation explains customization options","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-15T17:46:35.829049062-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:25:15.075132223-05:00","closed_at":"2026-01-15T23:25:15.075132223-05:00","close_reason":"Documentation completed: getting started guide and CI templates","dependencies":[{"issue_id":"bf-0wt","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:17.144025118-05:00","created_by":"ubuntu"}]}
{"id":"bf-2un","title":"B.3: Implement bf doctor command","description":"# Task: Implement bf doctor Command\n\n## Context\n\\`bf doctor\\` checks that all dependencies are installed and configured correctly. It provides actionable fix instructions for any issues found.\n\n## What to Build\n\\`\\`\\`typescript\n// bf doctor [options]\n// Options:\n//   --fix    Attempt to fix issues automatically\n\ninterface Check {\n  name: string;\n  check: () =\u003e Promise\u003cCheckResult\u003e;\n  fix?: () =\u003e Promise\u003cvoid\u003e;\n}\n\ninterface CheckResult {\n  status: 'pass' | 'warn' | 'fail';\n  message: string;\n  fixHint?: string;\n}\n\nconst checks: Check[] = [\n  {\n    name: 'Node.js version',\n    check: async () =\u003e {\n      const version = process.version;\n      const major = parseInt(version.slice(1));\n      if (major \u003e= 18) {\n        return { status: 'pass', message: \\`Node.js \\${version}\\` };\n      }\n      return {\n        status: 'fail',\n        message: \\`Node.js \\${version} (need \u003e=18)\\`,\n        fixHint: 'Install Node.js 18+ from https://nodejs.org'\n      };\n    }\n  },\n  {\n    name: 'agent-browser',\n    check: async () =\u003e {\n      try {\n        await exec('agent-browser --version');\n        return { status: 'pass', message: 'Installed' };\n      } catch {\n        return {\n          status: 'fail',\n          message: 'Not installed',\n          fixHint: 'Run: bun add -g agent-browser'\n        };\n      }\n    }\n  },\n  {\n    name: 'Playwright browsers',\n    check: async () =\u003e { /* Check chromium installed */ }\n  },\n  {\n    name: 'Configuration',\n    check: async () =\u003e {\n      if (!exists('browserflow.yaml')) {\n        return {\n          status: 'fail',\n          message: 'No browserflow.yaml',\n          fixHint: 'Run: bf init'\n        };\n      }\n      // Validate config\n      return { status: 'pass', message: 'Valid' };\n    }\n  },\n  {\n    name: 'Review port',\n    check: async () =\u003e {\n      const port = config.review.port;\n      if (await isPortAvailable(port)) {\n        return { status: 'pass', message: \\`Port \\${port} available\\` };\n      }\n      return {\n        status: 'warn',\n        message: \\`Port \\${port} in use\\`,\n        fixHint: 'Change review.port in browserflow.yaml'\n      };\n    }\n  }\n];\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf doctor\n\nBrowserFlow Doctor\n\n  ✓ Node.js version      v20.10.0\n  ✓ agent-browser        v0.5.0\n  ✗ Playwright browsers  Not installed\n    → Run: bunx playwright install chromium\n  ✓ Configuration        Valid\n  ⚠ Review port          8190 in use\n    → Change review.port in browserflow.yaml\n\n2 passed, 1 warning, 1 failed\n\nRun bf doctor --fix to attempt automatic fixes.\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Checks Node.js version (\u003e=18)\n- [ ] Checks agent-browser installation\n- [ ] Checks Playwright browsers\n- [ ] Validates browserflow.yaml\n- [ ] Checks review port availability\n- [ ] Provides actionable fix hints\n- [ ] --fix attempts automatic fixes where possible\n- [ ] Exit code reflects worst status","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:39.936745969-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:39.389924087-05:00","closed_at":"2026-01-15T21:59:39.389924087-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-2un","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:14.976740866-05:00","created_by":"ubuntu"}]}
{"id":"bf-32b","title":"J.1: Write getting started guide","description":"# Task: Write Getting Started Guide\n\n## Context\nThe getting started guide is the first documentation new users see. It must enable zero-to-first-test in under 10 minutes.\n\n## What to Build\n\\`\\`\\`markdown\n# Getting Started with BrowserFlow\n\n## Installation\n\n\\`\\`\\`bash\n# Install globally\nbun add -g browserflow\n\n# Install Playwright browsers\nbunx playwright install chromium\n\\`\\`\\`\n\n## Quick Start\n\n### 1. Initialize Your Project\n\n\\`\\`\\`bash\ncd your-web-app\nbf init --example\n\\`\\`\\`\n\n### 2. Check Your Setup\n\n\\`\\`\\`bash\nbf doctor\n\\`\\`\\`\n\n### 3. Write Your First Spec\n\n\\`\\`\\`yaml\n# specs/homepage.yaml\nversion: 2\nname: homepage-test\ndescription: Verify homepage loads correctly\n\nsteps:\n  - id: visit_home\n    action: navigate\n    to: /\n    \n  - id: check_title\n    action: expect\n    checks:\n      - visible:\n          target: { css: \"h1\" }\n\\`\\`\\`\n\n### 4. Validate Your Spec\n\n\\`\\`\\`bash\nbf lint\n\\`\\`\\`\n\n### 5. Run Exploration\n\n\\`\\`\\`bash\n# Start your app first\nbun run dev\n\n# Then explore\nbf explore --spec homepage-test --url http://localhost:3000\n\\`\\`\\`\n\n### 6. Review \u0026 Approve\n\n\\`\\`\\`bash\nbf review --spec homepage-test\n\\`\\`\\`\n\n### 7. Generate Test\n\n\\`\\`\\`bash\nbf generate --spec homepage-test\n\\`\\`\\`\n\n### 8. Run Test\n\n\\`\\`\\`bash\nbf run --spec homepage-test\n\\`\\`\\`\n\n## What's Next?\n\n- [Configuration Guide](./configuration.md)\n- [Spec Format Reference](./spec-format.md)\n- [CI Integration](./ci-integration.md)\n\\`\\`\\`\n\n## Structure\n- Installation (30 seconds)\n- Quick start (5 minutes)\n- What's next (links to deeper docs)\n\n## Acceptance Criteria\n- [ ] New user can follow guide successfully\n- [ ] All commands work as documented\n- [ ] Links to deeper documentation\n- [ ] Troubleshooting section for common issues","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-15T17:46:24.087472502-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:25:15.073456989-05:00","closed_at":"2026-01-15T23:25:15.073456989-05:00","close_reason":"Documentation completed: getting started guide and CI templates","dependencies":[{"issue_id":"bf-32b","depends_on_id":"bf-jlm","type":"blocks","created_at":"2026-01-15T17:47:17.051788758-05:00","created_by":"ubuntu"}]}
{"id":"bf-5t1","title":"B.5: Implement CLI output utilities","description":"# Task: Implement CLI Output Utilities\n\n## Context\nPremium CLI UX requires consistent formatting, colors, spinners, and prompts. This task creates reusable utilities for all commands.\n\n## What to Build\n\n### Colors (ui/colors.ts)\n\\`\\`\\`typescript\nimport chalk from 'chalk';\n\nexport const colors = {\n  success: chalk.green,\n  error: chalk.red,\n  warn: chalk.yellow,\n  info: chalk.blue,\n  dim: chalk.gray,\n  bold: chalk.bold,\n  \n  // Semantic\n  pass: chalk.green('✓'),\n  fail: chalk.red('✗'),\n  pending: chalk.yellow('○'),\n  arrow: chalk.cyan('→'),\n};\n\\`\\`\\`\n\n### Spinner (ui/spinner.ts)\n\\`\\`\\`typescript\nimport ora from 'ora';\n\nexport function createSpinner(text: string) {\n  return ora({\n    text,\n    color: 'cyan',\n    spinner: 'dots'\n  });\n}\n\n// Usage:\nconst spinner = createSpinner('Exploring...');\nspinner.start();\n// ... work ...\nspinner.succeed('Exploration complete');\n\\`\\`\\`\n\n### Box Output (ui/box.ts)\n\\`\\`\\`typescript\nexport function printBox(title: string, content: string[]) {\n  const width = 60;\n  console.log('┌' + '─'.repeat(width) + '┐');\n  console.log('│ ' + title.padEnd(width - 1) + '│');\n  console.log('├' + '─'.repeat(width) + '┤');\n  for (const line of content) {\n    console.log('│ ' + line.padEnd(width - 1) + '│');\n  }\n  console.log('└' + '─'.repeat(width) + '┘');\n}\n\\`\\`\\`\n\n### JSON Mode (ui/output.ts)\n\\`\\`\\`typescript\nlet jsonMode = false;\n\nexport function setJsonMode(enabled: boolean) {\n  jsonMode = enabled;\n}\n\nexport function output(data: unknown) {\n  if (jsonMode) {\n    console.log(JSON.stringify(data, null, 2));\n  } else {\n    // Pretty print for humans\n  }\n}\n\\`\\`\\`\n\n### Next Steps Helper\n\\`\\`\\`typescript\nexport function printNextSteps(steps: string[]) {\n  console.log('');\n  console.log(colors.bold('Next steps:'));\n  for (const step of steps) {\n    console.log(\\`  \\${colors.arrow} \\${step}\\`);\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Consistent color scheme across all commands\n- [ ] Spinners for long-running operations\n- [ ] --json flag outputs parseable JSON\n- [ ] Box formatting for summaries\n- [ ] \"Next steps\" suggestions after every command\n- [ ] Works in CI (no TTY) without breaking","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:41:12.545342411-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:24:10.921842148-05:00","closed_at":"2026-01-15T22:24:10.921842148-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-5t1","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:15.244266432-05:00","created_by":"ubuntu"}]}
{"id":"bf-661","title":"C.4: Implement locator candidate generator","description":"# Task: Implement Locator Candidate Generator\n\n## Context\nFor each target element found during exploration, we generate multiple locator strategies. These become the options reviewers choose from when locking the preferred locator.\n\n## What to Build\n\\`\\`\\`typescript\nimport { Locator, ElementHandle } from 'playwright-core';\n\ninterface LocatorCandidate {\n  strategy: LocatorStrategy;\n  confidence: number;      // 0-1, how stable/reliable\n  match_count: number;     // How many elements match\n  screenshot_crop?: string; // Path to cropped image of element\n}\n\nexport async function generateCandidates(\n  element: Locator,\n  page: Page\n): Promise\u003cLocatorCandidate[]\u003e {\n  const candidates: LocatorCandidate[] = [];\n  \n  // Get element properties\n  const handle = await element.elementHandle();\n  const tagName = await handle.evaluate(el =\u003e el.tagName.toLowerCase());\n  const attributes = await getAttributes(handle);\n  const textContent = await element.textContent();\n  const ariaRole = await handle.evaluate(el =\u003e el.getAttribute('role'));\n  const ariaLabel = await handle.evaluate(el =\u003e el.getAttribute('aria-label'));\n  \n  // 1. Try data-testid (highest confidence)\n  for (const attr of ['data-testid', 'data-test', 'data-qa']) {\n    if (attributes[attr]) {\n      candidates.push({\n        strategy: { type: 'testid', value: attributes[attr], attribute: attr },\n        confidence: 0.95,\n        match_count: await countMatches(page, \\`[\\${attr}=\"\\${attributes[attr]}\"]\\`)\n      });\n    }\n  }\n  \n  // 2. Try role + name (high confidence)\n  if (ariaRole || inferRole(tagName)) {\n    const role = ariaRole || inferRole(tagName);\n    const name = ariaLabel || textContent?.trim();\n    if (name) {\n      candidates.push({\n        strategy: { type: 'role', role, name, exact: true },\n        confidence: 0.85,\n        match_count: await countRoleMatches(page, role, name)\n      });\n    }\n  }\n  \n  // 3. Try label (for form elements)\n  const labelText = await findAssociatedLabel(handle);\n  if (labelText) {\n    candidates.push({\n      strategy: { type: 'label', text: labelText },\n      confidence: 0.80,\n      match_count: await countLabelMatches(page, labelText)\n    });\n  }\n  \n  // 4. Try text content (medium confidence)\n  if (textContent \u0026\u0026 textContent.length \u003c 50) {\n    candidates.push({\n      strategy: { type: 'text', text: textContent.trim() },\n      confidence: 0.60,\n      match_count: await countTextMatches(page, textContent)\n    });\n  }\n  \n  // 5. CSS selector (fallback, lowest confidence)\n  const cssSelector = await generateCssSelector(handle);\n  candidates.push({\n    strategy: { type: 'css', selector: cssSelector },\n    confidence: 0.40,\n    match_count: 1  // CSS selectors are usually unique\n  });\n  \n  // Sort by confidence\n  return candidates.sort((a, b) =\u003e b.confidence - a.confidence);\n}\n\\`\\`\\`\n\n## Confidence Scoring\n| Strategy | Base Confidence | Notes |\n|----------|-----------------|-------|\n| testid | 0.95 | Developer-controlled, most stable |\n| role+name | 0.85 | Semantic, survives styling changes |\n| label | 0.80 | User-facing, stable for forms |\n| placeholder | 0.70 | May change with i18n |\n| text | 0.60 | Can change frequently |\n| css | 0.40 | Brittle, last resort |\n\n## Acceptance Criteria\n- [ ] Generates multiple candidates for each element\n- [ ] Candidates ordered by confidence\n- [ ] match_count accurate\n- [ ] CSS fallback always generated\n- [ ] Handles elements without testid gracefully","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:14.459464505-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:00:46.359189234-05:00","closed_at":"2026-01-15T23:00:46.359189234-05:00","close_reason":"Implemented locator candidate generator with all strategies (ref, testid, role, text, css), element matching, confidence scoring. 39 tests pass.","dependencies":[{"issue_id":"bf-661","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.528514424-05:00","created_by":"ubuntu"},{"issue_id":"bf-661","depends_on_id":"bf-c4o","type":"blocks","created_at":"2026-01-15T17:47:15.818262824-05:00","created_by":"ubuntu"}]}
{"id":"bf-6e6","title":"D.3: Implement screenshot viewer with comparison modes","description":"# Task: Implement Screenshot Viewer\n\n## Context\nThe screenshot viewer is the main panel showing before/after screenshots. It supports 4 comparison modes per the spec: side-by-side, slider, blink, and diff.\n\n## What to Build\n\\`\\`\\`typescript\ntype ViewMode = 'side-by-side' | 'slider' | 'blink' | 'diff';\n\ninterface ScreenshotViewerProps {\n  beforeSrc: string;\n  afterSrc: string;\n  diffSrc?: string;\n  mode: ViewMode;\n  onModeChange: (mode: ViewMode) =\u003e void;\n}\n\nexport function ScreenshotViewer({ beforeSrc, afterSrc, diffSrc, mode, onModeChange }: ScreenshotViewerProps) {\n  return (\n    \u003cdiv className=\"flex flex-col h-full\"\u003e\n      {/* Mode selector */}\n      \u003cdiv className=\"flex gap-2 p-2 border-b\"\u003e\n        \u003cButton variant={mode === 'side-by-side' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('side-by-side')}\u003e\n          Side-by-Side\n        \u003c/Button\u003e\n        \u003cButton variant={mode === 'slider' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('slider')}\u003e\n          Slider\n        \u003c/Button\u003e\n        \u003cButton variant={mode === 'blink' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('blink')}\u003e\n          Blink\n        \u003c/Button\u003e\n        {diffSrc \u0026\u0026 (\n          \u003cButton variant={mode === 'diff' ? 'default' : 'outline'} onClick={() =\u003e onModeChange('diff')}\u003e\n            Diff\n          \u003c/Button\u003e\n        )}\n      \u003c/div\u003e\n      \n      {/* Viewer content */}\n      \u003cdiv className=\"flex-1 overflow-auto p-4\"\u003e\n        {mode === 'side-by-side' \u0026\u0026 \u003cSideBySideView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'slider' \u0026\u0026 \u003cSliderView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'blink' \u0026\u0026 \u003cBlinkView before={beforeSrc} after={afterSrc} /\u003e}\n        {mode === 'diff' \u0026\u0026 diffSrc \u0026\u0026 \u003cDiffView baseline={beforeSrc} actual={afterSrc} diff={diffSrc} /\u003e}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Side-by-Side View\n\\`\\`\\`typescript\nfunction SideBySideView({ before, after }) {\n  return (\n    \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e\n      \u003cdiv\u003e\n        \u003cdiv className=\"text-sm font-medium mb-2\"\u003eBefore\u003c/div\u003e\n        \u003cimg src={before} className=\"border rounded\" /\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003cdiv className=\"text-sm font-medium mb-2\"\u003eAfter\u003c/div\u003e\n        \u003cimg src={after} className=\"border rounded\" /\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Slider View\n\\`\\`\\`typescript\nfunction SliderView({ before, after }) {\n  const [position, setPosition] = useState(50);\n  \n  return (\n    \u003cdiv className=\"relative\"\u003e\n      \u003cimg src={after} className=\"w-full\" /\u003e\n      \u003cdiv \n        className=\"absolute top-0 left-0 h-full overflow-hidden\"\n        style={{ width: \\`\\${position}%\\` }}\n      \u003e\n        \u003cimg src={before} className=\"w-full\" style={{ width: \\`\\${100 / position * 100}%\\` }} /\u003e\n      \u003c/div\u003e\n      \u003cinput\n        type=\"range\"\n        min={0}\n        max={100}\n        value={position}\n        onChange={e =\u003e setPosition(Number(e.target.value))}\n        className=\"absolute bottom-4 left-4 right-4\"\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Blink View\n\\`\\`\\`typescript\nfunction BlinkView({ before, after }) {\n  const [showBefore, setShowBefore] = useState(true);\n  \n  useEffect(() =\u003e {\n    const interval = setInterval(() =\u003e setShowBefore(v =\u003e !v), 500);\n    return () =\u003e clearInterval(interval);\n  }, []);\n  \n  return \u003cimg src={showBefore ? before : after} className=\"w-full\" /\u003e;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] All 4 modes implemented\n- [ ] Mode switching is instant\n- [ ] Slider is draggable\n- [ ] Blink speed is comfortable (~500ms)\n- [ ] Diff mode shows highlighted differences\n- [ ] Keyboard shortcuts 1-4 switch modes","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:20.283852437-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.603910726-05:00","closed_at":"2026-01-15T22:02:18.603910726-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-6e6","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.001657599-05:00","created_by":"ubuntu"}]}
{"id":"bf-6ig","title":"A.5: Implement LocatorObject types and resolution","description":"# Task: Implement LocatorObject Types and Resolution\n\n## Context\nThe LocatorObject is the core primitive for deterministic element selection. It replaces brittle agent-browser refs with durable locator strategies that include fallbacks and proof.\n\n## What to Build\n\n### Types\n\\`\\`\\`typescript\ntype LocatorStrategyType = 'testid' | 'role' | 'label' | 'placeholder' | 'text' | 'css';\n\ninterface LocatorStrategy {\n  type: LocatorStrategyType;\n  // For testid\n  value?: string;\n  attribute?: string;  // Default: data-testid\n  // For role\n  role?: string;\n  name?: string;\n  exact?: boolean;  // Default: true\n  // For label/placeholder/text\n  text?: string;\n  // For css\n  selector?: string;\n}\n\ninterface LocatorObject {\n  locator_id: string;\n  preferred: LocatorStrategy;\n  fallbacks: LocatorStrategy[];\n  scoping?: {\n    within?: LocatorStrategy[];\n    nth?: number;\n  };\n  proof: {\n    a11y_role?: string;\n    a11y_name?: string;\n    dom_fingerprint?: {\n      tag: string;\n      classes: string[];\n      attributes?: Record\u003cstring, string\u003e;\n    };\n    bounding_box?: {\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n    };\n  };\n}\n\\`\\`\\`\n\n### Resolution Function\n\\`\\`\\`typescript\nimport { Page, Locator } from 'playwright-core';\n\ninterface ResolveOptions {\n  useFallbacks: boolean;  // false in CI, true in dev\n  timeout?: number;\n}\n\nfunction resolveLocator(\n  locator: LocatorObject,\n  page: Page,\n  options: ResolveOptions\n): Locator;\n\nfunction strategyToLocator(\n  strategy: LocatorStrategy,\n  page: Page\n): Locator;\n\\`\\`\\`\n\n## Resolution Priority (Default)\n1. testid (most stable)\n2. role + name (semantic)\n3. label (form-specific)\n4. placeholder (input-specific)\n5. text (visible content)\n6. css (last resort)\n\n## Scoping Application\n\\`\\`\\`typescript\n// Apply scoping constraints\nlet locator = strategyToLocator(obj.preferred, page);\n\nif (obj.scoping?.within) {\n  for (const scope of obj.scoping.within) {\n    locator = strategyToLocator(scope, page).locator(locator);\n  }\n}\n\nif (obj.scoping?.nth !== undefined) {\n  locator = locator.nth(obj.scoping.nth);\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Types match spec section 7\n- [ ] Zod schema validates LocatorObject correctly\n- [ ] Resolution works with Playwright Page\n- [ ] Scoping (within, nth) applied correctly\n- [ ] Fallback iteration works when useFallbacks=true","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:08.345477155-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.065088631-05:00","closed_at":"2026-01-15T22:27:55.065088631-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-6ig","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.52288281-05:00","created_by":"ubuntu"}]}
{"id":"bf-6yr","title":"Epic C: Exploration Engine","description":"# Epic C: Exploration Engine\n\n## Strategic Context\n\nThe exploration engine is where **AI meets browser automation**. This is the \"magic\" that differentiates BrowserFlow from traditional test frameworks. We use AI to interpret intent-first specs and turn them into actionable test evidence.\n\n## Why This Matters\n\n**Key insight from the spec:** Exploration produces **evidence + candidates**, not final truth.\n\nThe AI might:\n- Click the wrong element\n- Miss timing windows  \n- Misinterpret ambiguous specs\n- Discover incomplete specs\n\nThis is OK because **human review** comes next. The exploration engine's job is to:\n1. Make a best effort at each step\n2. Collect rich evidence (screenshots, trace, timing)\n3. Generate multiple locator candidates per target\n4. Document what it tried and what happened\n\n## Deliverables\n\n1. **@browserflow/exploration package**\n2. **Explorer orchestrator** - Drives browser through spec steps\n3. **Step executor** - Maps action types to agent-browser calls:\n   - click, fill, type, select, check\n   - navigate, back, forward, reload\n   - wait (element, text, url, load_state, function)\n   - expect (assertions)\n   - screenshot, scroll, press\n4. **Evidence collector**:\n   - Before/after screenshots per step\n   - Trace recording (Playwright trace)\n   - Console/network error capture\n   - Timing information\n5. **Locator candidate generator**:\n   - Inspects DOM for testid, role, label, etc.\n   - Ranks candidates by stability\n   - Records confidence scores\n6. **Claude adapter** - Implements AIAdapter interface\n\n## Acceptance Criteria\n\n- [ ] Exploration produces valid exploration.json\n- [ ] Screenshots exist for all steps with screenshot config\n- [ ] Locator candidates include testid, role, css strategies\n- [ ] Trace files are valid Playwright traces\n- [ ] Console/network errors are captured\n- [ ] Duration per step is recorded\n- [ ] Handles step failures gracefully (continues exploration)\n\n## Dependencies\n\n- **Depends on Epic A** - Core types, schemas\n- **Depends on Epic B** - CLI structure (bf explore command)\n\n## Technical Decisions\n\n**Why agent-browser as library (not CLI)?**\n- Direct access to Playwright primitives\n- No JSON serialization overhead\n- Better error handling\n- Type safety throughout\n\n**agent-browser ref system lifecycle:**\n\\`\\`\\`\nExploration time:\n  agent-browser ref (@e1)\n    ↓\n  { selector: \"getByRole('button', {name: 'Add'})\", ... }\n    ↓\nLockfile (durable):\n  LocatorObject { preferred, fallbacks, proof }\n    ↓\nGenerated test (deterministic):\n  page.getByTestId('add-to-cart')\n\\`\\`\\`\n\n**Handling ambiguity:**\nWhen \\`query:\\` maps to multiple elements:\n1. Record top 3-5 candidates with confidence\n2. Include screenshot crops of each candidate\n3. Review UI forces human to lock the intended one\n\n## Integration Points\n\n\\`\\`\\`typescript\nimport { BrowserManager } from 'agent-browser';\nimport { getEnhancedSnapshot } from 'agent-browser/snapshot';\n\nasync function exploreStep(step, browser) {\n  const snapshot = await browser.getSnapshot({ interactive: true });\n  const ref = await aiAgent.findElement(step.target, snapshot);\n  const locator = browser.getLocatorFromRef(ref);\n  await executeAction(step.action, locator);\n  const candidates = await generateLocatorCandidates(locator);\n  return { ref, candidates };\n}\n\\`\\`\\`\n\n## Risk Factors\n\n- AI interpretation variance (mitigated by human review)\n- agent-browser API stability\n- Complex sites may confuse element detection\n\n## Related Spec Sections\n\n- Section 8: Exploration Phase\n- Section 16: AI Adapter Interface\n- Section 17: agent-browser Integration","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:29.936909824-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.72344913-05:00","closed_at":"2026-01-16T17:18:41.72344913-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-6yr","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:46:59.887770987-05:00","created_by":"ubuntu"},{"issue_id":"bf-6yr","depends_on_id":"bf-p8r","type":"blocks","created_at":"2026-01-15T17:46:59.970834144-05:00","created_by":"ubuntu"}]}
{"id":"bf-71k","title":"Epic A: Core Infrastructure","description":"# Epic A: Core Infrastructure\n\n## Strategic Context\n\nThis is the **foundational epic** upon which all of BrowserFlow depends. Nothing else can proceed until we have a solid TypeScript monorepo with shared types, schemas, and core utilities.\n\n## Why This Matters\n\nBrowserFlow's architecture decision to use a **bun monorepo** with separate packages enables:\n1. **Clean separation of concerns** - Each package has a single responsibility\n2. **Independent testing** - Packages can be tested in isolation\n3. **Incremental adoption** - Users could theoretically use just parts\n4. **Type safety across boundaries** - Shared types prevent drift\n\nThe **Zod schemas** are critical because:\n- They provide runtime validation (specs, configs)\n- They generate TypeScript types automatically\n- They can export JSON Schema for IDE validation\n- They document the data model in code\n\n## Deliverables\n\n1. **Monorepo structure** with bun workspaces\n2. **@browserflow/core package** with:\n   - Spec v2 Zod schema\n   - LocatorObject types and resolution logic\n   - Lockfile types\n   - Duration string parser (handles \"3s\", \"2m\", \"500ms\", etc.)\n   - Run store for immutable run directories\n   - Configuration types\n3. **JSON Schema exports** for IDE validation\n4. **TypeScript configuration** with proper paths and references\n\n## Acceptance Criteria\n\n- [ ] \\`bun install\\` succeeds at repo root\n- [ ] \\`bun run build\\` compiles all packages\n- [ ] Duration parsing handles ms/s/m/h and combinations like \"1m30s\"\n- [ ] Run directories are created immutably (never overwrite)\n- [ ] Zod schemas validate example specs correctly\n- [ ] JSON Schemas export and validate in VS Code\n\n## Dependencies\n\nNone - this is the foundation everything else builds on.\n\n## Technical Decisions\n\n**Why Bun over npm/yarn/pnpm?**\n- Faster installs (important for CI)\n- Native workspace support\n- Better TypeScript/ESM handling\n- Single lockfile (bun.lockb)\n\n**Why Zod over JSON Schema directly?**\n- TypeScript-first: types derived from schemas\n- Better DX for schema composition\n- Runtime validation built-in\n- Can still export to JSON Schema\n\n## Risk Factors\n\n- Bun is newer; may have edge cases\n- Monorepo complexity can slow initial development\n- Schema design errors are expensive to fix later\n\n## Related Spec Sections\n\n- Section 6: Spec YAML v2 Schema\n- Section 7: Locator Object Model\n- Section 15: Configuration\n- Section 18: Architecture \u0026 Monorepo Structure\n- Appendix C: Duration String Format","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:33:45.400622533-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.709930872-05:00","closed_at":"2026-01-16T17:18:41.709930872-05:00","close_reason":"All tasks completed"}
{"id":"bf-7do","title":"C.2: Implement exploration orchestrator","description":"# Task: Implement Exploration Orchestrator\n\n## Context\nThe Explorer class orchestrates the entire exploration: initializing browser, executing steps, collecting evidence, and producing exploration.json.\n\n## What to Build\n\\`\\`\\`typescript\nimport { BrowserManager } from 'agent-browser';\nimport { Spec, ExplorationOutput, ExplorationStep } from '@browserflow/core';\n\nexport class Explorer {\n  private browser: BrowserManager;\n  private adapter: AIAdapter;\n  private runDir: string;\n  \n  constructor(options: ExplorerOptions) {\n    this.browser = new BrowserManager();\n    this.adapter = options.adapter;\n  }\n  \n  async explore(spec: Spec): Promise\u003cExplorationOutput\u003e {\n    const startTime = Date.now();\n    const steps: ExplorationStep[] = [];\n    \n    try {\n      // 1. Launch browser\n      await this.browser.launch({\n        headless: this.options.headless,\n        viewport: spec.preconditions?.viewport || this.options.viewport\n      });\n      \n      // 2. Navigate to starting page\n      const baseUrl = spec.base_url || this.options.baseUrl;\n      const startPage = spec.preconditions?.page || '/';\n      await this.browser.navigate(\\`\\${baseUrl}\\${startPage}\\`);\n      \n      // 3. Execute each step\n      for (const step of spec.steps) {\n        const result = await this.executeStep(step);\n        steps.push(result);\n        \n        if (result.execution.status === 'failed') {\n          // Continue exploration but mark as failed\n        }\n      }\n      \n      // 4. Build output\n      return {\n        run_id: this.runId,\n        spec_name: spec.name,\n        spec_hash: hashSpec(spec),\n        app_context: this.getAppContext(),\n        steps,\n        status: steps.every(s =\u003e s.execution.status === 'completed') \n          ? 'completed' : 'failed',\n        duration_ms: Date.now() - startTime,\n        errors: []\n      };\n    } finally {\n      await this.browser.close();\n    }\n  }\n  \n  private async executeStep(step: SpecStep): Promise\u003cExplorationStep\u003e {\n    // Delegate to StepExecutor\n  }\n}\n\\`\\`\\`\n\n## Key Behaviors\n1. **Graceful failure handling** - Continue on step failure, mark overall as failed\n2. **Evidence collection** - Screenshots before/after each action\n3. **Timing capture** - Duration per step\n4. **Context preservation** - Save browser state info\n\n## Acceptance Criteria\n- [ ] Can run exploration for a valid spec\n- [ ] Produces valid exploration.json\n- [ ] Handles step failures gracefully (continues)\n- [ ] Collects timing information\n- [ ] Cleans up browser on completion/error","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:39.033215682-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:37.386920955-05:00","closed_at":"2026-01-15T21:59:37.386920955-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-7do","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.334526496-05:00","created_by":"ubuntu"}]}
{"id":"bf-8k4","title":"D.1: Create @browserflow/review-ui package with React + Vite","description":"# Task: Create Review UI Package\n\n## Context\nThe Review UI is a React SPA for human review of explorations. It uses Vite for fast development, Tailwind for styling, and shadcn/ui for premium components.\n\n## What to Build\n\\`\\`\\`\npackages/review-ui/\n├── src/\n│   ├── main.tsx           # Entry point\n│   ├── App.tsx            # Root component\n│   ├── components/        # UI components\n│   ├── hooks/             # Custom hooks\n│   ├── lib/               # Utilities\n│   └── styles/\n│       └── globals.css    # Tailwind imports\n├── index.html\n├── package.json\n├── tsconfig.json\n├── vite.config.ts\n├── tailwind.config.js\n└── postcss.config.js\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/review-ui\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.20.0\",\n    \"@radix-ui/react-*\": \"...\",\n    \"class-variance-authority\": \"^0.7.0\",\n    \"clsx\": \"^2.0.0\",\n    \"tailwind-merge\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@vitejs/plugin-react\": \"^4.2.0\",\n    \"tailwindcss\": \"^3.4.0\",\n    \"autoprefixer\": \"^10.4.0\",\n    \"postcss\": \"^8.4.0\",\n    \"vite\": \"^5.0.0\"\n  }\n}\n\\`\\`\\`\n\n## vite.config.ts\n\\`\\`\\`typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  build: {\n    outDir: 'dist',\n    // For embedding in CLI\n    rollupOptions: {\n      output: {\n        manualChunks: undefined,\n      },\n    },\n  },\n});\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bun run dev\\` starts Vite dev server\n- [ ] \\`bun run build\\` produces static assets\n- [ ] Tailwind CSS works\n- [ ] shadcn/ui components available\n- [ ] Can be served by CLI package","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:46.873878559-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:31:58.140222329-05:00","closed_at":"2026-01-15T21:31:58.140222329-05:00","close_reason":"Closed"}
{"id":"bf-920","title":"D.4: Implement locator picker component","description":"# Task: Implement Locator Picker Component\n\n## Context\nThe locator picker shows locator candidates from exploration and lets reviewers lock the preferred strategy. This is critical for deterministic test generation.\n\n## What to Build\n\\`\\`\\`typescript\ninterface LocatorPickerProps {\n  candidates: LocatorCandidate[];\n  currentLocator?: LocatorObject;\n  onLockLocator: (locator: LocatorObject) =\u003e void;\n}\n\nexport function LocatorPicker({ candidates, currentLocator, onLockLocator }: LocatorPickerProps) {\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  \n  return (\n    \u003cdiv className=\"space-y-4\"\u003e\n      \u003cdiv className=\"flex justify-between items-center\"\u003e\n        \u003ch3 className=\"font-semibold\"\u003eLocator\u003c/h3\u003e\n        \u003cBadge variant={currentLocator ? 'default' : 'outline'}\u003e\n          {currentLocator ? 'Locked' : 'Not locked'}\n        \u003c/Badge\u003e\n      \u003c/div\u003e\n      \n      {/* Current locked locator */}\n      {currentLocator \u0026\u0026 (\n        \u003cdiv className=\"p-3 bg-green-50 border border-green-200 rounded\"\u003e\n          \u003cdiv className=\"text-sm font-medium text-green-800\"\u003ePreferred\u003c/div\u003e\n          \u003ccode className=\"text-xs\"\u003e{formatStrategy(currentLocator.preferred)}\u003c/code\u003e\n        \u003c/div\u003e\n      )}\n      \n      {/* Candidate list */}\n      \u003cdiv className=\"space-y-2\"\u003e\n        {candidates.map((candidate, index) =\u003e (\n          \u003cCandidateRow\n            key={index}\n            candidate={candidate}\n            isSelected={index === selectedIndex}\n            onClick={() =\u003e setSelectedIndex(index)}\n            onLock={() =\u003e onLockLocator(candidateToLocator(candidate))}\n          /\u003e\n        ))}\n      \u003c/div\u003e\n      \n      {/* Lock button */}\n      \u003cButton onClick={() =\u003e onLockLocator(candidateToLocator(candidates[selectedIndex]))}\u003e\n        Lock Selected as Preferred\n      \u003c/Button\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction CandidateRow({ candidate, isSelected, onClick, onLock }) {\n  return (\n    \u003cdiv\n      className={cn(\n        \"p-3 border rounded cursor-pointer\",\n        isSelected \u0026\u0026 \"border-blue-500 bg-blue-50\"\n      )}\n      onClick={onClick}\n    \u003e\n      \u003cdiv className=\"flex justify-between items-start\"\u003e\n        \u003cdiv\u003e\n          \u003cBadge variant=\"secondary\"\u003e{candidate.strategy.type}\u003c/Badge\u003e\n          \u003ccode className=\"ml-2 text-sm\"\u003e{formatStrategy(candidate.strategy)}\u003c/code\u003e\n        \u003c/div\u003e\n        \u003cdiv className=\"text-right\"\u003e\n          \u003cdiv className=\"text-sm\"\u003e{Math.round(candidate.confidence * 100)}% confidence\u003c/div\u003e\n          \u003cdiv className=\"text-xs text-muted-foreground\"\u003e\n            {candidate.match_count} match{candidate.match_count !== 1 ? 'es' : ''}\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction formatStrategy(strategy: LocatorStrategy): string {\n  switch (strategy.type) {\n    case 'testid':\n      return \\`[data-testid=\"\\${strategy.value}\"]\\`;\n    case 'role':\n      return \\`getByRole('\\${strategy.role}', { name: '\\${strategy.name}' })\\`;\n    case 'label':\n      return \\`getByLabel('\\${strategy.text}')\\`;\n    case 'css':\n      return strategy.selector;\n    default:\n      return JSON.stringify(strategy);\n  }\n}\n\\`\\`\\`\n\n## Features\n- Shows all candidates ranked by confidence\n- Displays confidence % and match count\n- Highlights selected candidate\n- One-click lock to preferred\n- Shows currently locked locator\n\n## Acceptance Criteria\n- [ ] All candidates displayed with confidence\n- [ ] Can select and lock a candidate\n- [ ] Locked state persists to lockfile\n- [ ] Shows testid/role/css in readable format\n- [ ] 'l' keyboard shortcut focuses picker","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:43:36.871668569-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:02:18.605376438-05:00","closed_at":"2026-01-15T22:02:18.605376438-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-920","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.10335248-05:00","created_by":"ubuntu"}]}
{"id":"bf-92j","title":"A.6: Implement run store (immutable directories)","description":"# Task: Implement Run Store\n\n## Context\nEvery exploration creates an immutable run directory. The run store manages creating these directories, maintaining \"latest\" symlinks, and ensuring runs are never overwritten.\n\n## Why Immutability Matters\n- Can diff between runs to see what changed\n- History preserved for debugging\n- No accidental data loss from re-exploration\n- Audit trail for compliance\n\n## What to Build\n\\`\\`\\`typescript\ninterface RunStore {\n  // Create new run directory, returns path\n  createRun(specName: string): Promise\u003cstring\u003e;\n  \n  // Get path to latest run for spec (or null)\n  getLatestRun(specName: string): string | null;\n  \n  // List all runs for a spec, newest first\n  listRuns(specName: string): string[];\n  \n  // Get full path to specific run\n  getRunDir(specName: string, runId: string): string;\n  \n  // Check if run exists\n  runExists(specName: string, runId: string): boolean;\n}\n\\`\\`\\`\n\n## Directory Structure\n\\`\\`\\`\n.browserflow/\n├── runs/\n│   └── checkout-cart/\n│       ├── run-20260115-031000-abc123/\n│       │   ├── exploration.json\n│       │   ├── review.json\n│       │   ├── lockfile.json\n│       │   └── artifacts/\n│       │       ├── screenshots/\n│       │       ├── trace.zip\n│       │       └── logs/\n│       ├── run-20260115-041500-def456/\n│       │   └── ...\n│       └── latest -\u003e run-20260115-041500-def456\n├── cache/\n└── tmp/\n\\`\\`\\`\n\n## Run ID Generation\n\\`\\`\\`typescript\nimport crypto from 'crypto';\n\nfunction createRunId(): string {\n  const now = new Date();\n  const ts = now.toISOString()\n    .replace(/[-:T]/g, '')\n    .slice(0, 14);  // YYYYMMDDHHMMSS\n  const rand = crypto.randomBytes(3).toString('hex');\n  return \\`run-\\${ts}-\\${rand}\\`;\n}\n// Example: run-20260115031000-a3f2dd\n\\`\\`\\`\n\n## Platform Considerations\n- Unix/Mac: Use symlinks for \"latest\"\n- Windows: Use junctions (fs.symlink with 'junction' type)\n- Handle race conditions in concurrent creation\n\n## Acceptance Criteria\n- [ ] Run directories never overwritten\n- [ ] \"latest\" symlink updated atomically on new run\n- [ ] Multiple runs for same spec coexist\n- [ ] Works on Windows (junctions) and Unix (symlinks)\n- [ ] Race conditions handled safely","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:24.298164687-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.06649772-05:00","closed_at":"2026-01-15T22:27:55.06649772-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-92j","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.616991847-05:00","created_by":"ubuntu"}]}
{"id":"bf-9ei","title":"Epic D: Review UI v1","description":"# Epic D: Review UI v1 (Core)\n\n## Strategic Context\n\nThe Review UI is where BrowserFlow becomes **premium**. This is the human gate where intent becomes deterministic. The spec calls for \"Stripe-level experience: fast, opinionated, polished, keyboard-driven.\"\n\nv1 focuses on **core review workflow**. v2 (Epic H) adds polish features like mask editor and assertion builder.\n\n## Why This Matters\n\n**Review is the quality gate.** No test gets codified without human sign-off.\n\nThe UI must make it **fast and pleasant** to:\n- Approve correct steps\n- Reject problematic steps with feedback\n- Lock the right locator from candidates\n- Understand what the AI did\n\nIf review is painful, people skip it. If people skip review, tests are unreliable.\n\n## Deliverables\n\n1. **@browserflow/review-ui package** (React SPA)\n2. **Step timeline** with thumbnails and status chips\n3. **Screenshot viewer** with 4 modes:\n   - Side-by-side\n   - Slider wipe\n   - Blink A/B\n   - Diff overlay\n4. **Approve/reject workflow** per step\n5. **Locator picker** - Show candidates, lock preferred\n6. **Comment and tag fields**\n7. **Keyboard shortcuts** (j/k navigate, a/approve, r/reject)\n8. **CLI server** to serve UI and handle API\n9. **review.json output** - Human decisions\n10. **lockfile.json output** - Resolved locators for generation\n\n## Acceptance Criteria\n\n- [ ] Reviewer can approve/reject all steps\n- [ ] Keyboard navigation works (j/k/a/r)\n- [ ] Screenshot comparison modes all functional\n- [ ] Locator locking persists to lockfile\n- [ ] Comments persist across sessions\n- [ ] Review produces valid review.json and lockfile.json\n- [ ] UI is responsive and doesn't feel janky\n- [ ] Light/dark mode support (stretch)\n\n## Dependencies\n\n- **Depends on Epic A** - Core types for lockfile, locators\n- **Depends on Epic C** - Exploration output to review\n\n## Technical Decisions\n\n**Why React + Tailwind + shadcn/ui?**\n- React: Rich component ecosystem, good state management\n- Tailwind: Rapid iteration, consistent design tokens\n- shadcn/ui: Premium components, accessible, customizable\n\n**Information Architecture:**\n\\`\\`\\`\n┌─────────────┬───────────────────────────────────┬───────────────────┐\n│   STEPS     │         MAIN PANEL                │    INSPECTOR      │\n│  (timeline) │   (screenshot viewer)             │  (locators, etc)  │\n└─────────────┴───────────────────────────────────┴───────────────────┘\n\\`\\`\\`\n\n**Keyboard shortcuts (from spec):**\n| Key | Action |\n|-----|--------|\n| j/↓ | Next step |\n| k/↑ | Previous step |\n| a | Approve |\n| r | Reject |\n| 1-4 | Screenshot view modes |\n| Ctrl+S | Submit review |\n\n## User Journey\n\n\\`\\`\\`\nbf explore --spec checkout-cart\n    ↓\nbf review --spec checkout-cart\n    ↓\nBrowser opens to http://localhost:8190/review/checkout-cart/run-xxx\n    ↓\nUser sees step timeline, clicks through\n    ↓\nUser approves most steps, rejects one with comment\n    ↓\nUser locks preferred locator for ambiguous step\n    ↓\nUser clicks \"Submit Review\"\n    ↓\nlockfile.json created, ready for generation\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 9: Review Phase\n- Section 10: Generation Phase (lockfile is input)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:53.772351054-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.726677699-05:00","closed_at":"2026-01-16T17:18:41.726677699-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-9ei","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:47:00.074525905-05:00","created_by":"ubuntu"},{"issue_id":"bf-9ei","depends_on_id":"bf-6yr","type":"blocks","created_at":"2026-01-15T17:47:00.158681822-05:00","created_by":"ubuntu"}]}
{"id":"bf-aak","title":"A.7: Implement lockfile types","description":"# Task: Implement Lockfile Types\n\n## Context\nThe lockfile is the canonical source for code generation. It contains all resolved locators, masks, and assertions from human review. Generation reads ONLY from the lockfile - never from raw exploration output.\n\n## What to Build\n\\`\\`\\`typescript\ninterface Lockfile {\n  // Identification\n  run_id: string;\n  spec_name: string;\n  spec_hash: string;  // SHA256 of spec file at review time\n  created_at: string; // ISO8601\n  \n  // Resolved locators (keyed by step_id or locator_id)\n  locators: Record\u003cstring, LocatorObject\u003e;\n  \n  // Masks for screenshots (keyed by screenshot name)\n  masks: Record\u003cstring, Mask[]\u003e;\n  \n  // Assertions (from review)\n  assertions: Assertion[];\n  \n  // Generation metadata\n  generation: {\n    format: 'playwright-ts';\n    output_path: string;\n    generated_at?: string;\n  };\n}\n\ninterface Mask {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  reason: string;  // Why this region is masked\n  locator?: string; // Optional: derived from element locator\n}\n\ninterface Assertion {\n  id: string;\n  type: AssertionType;\n  target?: LocatorObject;\n  expected?: string | number | boolean;\n  step_id?: string;  // If attached to specific step\n}\n\ntype AssertionType = \n  | 'visible'\n  | 'hidden'\n  | 'text_contains'\n  | 'text_equals'\n  | 'url_contains'\n  | 'url_matches'\n  | 'count'\n  | 'attribute'\n  | 'checked'\n  | 'screenshot';\n\\`\\`\\`\n\n## File Operations\n\\`\\`\\`typescript\nfunction readLockfile(runDir: string): Promise\u003cLockfile\u003e;\nfunction writeLockfile(runDir: string, lockfile: Lockfile): Promise\u003cvoid\u003e;\nfunction validateLockfile(lockfile: unknown): lockfile is Lockfile;\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Types match spec section 9.8\n- [ ] Zod schema validates lockfiles\n- [ ] Read/write functions handle file I/O\n- [ ] Missing optional fields handled gracefully\n- [ ] spec_hash computed consistently","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:39:37.901866983-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.067870267-05:00","closed_at":"2026-01-15T22:27:55.067870267-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-aak","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.707499783-05:00","created_by":"ubuntu"}]}
{"id":"bf-apb","title":"D.5: Implement keyboard shortcuts","description":"# Task: Implement Keyboard Shortcuts\n\n## Context\nPremium UX requires keyboard-driven workflows. The Review UI should be fully navigable via keyboard shortcuts per spec section 9.3.\n\n## What to Build\n\\`\\`\\`typescript\nimport { useHotkeys } from 'react-hotkeys-hook';\n\nexport function useReviewKeyboardShortcuts(handlers: ReviewHandlers) {\n  // Navigation\n  useHotkeys('j', handlers.nextStep, { description: 'Next step' });\n  useHotkeys('down', handlers.nextStep);\n  useHotkeys('k', handlers.prevStep, { description: 'Previous step' });\n  useHotkeys('up', handlers.prevStep);\n  \n  // Review actions\n  useHotkeys('a', handlers.approveStep, { description: 'Approve current step' });\n  useHotkeys('r', handlers.rejectStep, { description: 'Reject current step' });\n  \n  // UI actions\n  useHotkeys('m', handlers.addMask, { description: 'Add mask' });\n  useHotkeys('l', handlers.focusLocatorPicker, { description: 'Lock locator' });\n  useHotkeys('e', handlers.addAssertion, { description: 'Add assertion' });\n  useHotkeys('c', handlers.focusComment, { description: 'Focus comment field' });\n  \n  // View modes\n  useHotkeys('1', () =\u003e handlers.setViewMode('side-by-side'));\n  useHotkeys('2', () =\u003e handlers.setViewMode('slider'));\n  useHotkeys('3', () =\u003e handlers.setViewMode('blink'));\n  useHotkeys('4', () =\u003e handlers.setViewMode('diff'));\n  \n  // Search\n  useHotkeys('/', handlers.openSearch, { description: 'Search steps' });\n  \n  // Submit\n  useHotkeys('mod+s', handlers.submitReview, { description: 'Submit review' });\n  \n  // Help\n  useHotkeys('mod+?', handlers.showHelp, { description: 'Show shortcuts' });\n  useHotkeys('escape', handlers.closeModal);\n}\n\\`\\`\\`\n\n## Shortcuts Reference (from Spec)\n| Key | Action |\n|-----|--------|\n| j / ↓ | Next step |\n| k / ↑ | Previous step |\n| a | Approve current step |\n| r | Reject current step |\n| m | Add mask |\n| l | Lock locator |\n| e | Add assertion |\n| c | Focus comment field |\n| / | Search steps |\n| 1-4 | Screenshot view modes |\n| Ctrl+S | Submit review |\n| Ctrl+? | Show keyboard shortcuts |\n| Escape | Close modal/cancel |\n\n## Help Modal\n\\`\\`\\`typescript\nexport function KeyboardShortcutsHelp() {\n  return (\n    \u003cDialog\u003e\n      \u003cDialogContent\u003e\n        \u003cDialogHeader\u003e\n          \u003cDialogTitle\u003eKeyboard Shortcuts\u003c/DialogTitle\u003e\n        \u003c/DialogHeader\u003e\n        \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e\n          {shortcuts.map(({ key, description }) =\u003e (\n            \u003cdiv key={key} className=\"flex justify-between\"\u003e\n              \u003cspan\u003e{description}\u003c/span\u003e\n              \u003ckbd className=\"px-2 py-1 bg-muted rounded\"\u003e{key}\u003c/kbd\u003e\n            \u003c/div\u003e\n          ))}\n        \u003c/div\u003e\n      \u003c/DialogContent\u003e\n    \u003c/Dialog\u003e\n  );\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] All shortcuts from spec work\n- [ ] j/k navigate steps\n- [ ] a/r approve/reject\n- [ ] 1-4 switch view modes\n- [ ] Ctrl+S submits review\n- [ ] Help modal shows all shortcuts\n- [ ] Shortcuts don't interfere with text input","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:43:53.418823572-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:01:38.105103396-05:00","closed_at":"2026-01-15T23:01:38.105103396-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-apb","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.208286605-05:00","created_by":"ubuntu"}]}
{"id":"bf-b3g","title":"Epic G: Baseline Management","description":"# Epic G: Baseline Management\n\n## Strategic Context\n\nBaselines are the \"golden\" screenshots that visual regression tests compare against. Managing them properly is critical - **baselines should never update implicitly**.\n\n## Why This Matters\n\n**Explicit baseline acceptance** prevents:\n- Accidental regression acceptance\n- Confusion about what changed\n- Lost context on why images differ\n\nThe workflow must be:\n1. Test fails with visual diff\n2. Developer reviews diff (intentional change or bug?)\n3. If intentional: explicit \\`bf baseline accept\\`\n4. If bug: fix code, re-run\n\n## Deliverables\n\n1. **bf baseline commands**:\n   - \\`status\\` - Show baseline state for spec\n   - \\`diff\\` - Open diff gallery in Review UI\n   - \\`accept\\` - Accept new baselines (explicit)\n   - \\`update\\` - Convenience alias for accept from latest\n2. **Baseline diff gallery** in Review UI:\n   - Side-by-side baseline/actual/diff\n   - Accept/reject per screenshot\n   - Batch accept option\n3. **Acceptance metadata**:\n   - Who accepted\n   - When\n   - From which run\n   - Previous hash\n4. **Per-priority fail policy**:\n   - Critical/high: fail CI on diff\n   - Normal/low: warn only\n\n## Acceptance Criteria\n\n- [ ] Baselines never update without explicit command\n- [ ] \\`bf baseline diff\\` shows visual comparison\n- [ ] Acceptance includes reviewer and timestamp\n- [ ] Per-priority policy controls work\n- [ ] Metadata stored for audit trail\n- [ ] Works with multiple screenshots per spec\n\n## Dependencies\n\n- **Depends on Epic D** - Review UI for diff gallery\n- **Depends on Epic F** - Runner produces diffs\n\n## Technical Decisions\n\n**Baseline storage:**\n\\`\\`\\`\nbaselines/\n└── checkout-cart/\n    ├── cart-with-item.png\n    └── checkout-confirmation.png\n\\`\\`\\`\n\n**Metadata storage** (.browserflow/baseline-meta.json):\n\\`\\`\\`json\n{\n  \"baselines/checkout-cart/cart-with-item.png\": {\n    \"accepted_at\": \"2026-01-15T03:25:00Z\",\n    \"accepted_by\": \"alex\",\n    \"run_id\": \"run-xxx\",\n    \"previous_hash\": \"sha256:abc...\",\n    \"current_hash\": \"sha256:def...\",\n    \"reason\": \"Updated cart design\"\n  }\n}\n\\`\\`\\`\n\n**Priority-based policies** (from config):\n\\`\\`\\`yaml\nvisual:\n  fail_on_diff_by_priority:\n    critical: true   # Fail CI\n    high: true       # Fail CI\n    normal: false    # Warn only\n    low: false       # Warn only\n\\`\\`\\`\n\n## User Flow\n\n\\`\\`\\`\nTest fails with screenshot diff\n    ↓\nbf baseline diff --spec checkout-cart\n    ↓\nReview UI opens with baseline/actual/diff gallery\n    ↓\nUser reviews: \"This is intentional, we updated the cart design\"\n    ↓\nbf baseline accept --spec checkout-cart\n    ↓\nBaseline updated, metadata recorded\n    ↓\nRe-run passes\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 13: Baseline Management\n- Section 15: Configuration (visual settings)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:35:57.11800074-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.734612739-05:00","closed_at":"2026-01-16T17:18:41.734612739-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-b3g","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.524645102-05:00","created_by":"ubuntu"},{"issue_id":"bf-b3g","depends_on_id":"bf-xx5","type":"blocks","created_at":"2026-01-15T17:47:00.610530233-05:00","created_by":"ubuntu"}]}
{"id":"bf-bcv","title":"Epic H: Review UI v2 (Polish)","description":"# Epic H: Review UI v2 (Polish Features)\n\n## Strategic Context\n\nThis epic adds **premium features** to the Review UI that differentiate BrowserFlow from basic test tools. The mask editor and assertion builder turn review from \"just approval\" into \"active test refinement.\"\n\n## Why This Matters\n\n**\"Stripe-level review experience\"** means:\n- Users don't just approve/reject\n- They can refine tests without editing YAML\n- Dynamic content is handled elegantly (masks)\n- Missing assertions are easily added\n\nThese features reduce friction between \"test works\" and \"test is robust.\"\n\n## Deliverables\n\n1. **Mask editor** (canvas-based):\n   - Draw rectangle masks\n   - Click-to-mask from locator\n   - Resize/move existing masks\n   - Delete masks\n   - Reason field per mask\n2. **Assertion builder**:\n   - Add assertions without YAML editing\n   - Types: visible, hidden, text_contains, url_contains, etc.\n   - Attach to step or expected_outcomes\n3. **Evidence drawer**:\n   - Console errors (expandable)\n   - Network failures (expandable)\n   - Timing breakdown\n4. **Repair panel** (for Epic I):\n   - Show failure context\n   - Display fix suggestions\n   - Apply/reject buttons\n5. **UI polish**:\n   - Loading states\n   - Error boundaries\n   - Smooth animations\n   - Responsive design\n\n## Acceptance Criteria\n\n- [ ] Masks can be drawn, moved, resized, deleted\n- [ ] Click-to-mask works from element locator\n- [ ] Assertions can be added without editing YAML\n- [ ] Evidence drawer shows console/network info\n- [ ] Repair panel displays fix suggestions\n- [ ] No jank during interactions\n- [ ] Keyboard shortcuts for mask/assertion (m, e)\n\n## Dependencies\n\n- **Depends on Epic D** - Base Review UI\n- **Depends on Epic G** - Baseline diff gallery integration\n\n## Technical Decisions\n\n**Mask editor implementation:**\n- Use HTML5 Canvas for drawing\n- Store masks as array of { x, y, width, height, reason }\n- Persist to lockfile.json\n- Pass to Playwright's \\`mask\\` option\n\n**Assertion builder:**\n\\`\\`\\`typescript\ninterface Assertion {\n  id: string;\n  type: 'visible' | 'hidden' | 'text_contains' | 'url_contains' | ...;\n  target?: LocatorObject;\n  expected?: string;\n  step_id?: string;  // If attached to specific step\n}\n\\`\\`\\`\n\n**Evidence drawer:**\n- Collapsed by default (not overwhelming)\n- Shows counts: \"3 console errors, 1 network failure\"\n- Click to expand and see details\n\n## Premium UX Details\n\n**Mask editor interactions:**\n1. Click \"Add Mask\" button (or press 'm')\n2. Draw rectangle on screenshot\n3. Fill in reason: \"Dynamic timestamp\"\n4. Mask appears with translucent overlay\n5. Can resize via corner handles\n6. Can delete via 'x' button or Delete key\n\n**Assertion builder flow:**\n1. Click \"Add Assertion\" (or press 'e')\n2. Select type from dropdown\n3. If needs target: click element or enter locator\n4. If needs value: enter expected text\n5. Assertion added to step or global outcomes\n\n## Related Spec Sections\n\n- Section 9: Review Phase (9.5 Mask Editor, 9.6 Assertion Builder)\n- Section 10.3: Visual Regression Generation (masks)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:36:17.528898171-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.736988039-05:00","closed_at":"2026-01-16T17:18:41.736988039-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-bcv","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.70840866-05:00","created_by":"ubuntu"},{"issue_id":"bf-bcv","depends_on_id":"bf-b3g","type":"blocks","created_at":"2026-01-15T17:47:00.803013512-05:00","created_by":"ubuntu"}]}
{"id":"bf-bvs","title":"E.1: Create @browserflow/generator package","description":"# Task: Create Generator Package\n\n## Context\nThe generator package converts lockfiles into deterministic Playwright Test code. No AI involved - pure code generation.\n\n## What to Build\n\\`\\`\\`\npackages/generator/\n├── src/\n│   ├── index.ts              # Public exports\n│   ├── playwright-ts.ts      # TypeScript test generator\n│   ├── locator-emit.ts       # LocatorObject → Playwright code\n│   ├── visual-checks.ts      # Screenshot assertion generation\n│   └── config-emit.ts        # playwright.config.ts generation\n├── templates/\n│   ├── test.ts.hbs           # Test file template\n│   └── config.ts.hbs         # Config template\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/generator\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"handlebars\": \"^4.7.8\"\n  }\n}\n\\`\\`\\`\n\n## Main Export\n\\`\\`\\`typescript\nexport { PlaywrightGenerator } from './playwright-ts';\nexport { generateLocatorCode } from './locator-emit';\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles\n- [ ] Can generate test file from lockfile\n- [ ] Templates render correctly\n- [ ] Exports accessible from CLI","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:04.524259127-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:36:51.171886241-05:00","closed_at":"2026-01-15T21:36:51.171886241-05:00","close_reason":"Implemented @browserflow/generator package with PlaywrightGenerator, locator-emit, visual-checks, config-emit, and Handlebars templates"}
{"id":"bf-bwv","title":"Epic I: Repair Mode","description":"# Epic I: Repair Mode\n\n## Strategic Context\n\nRepair mode is what makes BrowserFlow **maintainable at scale**. E2E tests are notorious for breaking with UI changes. Instead of \"fix or delete\", BrowserFlow offers \"repair and move on.\"\n\n## Why This Matters\n\n**\"First-class maintainability\"** is a product goal.\n\nWhen tests break, developers typically:\n1. Spend hours debugging why\n2. Manually update selectors\n3. Re-run, discover more breaks\n4. Eventually give up and delete tests\n\nRepair mode changes this to:\n1. \\`bf repair --spec X\\`\n2. See failure context + suggested fixes\n3. Approve fix\n4. Done\n\nThis keeps test suites alive and valuable.\n\n## Deliverables\n\n1. **bf repair command**:\n   - \\`--spec X\\` - Repair specific spec (uses latest failure)\n   - \\`--from-run \u003cpath\u003e\\` - Repair from specific failure bundle\n   - \\`--ai\\` - Enable AI-assisted repair proposals\n   - \\`--apply\\` - Auto-apply suggested fixes\n   - \\`--headed\\` - Show browser during repair\n2. **Deterministic fix analysis**:\n   - Try fallback locators\n   - Increase timeout by 2x\n   - Suggest mask for changed region\n   - Show actual vs expected for assertions\n3. **AI repair proposals** (optional):\n   - Re-run failing step in headed mode\n   - AI inspects current DOM\n   - Proposes new locator/assertion/mask\n4. **Repair UI panel** in Review app:\n   - Show failure context\n   - Display fix options\n   - Apply/skip buttons\n5. **Patch application**:\n   - Update lockfile\n   - Regenerate test\n   - Run verification\n\n## Acceptance Criteria\n\n- [ ] \\`bf repair\\` loads failure bundle correctly\n- [ ] Deterministic fixes work (fallbacks, timeout)\n- [ ] AI proposals work when --ai flag provided\n- [ ] Human approval required before applying\n- [ ] Repaired tests pass verification run\n- [ ] repair_patch.json documents what changed\n\n## Dependencies\n\n- **Depends on Epic F** - Failure bundles\n- **Depends on Epic H** - Repair panel in Review UI\n- **Depends on Epic E** - Regenerate tests after repair\n\n## Technical Decisions\n\n**Repair flow:**\n\\`\\`\\`\n1. Load failure bundle + spec + lockfile\n2. Analyze failure type:\n   - locator_not_found → try fallbacks\n   - timeout → increase timeout\n   - screenshot_diff → suggest baseline update or mask\n   - assertion_failed → show actual vs expected\n3. Generate deterministic suggestions\n4. (If --ai) Run AI for additional proposals\n5. Open repair UI for human approval\n6. Apply approved changes to lockfile\n7. Regenerate test\n8. Run verification\n\\`\\`\\`\n\n**Deterministic vs AI fixes:**\n- Deterministic: always try first, no tokens\n- AI: only when --ai flag, costs tokens\n\n**Patch format:**\n\\`\\`\\`json\n{\n  \"run_id\": \"repair-xxx\",\n  \"original_run_id\": \"run-yyy\",\n  \"changes\": [\n    {\n      \"type\": \"locator_update\",\n      \"step_id\": \"add_product\",\n      \"before\": { \"preferred\": { \"type\": \"testid\", \"value\": \"old-id\" } },\n      \"after\": { \"preferred\": { \"type\": \"testid\", \"value\": \"new-id\" } },\n      \"reason\": \"Element testid changed\"\n    }\n  ]\n}\n\\`\\`\\`\n\n## User Journey\n\n\\`\\`\\`\nCI fails: checkout-cart\n    ↓\nDeveloper downloads failure bundle (or uses local)\n    ↓\nbf repair --spec checkout-cart\n    ↓\nCLI: \"Analyzing failure...\"\nCLI: \"Found: locator_not_found at step add_product\"\nCLI: \"Suggestion: Use fallback role locator (confidence: 0.9)\"\nCLI: \"Opening repair UI...\"\n    ↓\nRepair UI shows:\n  - Original locator that failed\n  - Suggested replacement\n  - Screenshot context\n    ↓\nDeveloper clicks \"Apply Fix\"\n    ↓\nCLI: \"Updating lockfile...\"\nCLI: \"Regenerating test...\"\nCLI: \"Running verification...\"\nCLI: \"✓ Test passes!\"\n    ↓\ngit add \u0026\u0026 git commit -m \"fix: update add_product locator\"\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 12: Repair Mode\n- Section 11.5: Failure Bundle Schema","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:36:41.549869761-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.739553842-05:00","closed_at":"2026-01-16T17:18:41.739553842-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-bwv","depends_on_id":"bf-xx5","type":"blocks","created_at":"2026-01-15T17:47:00.901983045-05:00","created_by":"ubuntu"},{"issue_id":"bf-bwv","depends_on_id":"bf-bcv","type":"blocks","created_at":"2026-01-15T17:47:00.988222239-05:00","created_by":"ubuntu"},{"issue_id":"bf-bwv","depends_on_id":"bf-u2n","type":"blocks","created_at":"2026-01-15T17:47:01.076049025-05:00","created_by":"ubuntu"}]}
{"id":"bf-c4o","title":"C.3: Implement step executor","description":"# Task: Implement Step Executor\n\n## Context\nThe step executor maps spec action types to actual browser operations using agent-browser.\n\n## What to Build\n\\`\\`\\`typescript\nexport class StepExecutor {\n  constructor(private browser: BrowserManager, private adapter: AIAdapter) {}\n  \n  async execute(step: SpecStep): Promise\u003cStepResult\u003e {\n    switch (step.action) {\n      case 'navigate':\n        return this.executeNavigate(step);\n      case 'click':\n        return this.executeClick(step);\n      case 'fill':\n        return this.executeFill(step);\n      case 'type':\n        return this.executeType(step);\n      case 'wait':\n        return this.executeWait(step);\n      case 'expect':\n        return this.executeExpect(step);\n      case 'screenshot':\n        return this.executeScreenshot(step);\n      case 'select':\n        return this.executeSelect(step);\n      case 'check':\n        return this.executeCheck(step);\n      case 'press':\n        return this.executePress(step);\n      case 'scroll':\n        return this.executeScroll(step);\n      // ... etc\n    }\n  }\n  \n  private async executeClick(step: ClickStep): Promise\u003cStepResult\u003e {\n    // 1. Resolve target to element\n    const { ref, locator } = await this.resolveTarget(step.target);\n    \n    // 2. Take before screenshot if configured\n    let beforeScreenshot: string | undefined;\n    if (step.screenshot?.before) {\n      beforeScreenshot = await this.captureScreenshot(\\`\\${step.id}-before\\`);\n    }\n    \n    // 3. Perform click\n    await locator.click({\n      button: step.button || 'left',\n      clickCount: step.click_count || 1\n    });\n    \n    // 4. Take after screenshot\n    let afterScreenshot: string | undefined;\n    if (step.screenshot?.after) {\n      afterScreenshot = await this.captureScreenshot(\\`\\${step.id}-after\\`);\n    }\n    \n    // 5. Generate locator candidates\n    const candidates = await this.generateCandidates(locator);\n    \n    return {\n      status: 'completed',\n      ref_used: ref,\n      screenshots: { before: beforeScreenshot, after: afterScreenshot },\n      candidates\n    };\n  }\n  \n  private async resolveTarget(target: Target): Promise\u003cResolvedTarget\u003e {\n    if (target.query) {\n      // Use AI to find element from natural language\n      return this.adapter.findElement(target.query, await this.browser.getSnapshot());\n    }\n    // Use explicit locator strategy\n    return this.resolveExplicitTarget(target);\n  }\n}\n\\`\\`\\`\n\n## Action Types to Implement\n- **Navigation:** navigate, back, forward, reload\n- **Interaction:** click, fill, type, select, check, press, upload\n- **Waiting:** wait (element, text, url, load_state, function)\n- **Assertions:** expect (visible, hidden, text_contains, etc.)\n- **Capture:** screenshot, scroll, scroll_into_view\n\n## Acceptance Criteria\n- [ ] All action types from spec section 6.4 implemented\n- [ ] Screenshots captured when configured\n- [ ] Target resolution works for query and explicit strategies\n- [ ] Error handling returns failed status with message\n- [ ] Locator candidates generated for target-based actions","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:55.084471671-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:53.026436312-05:00","closed_at":"2026-01-15T22:27:53.026436312-05:00","close_reason":"Implemented step executor with all action types. 44 tests pass.","dependencies":[{"issue_id":"bf-c4o","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.425755433-05:00","created_by":"ubuntu"},{"issue_id":"bf-c4o","depends_on_id":"bf-7do","type":"blocks","created_at":"2026-01-15T17:47:15.721589777-05:00","created_by":"ubuntu"}]}
{"id":"bf-cds","title":"A.2: Create @browserflow/core package structure","description":"# Task: Create Core Package Structure\n\n## Context\nThe core package holds shared types, schemas, and utilities used by all other packages. It's the dependency foundation - every other package imports from @browserflow/core.\n\n## What to Build\n\\`\\`\\`\npackages/core/\n├── src/\n│   ├── index.ts          # Public exports\n│   ├── spec-schema.ts    # Zod schemas for spec v2\n│   ├── locator-object.ts # LocatorObject types + resolution\n│   ├── lockfile.ts       # Lockfile types\n│   ├── duration.ts       # Duration string parser\n│   ├── run-store.ts      # Immutable run directory management\n│   └── config.ts         # Configuration types\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/core\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": \"./dist/index.js\",\n    \"./schemas\": \"./dist/spec-schema.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"vitest\"\n  },\n  \"dependencies\": {\n    \"zod\": \"^3.22.4\"\n  }\n}\n\\`\\`\\`\n\n## tsconfig.json\n\\`\\`\\`json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles with \\`bun run build\\`\n- [ ] Exports are accessible: \\`import { specSchema } from '@browserflow/core'\\`\n- [ ] Types are properly generated in dist/\n- [ ] Can be used as dependency in other workspace packages","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:18.906965459-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:57:46.716458245-05:00","closed_at":"2026-01-15T21:57:46.716458245-05:00","close_reason":"Created core package structure with modular file layout, zod schemas, and proper exports","dependencies":[{"issue_id":"bf-cds","depends_on_id":"bf-0fe","type":"blocks","created_at":"2026-01-15T17:47:14.25629364-05:00","created_by":"ubuntu"}]}
{"id":"bf-cim","title":"H.1: Implement mask editor component","description":"# Task: Implement Mask Editor Component\n\n## Context\nThe mask editor lets reviewers draw rectangles over dynamic regions (timestamps, ads, user avatars) that should be excluded from visual comparison.\n\n## What to Build\n\\`\\`\\`typescript\ninterface MaskEditorProps {\n  imageSrc: string;\n  masks: Mask[];\n  onMasksChange: (masks: Mask[]) =\u003e void;\n}\n\ninterface Mask {\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  reason: string;\n}\n\nexport function MaskEditor({ imageSrc, masks, onMasksChange }: MaskEditorProps) {\n  const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);\n  const [drawing, setDrawing] = useState(false);\n  const [currentRect, setCurrentRect] = useState\u003cRect | null\u003e(null);\n  const [selectedMask, setSelectedMask] = useState\u003cstring | null\u003e(null);\n  \n  // Handle mouse events for drawing\n  const handleMouseDown = (e: React.MouseEvent) =\u003e {\n    const rect = canvasRef.current.getBoundingClientRect();\n    setDrawing(true);\n    setCurrentRect({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n      width: 0,\n      height: 0\n    });\n  };\n  \n  const handleMouseMove = (e: React.MouseEvent) =\u003e {\n    if (!drawing || !currentRect) return;\n    const rect = canvasRef.current.getBoundingClientRect();\n    setCurrentRect({\n      ...currentRect,\n      width: e.clientX - rect.left - currentRect.x,\n      height: e.clientY - rect.top - currentRect.y\n    });\n  };\n  \n  const handleMouseUp = () =\u003e {\n    if (currentRect \u0026\u0026 currentRect.width \u003e 10 \u0026\u0026 currentRect.height \u003e 10) {\n      // Prompt for reason\n      const reason = prompt('Why is this region masked?');\n      if (reason) {\n        onMasksChange([...masks, {\n          id: crypto.randomUUID(),\n          ...normalizeRect(currentRect),\n          reason\n        }]);\n      }\n    }\n    setDrawing(false);\n    setCurrentRect(null);\n  };\n  \n  // Render masks with resize handles\n  return (\n    \u003cdiv className=\"relative\"\u003e\n      \u003cimg src={imageSrc} className=\"pointer-events-none\" /\u003e\n      \u003ccanvas\n        ref={canvasRef}\n        className=\"absolute top-0 left-0 w-full h-full\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n      /\u003e\n      \n      {/* Render existing masks */}\n      {masks.map(mask =\u003e (\n        \u003cMaskOverlay\n          key={mask.id}\n          mask={mask}\n          isSelected={selectedMask === mask.id}\n          onSelect={() =\u003e setSelectedMask(mask.id)}\n          onResize={(newRect) =\u003e updateMask(mask.id, newRect)}\n          onDelete={() =\u003e deleteMask(mask.id)}\n        /\u003e\n      ))}\n      \n      {/* Current drawing rect */}\n      {currentRect \u0026\u0026 (\n        \u003cdiv\n          className=\"absolute border-2 border-dashed border-blue-500 bg-blue-500/20\"\n          style={{\n            left: currentRect.x,\n            top: currentRect.y,\n            width: currentRect.width,\n            height: currentRect.height\n          }}\n        /\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n## Features\n- Draw rectangles by click+drag\n- Resize via corner handles\n- Delete via Delete key or button\n- Reason field for each mask\n- Visual feedback (translucent overlay)\n\n## Acceptance Criteria\n- [ ] Can draw new mask rectangles\n- [ ] Can resize existing masks\n- [ ] Can delete masks\n- [ ] Reason prompt on creation\n- [ ] Masks saved to lockfile\n- [ ] 'm' shortcut enters mask mode","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:45:49.698982228-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:59:38.799032649-05:00","closed_at":"2026-01-15T22:59:38.799032649-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-cim","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.867677689-05:00","created_by":"ubuntu"}]}
{"id":"bf-cv6","title":"A.8: Export JSON Schemas for IDE validation","description":"# Task: Export JSON Schemas for IDE Validation\n\n## Context\nJSON Schemas enable IDE features like autocomplete, inline validation, and documentation for YAML specs and config files. This dramatically improves DX.\n\n## What to Build\n\\`\\`\\`\nschemas/\n├── spec-v2.schema.json       # Spec YAML validation\n├── browserflow.schema.json   # Config file validation\n├── lockfile.schema.json      # Lockfile validation\n└── exploration.schema.json   # Exploration output validation\n\\`\\`\\`\n\n## Generation from Zod\n\\`\\`\\`typescript\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { specSchema, configSchema, lockfileSchema } from '@browserflow/core';\nimport fs from 'fs/promises';\n\nasync function generateSchemas() {\n  const schemas = {\n    'spec-v2': zodToJsonSchema(specSchema, 'spec-v2'),\n    'browserflow': zodToJsonSchema(configSchema, 'browserflow'),\n    'lockfile': zodToJsonSchema(lockfileSchema, 'lockfile'),\n  };\n  \n  for (const [name, schema] of Object.entries(schemas)) {\n    await fs.writeFile(\n      \\`schemas/\\${name}.schema.json\\`,\n      JSON.stringify(schema, null, 2)\n    );\n  }\n}\n\\`\\`\\`\n\n## VS Code Integration\nUsers add to YAML files:\n\\`\\`\\`yaml\n# yaml-language-server: \\$schema=./node_modules/browserflow/schemas/spec-v2.schema.json\nversion: 2\nname: my-test\n\\`\\`\\`\n\nOr in .vscode/settings.json:\n\\`\\`\\`json\n{\n  \"yaml.schemas\": {\n    \"./node_modules/browserflow/schemas/spec-v2.schema.json\": \"specs/*.yaml\",\n    \"./node_modules/browserflow/schemas/browserflow.schema.json\": \"browserflow.yaml\"\n  }\n}\n\\`\\`\\`\n\n## npm Package Inclusion\n\\`\\`\\`json\n{\n  \"files\": [\n    \"dist\",\n    \"schemas\"\n  ]\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] JSON Schemas generated from Zod schemas\n- [ ] Schemas validate correctly in VS Code YAML extension\n- [ ] Schemas included in npm package distribution\n- [ ] Documentation shows how to enable in VS Code/other IDEs\n- [ ] Build script regenerates schemas on change","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:39:51.999251205-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:01:12.636495129-05:00","closed_at":"2026-01-15T23:01:12.636495129-05:00","close_reason":"Implemented JSON schema generation from Zod schemas with VS Code integration docs","dependencies":[{"issue_id":"bf-cv6","depends_on_id":"bf-dgs","type":"blocks","created_at":"2026-01-15T17:47:14.796437963-05:00","created_by":"ubuntu"}]}
{"id":"bf-dcs","title":"F.2: Implement failure bundle generation","description":"# Task: Implement Failure Bundle Generation\n\n## Context\nWhen tests fail, BrowserFlow creates failure bundles containing everything needed for debugging and repair. These bundles are the input to \\`bf repair\\`.\n\n## What to Build\n\\`\\`\\`typescript\ninterface FailureBundle {\n  run_id: string;\n  spec_name: string;\n  failed_at: string;  // ISO8601\n  \n  failure: {\n    step_id: string;\n    action: string;\n    error_message: string;\n    error_type: 'locator_not_found' | 'timeout' | 'assertion_failed' | 'screenshot_diff' | 'unknown';\n  };\n  \n  context: {\n    url: string;\n    viewport: { width: number; height: number };\n    browser: string;\n  };\n  \n  artifacts: {\n    trace?: string;      // Path to trace.zip\n    video?: string;      // Path to video\n    screenshot?: string; // Path to failure screenshot\n    diff?: {\n      baseline: string;\n      actual: string;\n      diff: string;\n    };\n    console_log?: string;\n    network_log?: string;\n  };\n  \n  suggestions?: RepairSuggestion[];\n}\n\nasync function generateFailureBundle(\n  runDir: string,\n  failure: TestFailure,\n  playwrightArtifacts: string\n): Promise\u003cstring\u003e {\n  const bundleDir = path.join(runDir, 'artifacts');\n  \n  // 1. Copy trace file\n  const tracePath = await findTrace(playwrightArtifacts);\n  if (tracePath) {\n    await copyFile(tracePath, path.join(bundleDir, 'trace.zip'));\n  }\n  \n  // 2. Copy failure screenshot\n  const screenshotPath = await findFailureScreenshot(playwrightArtifacts);\n  if (screenshotPath) {\n    await copyFile(screenshotPath, path.join(bundleDir, 'screenshots', 'failure.png'));\n  }\n  \n  // 3. Copy diff images if screenshot failure\n  if (failure.type === 'screenshot_diff') {\n    await copyDiffImages(playwrightArtifacts, bundleDir);\n  }\n  \n  // 4. Extract console/network logs from trace\n  const logs = await extractLogsFromTrace(path.join(bundleDir, 'trace.zip'));\n  await writeJson(path.join(bundleDir, 'logs', 'console.json'), logs.console);\n  await writeJson(path.join(bundleDir, 'logs', 'network.json'), logs.network);\n  \n  // 5. Generate repair suggestions\n  const suggestions = generateRepairSuggestions(failure);\n  \n  // 6. Write failure.json\n  const bundle: FailureBundle = {\n    run_id: path.basename(runDir),\n    spec_name: failure.specName,\n    failed_at: new Date().toISOString(),\n    failure: {\n      step_id: failure.stepId,\n      action: failure.action,\n      error_message: failure.message,\n      error_type: classifyError(failure.message)\n    },\n    context: failure.context,\n    artifacts: { ... },\n    suggestions\n  };\n  \n  const bundlePath = path.join(runDir, 'failure.json');\n  await writeJson(bundlePath, bundle);\n  \n  return bundlePath;\n}\n\\`\\`\\`\n\n## Error Classification\n| Pattern | Error Type |\n|---------|------------|\n| \"locator resolved to N elements\" | locator_not_found |\n| \"Timeout\" | timeout |\n| \"expect\" failures | assertion_failed |\n| \"Screenshot comparison\" | screenshot_diff |\n| Other | unknown |\n\n## Acceptance Criteria\n- [ ] Failure bundle contains trace, screenshots, logs\n- [ ] failure.json is machine-readable\n- [ ] Error type classified correctly\n- [ ] Diff images included for visual failures\n- [ ] Repair suggestions generated","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:45:14.88553056-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:23:29.690977512-05:00","closed_at":"2026-01-15T22:23:29.690977512-05:00","close_reason":"Implemented failure bundle generation with: error classification, artifact collection (trace, screenshots, diff images), log extraction placeholders, repair suggestions, and comprehensive tests","dependencies":[{"issue_id":"bf-dcs","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:16.577203829-05:00","created_by":"ubuntu"}]}
{"id":"bf-dgs","title":"A.3: Implement spec v2 Zod schema","description":"# Task: Implement Spec v2 Zod Schema\n\n## Context\nThe spec schema validates YAML test specifications at runtime. It must be comprehensive enough to catch errors early with actionable messages, but flexible enough to support all documented spec features.\n\n## What to Build\nZod schemas covering:\n- Top-level spec fields (version, name, description, steps, etc.)\n- Target object (query, testid, role, label, css, within, nth)\n- All action types from spec section 6.4\n- Duration string validation\n- Preconditions (page, auth, viewport, mocks)\n- Expected outcomes\n\n## Key Schema Patterns\n\\`\\`\\`typescript\n// Duration validation\nconst durationSchema = z.string().regex(\n  /^(\\d+(ms|s|m|h))+$/,\n  'Must be duration string like \"3s\", \"2m\", \"500ms\"'\n);\n\n// Target - at least one strategy required\nconst targetSchema = z.object({\n  query: z.string().optional(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  name: z.string().optional(),\n  label: z.string().optional(),\n  placeholder: z.string().optional(),\n  text: z.string().optional(),\n  css: z.string().optional(),\n  within: z.lazy(() =\u003e targetSchema).optional(),\n  nth: z.number().int().optional(),\n}).refine(\n  data =\u003e data.query || data.testid || data.role || data.label || data.css || data.text,\n  'Target must have at least one locator strategy'\n);\n\n// Step - id is REQUIRED\nconst stepSchema = z.object({\n  id: z.string().min(1, 'Step id is required'),\n  action: z.enum(['click', 'fill', 'navigate', 'wait', 'expect', ...]),\n  target: targetSchema.optional(),\n  // ... action-specific fields via discriminated union\n});\n\n// Top-level spec\nconst specSchema = z.object({\n  version: z.literal(2),\n  name: z.string().regex(/^[a-z0-9-]+$/, 'Name must be kebab-case'),\n  description: z.string().optional(),\n  steps: z.array(stepSchema).min(1, 'At least one step required'),\n  timeout: durationSchema.optional(),\n  priority: z.enum(['critical', 'high', 'normal', 'low']).optional(),\n  tags: z.array(z.string()).optional(),\n  preconditions: preconditionsSchema.optional(),\n  expected_outcomes: z.array(outcomeSchema).optional(),\n}).refine(\n  data =\u003e {\n    const ids = data.steps.map(s =\u003e s.id);\n    return new Set(ids).size === ids.length;\n  },\n  'Step IDs must be unique within spec'\n);\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Valid specs pass validation\n- [ ] Invalid specs fail with clear, actionable error messages\n- [ ] All action types from spec section 6.4 covered\n- [ ] Duration strings validated per Appendix C\n- [ ] Step IDs validated for uniqueness\n- [ ] Discriminated unions handle action-specific fields","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:33.257176982-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.062094224-05:00","closed_at":"2026-01-15T22:27:55.062094224-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-dgs","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.347614529-05:00","created_by":"ubuntu"}]}
{"id":"bf-dyj","title":"C.5: Implement Claude adapter","description":"# Task: Implement Claude Adapter\n\n## Context\nThe Claude adapter implements the AIAdapter interface, using Claude to interpret spec steps and find elements from natural language queries.\n\n## What to Build\n\\`\\`\\`typescript\nimport Anthropic from '@anthropic-ai/sdk';\n\nexport interface AIAdapter {\n  name: string;\n  \n  // Find element from natural language query\n  findElement(\n    query: string,\n    snapshot: EnhancedSnapshot\n  ): Promise\u003c{ ref: string; reasoning: string }\u003e;\n  \n  // (Optional) Propose repair for failure\n  proposeRepair?(params: RepairParams): Promise\u003cRepairProposal\u003e;\n}\n\nexport class ClaudeAdapter implements AIAdapter {\n  name = 'claude';\n  private client: Anthropic;\n  \n  constructor() {\n    this.client = new Anthropic();\n  }\n  \n  async findElement(query: string, snapshot: EnhancedSnapshot): Promise\u003c...\u003e {\n    const response = await this.client.messages.create({\n      model: 'claude-sonnet-4-20250514',\n      max_tokens: 1024,\n      system: ELEMENT_FINDER_SYSTEM_PROMPT,\n      messages: [{\n        role: 'user',\n        content: \\`\n          Find the element matching this description: \"\\${query}\"\n          \n          Current page snapshot:\n          \\${snapshot.tree}\n          \n          Available refs: \\${Object.keys(snapshot.refs).join(', ')}\n          \n          Return the ref (e.g., \"e1\") of the best matching element.\n        \\`\n      }]\n    });\n    \n    // Parse response to extract ref\n    const ref = extractRef(response.content[0].text);\n    return { ref, reasoning: response.content[0].text };\n  }\n}\n\nconst ELEMENT_FINDER_SYSTEM_PROMPT = \\`\nYou are helping find UI elements based on natural language descriptions.\nGiven an accessibility snapshot of a web page, identify the element that best matches the user's description.\n\nRules:\n1. Return ONLY the ref (like \"e1\", \"e2\") of the matching element\n2. If multiple elements could match, pick the most likely based on context\n3. If no element matches, say \"NOT_FOUND\" and explain why\n4. Consider the element's role, name, and position in the hierarchy\n\\`;\n\\`\\`\\`\n\n## Tool Use Pattern (Alternative)\n\\`\\`\\`typescript\n// Can also use tool_use for structured output\nconst tools = [{\n  name: 'select_element',\n  description: 'Select an element by its ref',\n  input_schema: {\n    type: 'object',\n    properties: {\n      ref: { type: 'string', description: 'Element ref like e1, e2' },\n      confidence: { type: 'number', description: '0-1 confidence' },\n      reasoning: { type: 'string' }\n    },\n    required: ['ref', 'confidence', 'reasoning']\n  }\n}];\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Implements AIAdapter interface\n- [ ] Uses Claude API correctly\n- [ ] Handles ambiguous queries gracefully\n- [ ] Returns ref + reasoning\n- [ ] Works with agent-browser snapshot format\n- [ ] Respects rate limits","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:42:32.166151615-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:37.388487652-05:00","closed_at":"2026-01-15T21:59:37.388487652-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-dyj","depends_on_id":"bf-o9t","type":"blocks","created_at":"2026-01-15T17:47:15.627977239-05:00","created_by":"ubuntu"}]}
{"id":"bf-eq4","title":"B.4: Implement bf lint command","description":"# Task: Implement bf lint Command\n\n## Context\n\\`bf lint\\` validates spec files against the v2 schema. It catches errors early with actionable messages including line numbers.\n\n## What to Build\n\\`\\`\\`typescript\n// bf lint [options] [files...]\n// Options:\n//   --fix    Auto-fix simple issues (formatting)\n// Arguments:\n//   files    Specific files to lint (default: specs/*.yaml)\n\nimport { parse as parseYaml } from 'yaml';\nimport { specSchema } from '@browserflow/core';\n\nasync function lint(files: string[], options: { fix?: boolean }) {\n  const results: LintResult[] = [];\n  \n  for (const file of files) {\n    const content = await readFile(file, 'utf-8');\n    const parsed = parseYaml(content);\n    \n    const validation = specSchema.safeParse(parsed);\n    \n    if (!validation.success) {\n      results.push({\n        file,\n        errors: validation.error.issues.map(issue =\u003e ({\n          path: issue.path.join('.'),\n          message: issue.message,\n          line: getLineNumber(content, issue.path)\n        }))\n      });\n    }\n  }\n  \n  // Print results\n  for (const result of results) {\n    if (result.errors.length === 0) {\n      console.log(\\`✓ \\${result.file}\\`);\n    } else {\n      console.log(\\`✗ \\${result.file}\\`);\n      for (const error of result.errors) {\n        console.log(\\`  Line \\${error.line}: \\${error.message}\\`);\n        console.log(\\`    at \\${error.path}\\`);\n      }\n    }\n  }\n  \n  return results.some(r =\u003e r.errors.length \u003e 0) ? 1 : 0;\n}\n\\`\\`\\`\n\n## Validation Rules\n1. **Schema compliance** - All fields match Zod schema\n2. **Required fields** - version (must be 2), name, steps\n3. **Step IDs** - All steps have id, no duplicates\n4. **Duration strings** - All timeouts are valid (3s, 2m, etc.)\n5. **Target objects** - At least one locator strategy\n6. **Kebab-case names** - Spec name follows convention\n\n## CLI Output\n\\`\\`\\`\n$ bf lint\n\nLinting specs/*.yaml\n\n✓ specs/checkout-cart.yaml\n✗ specs/login-flow.yaml\n  Line 12: Step id is required\n    at steps.2.id\n  Line 18: Invalid duration \"3000\" - use \"3s\" instead\n    at steps.3.timeout\n✓ specs/homepage.yaml\n\n2 passed, 1 failed (2 errors)\n\\`\\`\\`\n\n## Error Messages (Actionable)\nBad: \"Invalid type\"\nGood: \"Step id is required - add 'id: login_button' to this step\"\n\nBad: \"String expected\"\nGood: \"Invalid duration \\\"3000\\\" - use format like \\\"3s\\\", \\\"2m\\\", or \\\"500ms\\\"\"\n\n## Acceptance Criteria\n- [ ] Validates all specs in specs/ by default\n- [ ] Reports errors with line numbers\n- [ ] Error messages are actionable\n- [ ] Catches missing step IDs\n- [ ] Catches invalid duration strings\n- [ ] Catches duplicate step IDs\n- [ ] Exit code 3 on validation failure (per spec)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:57.8663227-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.441068464-05:00","closed_at":"2026-01-15T23:04:35.441068464-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-eq4","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:15.064940969-05:00","created_by":"ubuntu"},{"issue_id":"bf-eq4","depends_on_id":"bf-dgs","type":"blocks","created_at":"2026-01-15T17:47:15.154771672-05:00","created_by":"ubuntu"}]}
{"id":"bf-gdo","title":"E.3: Implement locator-to-code conversion","description":"# Task: Implement Locator-to-Code Conversion\n\n## Context\nThis utility converts LocatorObject from the lockfile into Playwright locator code. It handles all strategy types and scoping.\n\n## What to Build\n\\`\\`\\`typescript\nimport { LocatorObject, LocatorStrategy } from '@browserflow/core';\n\nexport function generateLocatorCode(\n  locator: LocatorObject,\n  variableName: string = 'page'\n): string {\n  let code = variableName;\n  \n  // 1. Apply scoping (within)\n  if (locator.scoping?.within) {\n    for (const scope of locator.scoping.within) {\n      code = \\`\\${code}.\\${strategyToCode(scope)}\\`;\n    }\n  }\n  \n  // 2. Apply preferred strategy\n  code = \\`\\${code}.\\${strategyToCode(locator.preferred)}\\`;\n  \n  // 3. Apply nth index\n  if (locator.scoping?.nth !== undefined) {\n    const nth = locator.scoping.nth;\n    if (nth === 0) {\n      code = \\`\\${code}.first()\\`;\n    } else if (nth === -1) {\n      code = \\`\\${code}.last()\\`;\n    } else {\n      code = \\`\\${code}.nth(\\${nth})\\`;\n    }\n  }\n  \n  return code;\n}\n\nfunction strategyToCode(strategy: LocatorStrategy): string {\n  switch (strategy.type) {\n    case 'testid':\n      const attr = strategy.attribute || 'data-testid';\n      if (attr === 'data-testid') {\n        return \\`getByTestId('\\${escape(strategy.value)}')\\`;\n      }\n      return \\`locator('[\\${attr}=\"\\${escape(strategy.value)}\"]')\\`;\n      \n    case 'role':\n      const opts: string[] = [];\n      if (strategy.name) {\n        opts.push(\\`name: '\\${escape(strategy.name)}'\\`);\n      }\n      if (strategy.exact !== undefined) {\n        opts.push(\\`exact: \\${strategy.exact}\\`);\n      }\n      const optsStr = opts.length \u003e 0 ? \\`, { \\${opts.join(', ')} }\\` : '';\n      return \\`getByRole('\\${strategy.role}'\\${optsStr})\\`;\n      \n    case 'label':\n      return \\`getByLabel('\\${escape(strategy.text)}')\\`;\n      \n    case 'placeholder':\n      return \\`getByPlaceholder('\\${escape(strategy.text)}')\\`;\n      \n    case 'text':\n      return \\`getByText('\\${escape(strategy.text)}')\\`;\n      \n    case 'css':\n      return \\`locator('\\${escape(strategy.selector)}')\\`;\n      \n    default:\n      throw new Error(\\`Unknown strategy type: \\${(strategy as any).type}\\`);\n  }\n}\n\nfunction escape(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n\\`\\`\\`\n\n## Example Transformations\n\n| LocatorObject | Generated Code |\n|---------------|----------------|\n| \\`{ type: 'testid', value: 'submit' }\\` | \\`page.getByTestId('submit')\\` |\n| \\`{ type: 'role', role: 'button', name: 'Save' }\\` | \\`page.getByRole('button', { name: 'Save' })\\` |\n| \\`{ within: [testid: 'form'], preferred: {role...}, nth: 0 }\\` | \\`page.getByTestId('form').getByRole('button').first()\\` |\n\n## Acceptance Criteria\n- [ ] All strategy types generate valid code\n- [ ] Scoping (within) chains correctly\n- [ ] nth handling correct (first/last/nth)\n- [ ] String escaping prevents injection\n- [ ] Generated code is readable","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:37.419589663-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:04.698707324-05:00","closed_at":"2026-01-15T21:59:04.698707324-05:00","close_reason":"Implemented locator-to-code conversion with nth (first/last/nth) and within (scoping) options. Added 63 comprehensive tests. All acceptance criteria met.","dependencies":[{"issue_id":"bf-gdo","depends_on_id":"bf-bvs","type":"blocks","created_at":"2026-01-15T17:47:16.396175311-05:00","created_by":"ubuntu"}]}
{"id":"bf-h07","title":"E.2: Implement Playwright test generator","description":"# Task: Implement Playwright Test Generator\n\n## Context\nThe main generator that converts a lockfile into a runnable Playwright Test file. This is where determinism is guaranteed - the output should produce identical results every run.\n\n## What to Build\n\\`\\`\\`typescript\nimport { Lockfile, Spec } from '@browserflow/core';\nimport Handlebars from 'handlebars';\n\nexport class PlaywrightGenerator {\n  async generate(spec: Spec, lockfile: Lockfile, outputPath: string): Promise\u003cvoid\u003e {\n    const testCode = this.renderTest(spec, lockfile);\n    await writeFile(outputPath, testCode);\n  }\n  \n  private renderTest(spec: Spec, lockfile: Lockfile): string {\n    const steps = spec.steps.map(step =\u003e ({\n      id: step.id,\n      action: step.action,\n      intent: this.formatIntent(step),\n      code: this.generateStepCode(step, lockfile)\n    }));\n    \n    return testTemplate({\n      spec_name: spec.name,\n      description: spec.description,\n      run_id: lockfile.run_id,\n      generated_at: new Date().toISOString(),\n      preconditions: spec.preconditions,\n      steps,\n      expected_outcomes: spec.expected_outcomes\n    });\n  }\n  \n  private generateStepCode(step: SpecStep, lockfile: Lockfile): string {\n    switch (step.action) {\n      case 'click':\n        return this.generateClick(step, lockfile);\n      case 'fill':\n        return this.generateFill(step, lockfile);\n      case 'navigate':\n        return this.generateNavigate(step);\n      case 'wait':\n        return this.generateWait(step);\n      case 'expect':\n        return this.generateExpect(step, lockfile);\n      case 'screenshot':\n        return this.generateScreenshot(step, lockfile);\n      // ... etc\n    }\n  }\n}\n\\`\\`\\`\n\n## Generated Test Structure\n\\`\\`\\`typescript\n// e2e/tests/checkout-cart.spec.ts\nimport { test, expect } from '@playwright/test';\n\n/**\n * BrowserFlow Generated Test\n * \n * Spec: checkout-cart\n * Run: run-20260115-031000-abc123\n * Generated: 2026-01-15T03:25:00Z\n * \n * WARNING: Do not edit manually.\n * To update: bf generate --spec checkout-cart\n */\n\ntest.describe('checkout-cart', () =\u003e {\n  test('checkout-cart', async ({ page }) =\u003e {\n    // Preconditions\n    await page.goto('/');\n    \n    // ────────────────────────────────────────────────\n    // Step: add_first_product\n    // Intent: Click \"Add to Cart button on first product\"\n    // ────────────────────────────────────────────────\n    await test.step('add_first_product', async () =\u003e {\n      await page.getByTestId('add-to-cart').first().click();\n    });\n    \n    // ... more steps\n  });\n});\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Generates valid TypeScript that compiles\n- [ ] Uses lockfile locators (not exploration refs)\n- [ ] Includes generation metadata in header\n- [ ] test.step() for each spec step\n- [ ] Comments show original intent\n- [ ] Handles all action types","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:20.983571749-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:24:49.426648502-05:00","closed_at":"2026-01-15T22:24:49.426648502-05:00","close_reason":"Implemented test.step() wrapping for Playwright tests with comprehensive test suite (38 tests). All acceptance criteria met.","dependencies":[{"issue_id":"bf-h07","depends_on_id":"bf-bvs","type":"blocks","created_at":"2026-01-15T17:47:16.302574752-05:00","created_by":"ubuntu"},{"issue_id":"bf-h07","depends_on_id":"bf-gdo","type":"blocks","created_at":"2026-01-15T17:47:16.485223169-05:00","created_by":"ubuntu"}]}
{"id":"bf-jlm","title":"B.2: Implement bf init command","description":"# Task: Implement bf init Command\n\n## Context\n\\`bf init\\` is the first command new users run. It creates the project structure and default configuration. This is the onboarding experience.\n\n## What to Build\n\\`\\`\\`typescript\n// bf init [options]\n// Options:\n//   --force     Overwrite existing config\n//   --example   Create example spec\n\nasync function init(options: { force?: boolean; example?: boolean }) {\n  // 1. Create directories\n  await mkdir('specs', { recursive: true });\n  \n  // 2. Create browserflow.yaml (if not exists or --force)\n  if (!exists('browserflow.yaml') || options.force) {\n    await writeFile('browserflow.yaml', DEFAULT_CONFIG);\n  }\n  \n  // 3. Update .gitignore\n  await appendToGitignore(['.browserflow/', 'node_modules/']);\n  \n  // 4. Create example spec (if --example)\n  if (options.example) {\n    await writeFile('specs/example.yaml', EXAMPLE_SPEC);\n  }\n  \n  // 5. Print next steps\n  console.log('BrowserFlow initialized!');\n  console.log('Next steps:');\n  console.log('  1. Edit browserflow.yaml');\n  console.log('  2. Create specs in specs/');\n  console.log('  3. Run: bf explore --spec \u003cname\u003e');\n}\n\\`\\`\\`\n\n## Default Config (browserflow.yaml)\n\\`\\`\\`yaml\nproject:\n  name: my-project\n  base_url: http://localhost:3000\n\nruntime:\n  browser: chromium\n  headless: true\n  viewport:\n    width: 1280\n    height: 720\n  timeout: 30s\n\nlocators:\n  prefer_testid: true\n  testid_attributes:\n    - data-testid\n    - data-test\n\nexploration:\n  adapter: claude\n  max_retries: 3\n\nreview:\n  port: 8190\n  auto_open: true\n\noutput:\n  tests_dir: e2e/tests\n  baselines_dir: baselines\n\\`\\`\\`\n\n## Example Spec (specs/example.yaml)\n\\`\\`\\`yaml\nversion: 2\nname: example\ndescription: Example spec - customize for your app\n\nsteps:\n  - id: visit_home\n    action: navigate\n    to: /\n\n  - id: homepage_screenshot\n    action: screenshot\n    name: homepage\n\ntags:\n  - example\n  - smoke\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf init --example\n\nBrowserFlow Initialized!\n\nCreated:\n  ✓ browserflow.yaml\n  ✓ specs/example.yaml\n  ✓ .gitignore (updated)\n\nNext steps:\n  1. Edit browserflow.yaml with your project settings\n  2. Write specs in specs/ directory\n  3. Run: bf explore --spec example\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Creates browserflow.yaml with sensible defaults\n- [ ] Creates specs/ directory\n- [ ] Updates .gitignore (doesn't duplicate entries)\n- [ ] --force overwrites existing config\n- [ ] --example creates working example spec\n- [ ] Prints clear next steps","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:22.296770448-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:59:39.388056487-05:00","closed_at":"2026-01-15T21:59:39.388056487-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-jlm","depends_on_id":"bf-vnd","type":"blocks","created_at":"2026-01-15T17:47:14.886038131-05:00","created_by":"ubuntu"}]}
{"id":"bf-lp7","title":"G.1: Implement bf baseline commands","description":"# Task: Implement bf baseline Commands\n\n## Context\nBaseline management commands let users view diff status, accept new baselines, and manage visual regression expectations. Baselines should NEVER update implicitly.\n\n## What to Build\n\\`\\`\\`typescript\n// bf baseline status --spec \u003cname\u003e\n// bf baseline diff --spec \u003cname\u003e\n// bf baseline accept --spec \u003cname\u003e [--run-id \u003cid\u003e] [--all]\n// bf baseline update --spec \u003cname\u003e  (convenience alias for accept from latest)\n\nexport async function baselineStatus(specName: string): Promise\u003cvoid\u003e {\n  const baselines = await getBaselinesForSpec(specName);\n  const latestRun = await getLatestRun(specName);\n  const actuals = await getActualsFromRun(latestRun);\n  \n  console.log(\\`Baseline status for: \\${specName}\\n\\`);\n  \n  for (const baseline of baselines) {\n    const actual = actuals.find(a =\u003e a.name === baseline.name);\n    const status = actual ? await compareImages(baseline.path, actual.path) : 'missing';\n    \n    const icon = status === 'match' ? '✓' : status === 'diff' ? '✗' : '?';\n    console.log(\\`  \\${icon} \\${baseline.name}\\`);\n    if (status === 'diff') {\n      console.log(\\`    → Differs by \\${status.diffPercent}%\\`);\n    }\n  }\n}\n\nexport async function baselineAccept(\n  specName: string,\n  options: { runId?: string; all?: boolean; screenshot?: string }\n): Promise\u003cvoid\u003e {\n  const runId = options.runId || await getLatestRunId(specName);\n  const runDir = getRunDir(specName, runId);\n  \n  // Get actuals from run\n  const actuals = await getActualsFromRun(runDir);\n  \n  // Filter if specific screenshot requested\n  const toAccept = options.screenshot\n    ? actuals.filter(a =\u003e a.name === options.screenshot)\n    : actuals;\n  \n  // Confirm if not --all\n  if (!options.all) {\n    console.log('Screenshots to accept as new baselines:');\n    for (const actual of toAccept) {\n      console.log(\\`  • \\${actual.name}\\`);\n    }\n    const confirmed = await confirm('Accept these baselines?');\n    if (!confirmed) return;\n  }\n  \n  // Copy actuals to baselines\n  for (const actual of toAccept) {\n    const baselinePath = \\`baselines/\\${specName}/\\${actual.name}.png\\`;\n    \n    // Record metadata\n    await recordBaselineAcceptance(baselinePath, {\n      accepted_at: new Date().toISOString(),\n      accepted_by: process.env.USER || 'unknown',\n      run_id: runId,\n      previous_hash: await hashFile(baselinePath).catch(() =\u003e null),\n      current_hash: await hashFile(actual.path)\n    });\n    \n    // Copy file\n    await copyFile(actual.path, baselinePath);\n    console.log(\\`✓ Accepted: \\${actual.name}\\`);\n  }\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bf baseline status\\` shows current state\n- [ ] \\`bf baseline accept\\` requires explicit confirmation\n- [ ] Acceptance records metadata (who, when, from which run)\n- [ ] \\`bf baseline diff\\` opens Review UI with diff gallery\n- [ ] Works with multiple screenshots per spec","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:45:31.999071121-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.442698831-05:00","closed_at":"2026-01-15T23:04:35.442698831-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-lp7","depends_on_id":"bf-qff","type":"blocks","created_at":"2026-01-15T17:47:16.671437881-05:00","created_by":"ubuntu"},{"issue_id":"bf-lp7","depends_on_id":"bf-8k4","type":"blocks","created_at":"2026-01-15T17:47:16.771398602-05:00","created_by":"ubuntu"}]}
{"id":"bf-mtk","title":"I.1: Implement bf repair command","description":"# Task: Implement bf repair Command\n\n## Context\n\\`bf repair\\` loads a failure bundle and guides the user through fixing the broken test. It can suggest deterministic fixes or use AI for more complex repairs.\n\n## What to Build\n\\`\\`\\`typescript\n// bf repair [options]\n// Options:\n//   --spec \u003cname\u003e         Repair specific spec\n//   --from-run \u003cpath\u003e     Path to failure.json\n//   --ai                  Enable AI-assisted repair\n//   --apply               Auto-apply suggestions\n//   --headed              Show browser during repair\n\nexport async function repair(options: RepairOptions): Promise\u003cvoid\u003e {\n  // 1. Load failure bundle\n  const failurePath = options.fromRun || await findLatestFailure(options.spec);\n  const failure = await loadFailureBundle(failurePath);\n  \n  console.log(\\`Repairing: \\${failure.spec_name}\\`);\n  console.log(\\`Failure: \\${failure.failure.error_type} at step \"\\${failure.failure.step_id}\"\\`);\n  console.log(\\`Message: \\${failure.failure.error_message}\\n\\`);\n  \n  // 2. Load current spec and lockfile\n  const spec = await loadSpec(failure.spec_name);\n  const lockfile = await loadLockfile(failure.run_id);\n  \n  // 3. Analyze and generate deterministic suggestions\n  const suggestions = analyzeFailure(failure, lockfile);\n  \n  // 4. (Optional) AI repair proposals\n  if (options.ai) {\n    const aiSuggestions = await aiRepairProposal(failure, spec, lockfile);\n    suggestions.push(...aiSuggestions);\n  }\n  \n  // 5. Present suggestions\n  if (suggestions.length === 0) {\n    console.log('No automatic repair suggestions. Manual intervention needed.');\n    return;\n  }\n  \n  for (const suggestion of suggestions) {\n    console.log(\\`Suggestion: \\${suggestion.description}\\`);\n    console.log(\\`  Type: \\${suggestion.type}\\`);\n    console.log(\\`  Confidence: \\${Math.round(suggestion.confidence * 100)}%\\`);\n  }\n  \n  // 6. Apply or open repair UI\n  if (options.apply) {\n    await applySuggestions(suggestions, lockfile);\n    await regenerateTest(spec, lockfile);\n    await verifyRepair(spec);\n  } else {\n    // Open repair UI\n    await openRepairUI(failure, suggestions);\n  }\n}\n\nfunction analyzeFailure(failure: FailureBundle, lockfile: Lockfile): RepairSuggestion[] {\n  const suggestions: RepairSuggestion[] = [];\n  \n  switch (failure.failure.error_type) {\n    case 'locator_not_found':\n      // Try fallback locators\n      const locator = lockfile.locators[failure.failure.step_id];\n      if (locator.fallbacks.length \u003e 0) {\n        suggestions.push({\n          type: 'use_fallback',\n          description: 'Try fallback locator',\n          confidence: 0.8,\n          patch: { preferred: locator.fallbacks[0] }\n        });\n      }\n      break;\n      \n    case 'timeout':\n      suggestions.push({\n        type: 'increase_timeout',\n        description: 'Double the timeout',\n        confidence: 0.6\n      });\n      break;\n      \n    case 'screenshot_diff':\n      suggestions.push({\n        type: 'update_baseline',\n        description: 'Accept new baseline',\n        confidence: 0.5\n      });\n      suggestions.push({\n        type: 'add_mask',\n        description: 'Add mask for changed region',\n        confidence: 0.7\n      });\n      break;\n  }\n  \n  return suggestions;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Loads failure bundle correctly\n- [ ] Deterministic suggestions work (fallbacks, timeout)\n- [ ] AI suggestions when --ai flag\n- [ ] Human approval required before applying\n- [ ] Regenerates test after repair\n- [ ] Verification run confirms fix","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-15T17:46:09.072264268-05:00","created_by":"ubuntu","updated_at":"2026-01-15T23:04:35.444099089-05:00","closed_at":"2026-01-15T23:04:35.444099089-05:00","close_reason":"Implemented all three commands with TDD approach: bf lint validates specs with line numbers and actionable errors, bf baseline manages visual regression baselines with status/accept/update/diff subcommands, bf repair loads failure bundles and generates deterministic repair suggestions","dependencies":[{"issue_id":"bf-mtk","depends_on_id":"bf-dcs","type":"blocks","created_at":"2026-01-15T17:47:16.964901908-05:00","created_by":"ubuntu"}]}
{"id":"bf-n3d","title":"Epic J: Documentation \u0026 Examples","description":"# Epic J: Documentation \u0026 Examples\n\n## Strategic Context\n\n**\"Install in minutes; minimal project changes required\"** is only possible with excellent documentation. This epic makes BrowserFlow accessible to new users without hand-holding.\n\n## Why This Matters\n\nGreat tools fail without great docs. BrowserFlow's workflow (spec → explore → review → generate → run → repair) is novel - users need guidance.\n\nGoals:\n- Zero-to-first-test in \u003c10 minutes\n- Self-service troubleshooting\n- CI integration \"just works\"\n\n## Deliverables\n\n1. **Getting started guide**:\n   - Installation\n   - First spec\n   - First exploration\n   - Review walkthrough\n   - CI setup\n2. **Configuration reference**:\n   - All browserflow.yaml options\n   - Environment variables\n   - Per-spec overrides\n3. **API reference** (for programmatic use):\n   - Core types\n   - Adapter interface\n4. **Example project**:\n   - Demo web app\n   - Multiple specs covering different patterns\n   - Pre-recorded exploration for offline testing\n5. **CI templates**:\n   - GitHub Actions\n   - GitLab CI\n   - Generic shell script\n6. **Inline CLI help**:\n   - \\`bf \u003ccmd\u003e --help\\` is comprehensive\n   - Examples in help text\n\n## Acceptance Criteria\n\n- [ ] New user can follow getting-started and have working test in \u003c10 minutes\n- [ ] All configuration options documented\n- [ ] Example project runs successfully\n- [ ] GitHub Actions template works on real repo\n- [ ] GitLab CI template works on real repo\n- [ ] --help output is comprehensive and accurate\n\n## Dependencies\n\n- **Depends on all other epics** - Can't document what doesn't exist\n- Can start in parallel with examples/templates\n\n## Documentation Principles\n\nFrom the spec:\n- **Progressive disclosure**: Start simple, link to advanced\n- **Actionable errors**: Every error message has a fix\n- **Examples over prose**: Show, don't just tell\n\n## Structure\n\n\\`\\`\\`\ndocs/\n├── getting-started.md      # 10-minute quickstart\n├── configuration.md        # All config options\n├── spec-format.md          # YAML v2 schema guide\n├── cli-reference.md        # All bf commands\n├── review-ui.md            # Review UI guide\n├── repair-mode.md          # Maintenance workflow\n├── ci-integration.md       # CI setup guides\n└── api-reference.md        # Programmatic usage\n\nexamples/\n└── demo-app/\n    ├── README.md           # How to run the example\n    ├── src/                # Simple web app\n    ├── specs/\n    │   ├── homepage.yaml\n    │   ├── login.yaml\n    │   └── checkout.yaml\n    └── browserflow.yaml\n\\`\\`\\`\n\n## CI Template (GitHub Actions)\n\n\\`\\`\\`yaml\nname: E2E Tests\non: [push, pull_request]\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: oven-sh/setup-bun@v1\n      \n      - name: Install BrowserFlow\n        run: bun add -g browserflow\n        \n      - name: Install Playwright browsers\n        run: bunx playwright install --with-deps chromium\n        \n      - name: Start app\n        run: bun run dev \u0026\n        \n      - name: Run tests\n        run: bf run\n        \n      - name: Upload failure artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: browserflow-failures\n          path: .browserflow/runs/**/failure.json\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 14: CLI Specification (--help content)\n- Section 22: Definitions of Done (documentation requirements)","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-15T17:37:02.407431094-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.741745293-05:00","closed_at":"2026-01-16T17:18:41.741745293-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-n3d","depends_on_id":"bf-bwv","type":"blocks","created_at":"2026-01-15T17:47:01.164510079-05:00","created_by":"ubuntu"}]}
{"id":"bf-o9t","title":"C.1: Create @browserflow/exploration package","description":"# Task: Create Exploration Package\n\n## Context\nThe exploration package contains the AI-powered exploration engine that drives a browser to execute spec steps and collect evidence.\n\n## What to Build\n\\`\\`\\`\npackages/exploration/\n├── src/\n│   ├── index.ts              # Public exports\n│   ├── explorer.ts           # Main orchestrator\n│   ├── step-executor.ts      # Execute individual steps\n│   ├── evidence.ts           # Screenshot/trace capture\n│   ├── locator-candidates.ts # Generate locator options\n│   └── adapters/\n│       ├── index.ts\n│       ├── types.ts          # AIAdapter interface\n│       └── claude.ts         # Claude implementation\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/exploration\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"agent-browser\": \"^0.5.0\",\n    \"@anthropic-ai/sdk\": \"^0.26.0\"\n  }\n}\n\\`\\`\\`\n\n## Main Export\n\\`\\`\\`typescript\nexport { Explorer } from './explorer';\nexport { ClaudeAdapter } from './adapters/claude';\nexport type { AIAdapter, ExploreParams, ExplorationOutput } from './adapters/types';\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Package compiles\n- [ ] Imports from agent-browser work\n- [ ] Adapter interface defined\n- [ ] Exports accessible from CLI package","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:41:24.268831416-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:36:44.951588173-05:00","closed_at":"2026-01-15T21:36:44.951588173-05:00","close_reason":"Closed"}
{"id":"bf-p8r","title":"Epic B: CLI Foundation","description":"# Epic B: CLI Foundation\n\n## Strategic Context\n\nThe CLI is the **primary interface** between developers and BrowserFlow. A well-designed CLI establishes the UX patterns that will carry through to all features. We're building \"bf\" as a single entry point with subcommands.\n\n## Why This Matters\n\n**Low setup overhead** is a product goal. The CLI must:\n- Be discoverable (great --help output)\n- Provide actionable feedback (not raw errors)\n- Guide users to next steps\n- Work consistently across platforms\n\nThe commands we build here (\\`init\\`, \\`doctor\\`, \\`lint\\`) are the **onboarding experience**. If these are polished, users trust the tool.\n\n## Deliverables\n\n1. **bf command** with Commander.js\n2. **bf init** - Creates project structure:\n   - browserflow.yaml (config)\n   - specs/ directory\n   - .gitignore entries for .browserflow/\n   - Example spec (optional)\n3. **bf doctor** - Environment checker:\n   - Node.js version (\u003e=18)\n   - agent-browser installation\n   - Playwright browsers installed\n   - Config validity\n   - Port availability\n4. **bf lint** - Spec validator:\n   - Schema compliance\n   - Required fields (version, name, steps, step ids)\n   - Duration string format\n   - No duplicate step IDs\n   - Actionable error messages\n\n## Acceptance Criteria\n\n- [ ] \\`bf init\\` creates correct directory structure\n- [ ] \\`bf init --example\\` includes working example spec\n- [ ] \\`bf doctor\\` identifies missing dependencies with fix instructions\n- [ ] \\`bf lint\\` catches schema violations with line numbers\n- [ ] Exit codes are correct (0=success, 1=error, 2=args, 3=validation)\n- [ ] \\`--json\\` output mode works for scripting\n- [ ] Colors/formatting work in terminal\n\n## Dependencies\n\n- **Depends on Epic A** - Needs core types and schemas\n\n## Technical Decisions\n\n**Why Commander.js?**\n- Simple, well-documented\n- Widespread adoption means familiar patterns\n- Good TypeScript support\n- Subcommand support built-in\n\n**CLI UX Guidelines (from spec):**\n- Crisp output: minimal, informative\n- Consistent formatting: icons, colors, indentation\n- Next steps: always suggest what to do next\n- Never dump raw JSON unless --json flag\n\n## User Journey\n\n\\`\\`\\`\nDeveloper discovers BrowserFlow\n    ↓\nRuns: bf init\n    ↓\nGets: Clean project structure with example\n    ↓\nRuns: bf doctor\n    ↓\nGets: \"All dependencies OK\" or \"Install X with: \u003ccommand\u003e\"\n    ↓\nWrites: specs/my-test.yaml\n    ↓\nRuns: bf lint\n    ↓\nGets: \"Valid!\" or \"Line 12: missing required field 'id'\"\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 14: CLI Specification\n- Section 15: Configuration\n- Section 22: Definitions of Done (CLI requirements)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:34:04.712526118-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.720609435-05:00","closed_at":"2026-01-16T17:18:41.720609435-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-p8r","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:46:59.799053338-05:00","created_by":"ubuntu"}]}
{"id":"bf-qff","title":"F.1: Implement bf run command","description":"# Task: Implement bf run Command\n\n## Context\n\\`bf run\\` wraps Playwright Test execution, collecting artifacts into the BrowserFlow run directory structure and producing human-friendly output.\n\n## What to Build\n\\`\\`\\`typescript\n// bf run [options] [specs...]\n// Options:\n//   --spec \u003cname\u003e     Run specific spec\n//   --tag \u003ctag\u003e       Filter by tag\n//   --parallel \u003cn\u003e    Worker count\n//   --headed          Show browser\n//   --trace \u003cmode\u003e    on | off | on-first-retry\n\nimport { spawn } from 'child_process';\n\nexport async function run(options: RunOptions): Promise\u003cRunResult\u003e {\n  const runStore = new RunStore();\n  \n  // 1. Determine which specs to run\n  const specs = await resolveSpecs(options);\n  \n  // 2. Create run directory for this execution\n  const runDir = await runStore.createRun('_execution');\n  \n  // 3. Build Playwright command\n  const args = [\n    'playwright', 'test',\n    '--config', 'e2e/playwright.config.ts',\n    '--reporter', 'json',\n    '--output', path.join(runDir, 'artifacts')\n  ];\n  \n  if (options.parallel) {\n    args.push('--workers', String(options.parallel));\n  }\n  if (options.headed) {\n    args.push('--headed');\n  }\n  if (options.trace) {\n    args.push('--trace', options.trace);\n  }\n  \n  // Add spec filters\n  for (const spec of specs) {\n    args.push(\\`e2e/tests/\\${spec}.spec.ts\\`);\n  }\n  \n  // 4. Execute\n  const result = await executePlaywright(args);\n  \n  // 5. Collect results and generate summary\n  const summary = await collectResults(runDir, result);\n  \n  // 6. Print human-friendly output\n  printRunSummary(summary);\n  \n  // 7. If failures, generate failure bundles\n  if (summary.failed \u003e 0) {\n    await generateFailureBundles(runDir, summary.failures);\n  }\n  \n  return summary;\n}\n\\`\\`\\`\n\n## CLI Output\n\\`\\`\\`\n$ bf run --spec checkout-cart\n\nRunning: checkout-cart\n\n  checkout-cart\n    ✓ add_first_product (1.2s)\n    ✓ cart_toast (0.8s)\n    ✓ open_cart (0.5s)\n    ✓ verify_cart_state (0.3s)\n    ✓ cart_visual (1.5s)\n    ✓ proceed_checkout (0.9s)\n    ✓ verify_checkout_state (0.4s)\n\n  7 passed (5.6s)\n\nRun complete. Results at: .browserflow/runs/_execution/run-xxx/\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Runs generated Playwright tests\n- [ ] Collects artifacts to .browserflow/runs/\n- [ ] Human-friendly step-by-step output\n- [ ] --parallel maps to Playwright workers\n- [ ] --headed shows browser\n- [ ] Exit code 5 on test failure","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:44:57.394154328-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:38:02.022981521-05:00","closed_at":"2026-01-15T21:38:02.022981521-05:00","close_reason":"Closed"}
{"id":"bf-u2n","title":"Epic E: Generator","description":"# Epic E: Generator (Playwright TypeScript)\n\n## Strategic Context\n\nThe generator is where **lockfile becomes code**. This is the transition from human-approved decisions to deterministic, runnable tests. No AI involved - pure code generation from structured data.\n\n## Why This Matters\n\n**Deterministic CI execution** is a core product goal. The generated tests must:\n- Produce the same result every run\n- Never call AI during execution\n- Use the exact locators approved in review\n- Generate proper artifacts on failure\n\nThis is also where BrowserFlow's **value proposition crystallizes**: you paid tokens once during exploration/review, now tests run forever for free.\n\n## Deliverables\n\n1. **@browserflow/generator package**\n2. **Playwright TS test generator**:\n   - Convert lockfile to test file\n   - Emit \\`test.step()\\` for each step\n   - Include comments with original intent\n   - Add generation metadata header\n3. **Locator-to-code converter**:\n   - LocatorObject → Playwright locator chain\n   - Handle scoping (within, nth)\n   - Prefer testid \u003e role \u003e css\n4. **Visual check generator**:\n   - \\`toHaveScreenshot()\\` with masks\n   - Threshold from lockfile\n5. **Config generator**:\n   - Create playwright.config.ts if absent\n   - Configure trace, video, reporters\n\n## Acceptance Criteria\n\n- [ ] Generated tests compile with TypeScript\n- [ ] Generated tests run deterministically\n- [ ] Visual checks include masks and thresholds\n- [ ] Tests produce trace on failure\n- [ ] Generation metadata in file header\n- [ ] \\`bf generate --spec X\\` creates e2e/tests/X.spec.ts\n- [ ] Existing tests not overwritten without --force\n\n## Dependencies\n\n- **Depends on Epic A** - Core types, lockfile schema\n- **Depends on Epic D** - Lockfile output from review\n\n## Technical Decisions\n\n**Why Playwright Test specifically?**\n- Industry standard, excellent documentation\n- Built-in visual comparison (\\`toHaveScreenshot\\`)\n- Native trace recording\n- Parallel execution\n- Great TypeScript support\n\n**Generated test structure:**\n\\`\\`\\`typescript\ntest.describe('checkout-cart', () =\u003e {\n  test('checkout-cart', async ({ page }) =\u003e {\n    // Step: add_first_product\n    await test.step('add_first_product', async () =\u003e {\n      await page.getByTestId('add-to-cart').click();\n    });\n    \n    // Step: cart_visual\n    await test.step('cart_visual', async () =\u003e {\n      await expect(page).toHaveScreenshot('cart-with-item.png', {\n        mask: [page.locator('.timestamp')],\n        maxDiffPixelRatio: 0.05,\n      });\n    });\n  });\n});\n\\`\\`\\`\n\n**Locator generation rules:**\n\\`\\`\\`typescript\nfunction generateLocator(locator: LocatorObject): string {\n  let code = 'page';\n  \n  // Apply scoping first\n  if (locator.scoping?.within) {\n    code += generateStrategy(locator.scoping.within[0]);\n  }\n  \n  // Apply preferred strategy\n  code += generateStrategy(locator.preferred);\n  \n  // Apply nth if needed\n  if (locator.scoping?.nth !== undefined) {\n    code += locator.scoping.nth === 0 ? '.first()' : \\`.nth(\\${locator.scoping.nth})\\`;\n  }\n  \n  return code;\n}\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 10: Generation Phase\n- Section 11: Runtime \u0026 Runner (generated tests are run)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-15T17:35:14.717950617-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.729439415-05:00","closed_at":"2026-01-16T17:18:41.729439415-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-u2n","depends_on_id":"bf-71k","type":"blocks","created_at":"2026-01-15T17:47:00.247352105-05:00","created_by":"ubuntu"},{"issue_id":"bf-u2n","depends_on_id":"bf-9ei","type":"blocks","created_at":"2026-01-15T17:47:00.338432927-05:00","created_by":"ubuntu"}]}
{"id":"bf-vnd","title":"B.1: Set up CLI package with Commander.js","description":"# Task: Set Up CLI Package with Commander.js\n\n## Context\nThe CLI is the primary interface to BrowserFlow. We use Commander.js for argument parsing and subcommand handling. This task sets up the package structure and command framework.\n\n## What to Build\n\\`\\`\\`\npackages/cli/\n├── src/\n│   ├── index.ts           # Entry point\n│   ├── commands/\n│   │   ├── init.ts\n│   │   ├── doctor.ts\n│   │   ├── lint.ts\n│   │   └── ... (others added in later tasks)\n│   └── ui/\n│       ├── spinner.ts     # Progress indicators\n│       ├── colors.ts      # Chalk wrapper\n│       └── prompts.ts     # User interaction\n├── bin/\n│   └── bf.js              # Shebang entry\n├── package.json\n└── tsconfig.json\n\\`\\`\\`\n\n## package.json\n\\`\\`\\`json\n{\n  \"name\": \"@browserflow/cli\",\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"bf\": \"./bin/bf.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\"\n  },\n  \"dependencies\": {\n    \"@browserflow/core\": \"workspace:*\",\n    \"commander\": \"^11.0.0\",\n    \"chalk\": \"^5.3.0\",\n    \"ora\": \"^7.0.0\"\n  }\n}\n\\`\\`\\`\n\n## bin/bf.js\n\\`\\`\\`javascript\n#!/usr/bin/env node\nimport '../dist/index.js';\n\\`\\`\\`\n\n## src/index.ts\n\\`\\`\\`typescript\nimport { Command } from 'commander';\nimport { version } from '../package.json';\n\nconst program = new Command();\n\nprogram\n  .name('bf')\n  .description('BrowserFlow - Human-in-the-Loop E2E Test Generation')\n  .version(version);\n\n// Subcommands added by other tasks\nprogram.command('init').description('Initialize BrowserFlow');\nprogram.command('doctor').description('Check environment');\nprogram.command('lint').description('Validate specs');\n// ... etc\n\nprogram.parse();\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] \\`bf --help\\` shows all commands\n- [ ] \\`bf --version\\` shows version\n- [ ] Commands are modular (one file per command)\n- [ ] Colors work in terminal\n- [ ] Builds and runs via \\`bun run dev\\`","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:40:05.467852311-05:00","created_by":"ubuntu","updated_at":"2026-01-15T21:34:58.817312149-05:00","closed_at":"2026-01-15T21:34:58.817312149-05:00","close_reason":"Closed"}
{"id":"bf-x1q","title":"A.4: Implement duration string parser","description":"# Task: Implement Duration String Parser\n\n## Context\nAll timeouts and durations in BrowserFlow use human-readable strings like \"3s\", \"2m\", \"500ms\". This utility converts them to milliseconds for use with Playwright APIs.\n\n## What to Build\n\\`\\`\\`typescript\n// Parse duration string to milliseconds\nfunction parseDuration(input: string): number;\n\n// Format milliseconds back to canonical string\nfunction formatDuration(ms: number): string;\n\n// Validate without parsing (for schema validation)\nfunction isValidDuration(input: string): boolean;\n\\`\\`\\`\n\n## Supported Formats (from Appendix C)\n| Input | Output (ms) |\n|-------|-------------|\n| 500ms | 500 |\n| 3s | 3000 |\n| 2m | 120000 |\n| 1h | 3600000 |\n| 1m30s | 90000 |\n| 1h30m | 5400000 |\n\n## Implementation\n\\`\\`\\`typescript\nconst UNITS: Record\u003cstring, number\u003e = {\n  ms: 1,\n  s: 1000,\n  m: 60 * 1000,\n  h: 60 * 60 * 1000,\n};\n\nexport function parseDuration(input: string): number {\n  if (typeof input !== 'string' || !input.trim()) {\n    throw new Error('Duration must be a non-empty string');\n  }\n  \n  const regex = /(\\d+)(ms|s|m|h)/g;\n  let total = 0;\n  let match;\n  let hasMatch = false;\n  \n  while ((match = regex.exec(input)) !== null) {\n    hasMatch = true;\n    const [, value, unit] = match;\n    total += parseInt(value, 10) * UNITS[unit];\n  }\n  \n  if (!hasMatch) {\n    throw new Error(\n      \\`Invalid duration \"\\${input}\". Use format like \"3s\", \"2m\", \"500ms\", or \"1m30s\"\\`\n    );\n  }\n  \n  return total;\n}\n\nexport function formatDuration(ms: number): string {\n  if (ms \u003c 1000) return \\`\\${ms}ms\\`;\n  if (ms \u003c 60000) return \\`\\${ms / 1000}s\\`;\n  if (ms \u003c 3600000) return \\`\\${ms / 60000}m\\`;\n  return \\`\\${ms / 3600000}h\\`;\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] Parses all documented formats correctly\n- [ ] Throws clear error for invalid input like \"3 seconds\" or \"abc\"\n- [ ] formatDuration() produces canonical shortest form\n- [ ] Unit tests cover: basic units, combinations, edge cases, errors\n- [ ] Zero/negative handling documented","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-15T17:38:46.785472918-05:00","created_by":"ubuntu","updated_at":"2026-01-15T22:27:55.063679429-05:00","closed_at":"2026-01-15T22:27:55.063679429-05:00","close_reason":"Closed","dependencies":[{"issue_id":"bf-x1q","depends_on_id":"bf-cds","type":"blocks","created_at":"2026-01-15T17:47:14.435436508-05:00","created_by":"ubuntu"}]}
{"id":"bf-xx5","title":"Epic F: Runner \u0026 Failure Bundles","description":"# Epic F: Runner \u0026 Failure Bundles\n\n## Strategic Context\n\nThe runner wraps Playwright execution and produces **failure bundles** that enable repair mode. This is critical for the maintenance story - when tests break, developers need actionable information.\n\n## Why This Matters\n\n**\"Failures are actionable with rich artifacts\"** is a product goal.\n\nA failure bundle must contain everything needed to:\n1. Understand what failed and why\n2. See the UI state at failure time\n3. Reproduce the issue locally\n4. Potentially auto-fix with repair mode\n\nWithout good failure bundles, broken tests become time sinks.\n\n## Deliverables\n\n1. **bf run command** - Wraps Playwright Test\n2. **Artifact collection** - Gather into .browserflow/runs/\n3. **Failure bundle generation**:\n   - trace.zip (Playwright trace)\n   - screenshots/failure.png\n   - diffs/ (baseline vs actual vs diff)\n   - logs/console.json\n   - logs/network.json\n   - failure.json (machine-readable summary)\n4. **Human-friendly CLI output**:\n   - Step-by-step progress\n   - Clear failure messages\n   - \"Next steps\" suggestions\n5. **Exit codes** per spec section 14.4\n\n## Acceptance Criteria\n\n- [ ] \\`bf run\\` executes generated tests\n- [ ] Failing tests produce complete failure bundles\n- [ ] CLI output shows pass/fail per step\n- [ ] \"Next steps\" suggests \\`bf repair\\` on failure\n- [ ] Artifacts are in .browserflow/runs/spec/run-id/\n- [ ] \\`--parallel N\\` maps to Playwright workers\n- [ ] \\`--headed\\` shows browser window\n- [ ] Exit codes match spec (0=pass, 5=test fail)\n\n## Dependencies\n\n- **Depends on Epic E** - Generated tests to run\n\n## Technical Decisions\n\n**Why wrap Playwright instead of using it directly?**\n- Collect artifacts into our run directory structure\n- Generate failure.json in our format\n- Add \"next steps\" and repair suggestions\n- Maintain immutable run history\n\n**Failure bundle structure:**\n\\`\\`\\`\n.browserflow/runs/checkout-cart/run-xxx/\n├── failure.json          # Machine-readable\n├── artifacts/\n│   ├── trace.zip         # Playwright trace\n│   ├── screenshots/\n│   │   └── failure.png\n│   ├── diffs/\n│   │   ├── cart-with-item-baseline.png\n│   │   ├── cart-with-item-actual.png\n│   │   └── cart-with-item-diff.png\n│   └── logs/\n│       ├── console.json\n│       └── network.json\n\\`\\`\\`\n\n**failure.json schema:**\n\\`\\`\\`json\n{\n  \"run_id\": \"run-xxx\",\n  \"spec_name\": \"checkout-cart\",\n  \"failure\": {\n    \"step_id\": \"cart_visual\",\n    \"action\": \"screenshot\",\n    \"error_type\": \"screenshot_diff\",\n    \"error_message\": \"Screenshot differs by 12.3%\"\n  },\n  \"artifacts\": {\n    \"trace\": \"artifacts/trace.zip\",\n    \"diff\": { ... }\n  },\n  \"suggestions\": [\n    { \"type\": \"update_baseline\", \"confidence\": 0.8 }\n  ]\n}\n\\`\\`\\`\n\n## CLI Output Example\n\n\\`\\`\\`\n┌────────────────────────────────────────────────────────┐\n│  BrowserFlow Test Results                               │\n├────────────────────────────────────────────────────────┤\n│  checkout-cart ──────────────────────────────────────  │\n│    ✓ add_first_product (1.2s)                          │\n│    ✓ cart_toast (0.8s)                                 │\n│    ✗ cart_visual (2.1s)                                │\n│      Screenshot differs from baseline by 12.3%         │\n│                                                        │\n│  1 failed │ 2 passed │ 4.1s total                      │\n│                                                        │\n│  Next steps:                                           │\n│    • bf baseline accept --spec checkout-cart           │\n│    • bf repair --spec checkout-cart                    │\n└────────────────────────────────────────────────────────┘\n\\`\\`\\`\n\n## Related Spec Sections\n\n- Section 11: Runtime \u0026 Runner\n- Section 12: Repair Mode (uses failure bundles)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T17:35:38.559658619-05:00","created_by":"ubuntu","updated_at":"2026-01-16T17:18:41.732075934-05:00","closed_at":"2026-01-16T17:18:41.732075934-05:00","close_reason":"All tasks completed","dependencies":[{"issue_id":"bf-xx5","depends_on_id":"bf-u2n","type":"blocks","created_at":"2026-01-15T17:47:00.423629045-05:00","created_by":"ubuntu"}]}
